// import type { LiveStoreSchema } from '@livestore/livestore'
// import { Schema } from '@livestore/livestore'
//
// /**
//  * Represents a single SQL statement extracted from an event materializer.
//  */
// export interface EventSqlStatement {
//   /** The generated SQL statement */
//   readonly sql: string
//   /** The bound parameter values for the statement */
//   readonly bindValues: Record<string, unknown>
//   /** Set of tables that this statement writes to (undefined if not tracked) */
//   readonly writeTables: ReadonlySet<string> | undefined
// }
//
// /**
//  * Result of extracting SQL from a single event.
//  */
// export interface EventSqlResult {
//   /** The event name (e.g., 'v1.TodoCreated') */
//   readonly eventName: string
//   /** The global sequence number of this event */
//   readonly seqNum: number
//   /** All SQL statements generated by this event's materializer */
//   readonly statements: ReadonlyArray<EventSqlStatement>
// }
//
// /**
//  * Extracts SQL statements from a single event.
//  */
// function extractEventSql(
//   event: { name: string; args: unknown; seqNum: number; parentSeqNum: number; clientId: string; sessionId: string },
//   schema: LiveStoreSchema,
// ): EventSqlResult | undefined {
//   const eventDef = schema.eventsDefsMap.get(event.name)
//   if (eventDef === undefined) {
//     return undefined
//   }
//
//   const materializer = schema.state.materializers.get(event.name)
//   if (materializer === undefined) {
//     return undefined
//   }
//
//   const decodedArgs = Schema.decodeUnknownSync(eventDef.schema)(event.args)
//
//   const materializerResult = materializer(decodedArgs, {
//     eventDef,
//     query: () => [],
//     currentFacts: new Map(),
//     // @ts-expect-error - event property is assigned correctly but TypeScript doesn't recognize it
//     event: {
//       name: event.name,
//       args: decodedArgs,
//       seqNum: { global: event.seqNum, client: 0, rebaseGeneration: 0 },
//       parentSeqNum: { global: event.parentSeqNum, client: 0, rebaseGeneration: 0 },
//       clientId: event.clientId,
//       sessionId: event.sessionId,
//     },
//   })
//
//   const statements = fromMaterializerResult(materializerResult)
//
//   return {
//     eventName: event.name,
//     seqNum: event.seqNum,
//     statements,
//   }
// }
//
// /**
//  * Extracts SQL statements from a batch of events.
//  */
// export function extractBatchEventSql(
//   events: ReadonlyArray<{ name: string; args: unknown; seqNum: number; parentSeqNum: number; clientId: string; sessionId: string }>,
//   schema: LiveStoreSchema,
// ): ReadonlyArray<EventSqlResult> {
//   const results: EventSqlResult[] = []
//
//   for (const event of events) {
//     const result = extractEventSql(event, schema)
//     if (result !== undefined) {
//       results.push(result)
//     }
//   }
//
//   return results
// }
//
// /**
//  * Converts materializer output to a normalized statement array.
//  */
// function fromMaterializerResult(
//   materializerResult: unknown,
// ): ReadonlyArray<EventSqlStatement> {
//   const normalize = (input: unknown): EventSqlStatement => {
//     // Handle QueryBuilder (has asSql method)
//     if (
//       typeof input === 'object' &&
//       input !== null &&
//       'asSql' in input &&
//       typeof (input as Record<string, unknown>).asSql === 'function'
//     ) {
//       const { query: sql, bindValues, usedTables } = (input as { asSql: () => { query: string; bindValues: Record<string, unknown>; usedTables: ReadonlySet<string> | undefined } }).asSql()
//       return { sql, bindValues, writeTables: usedTables }
//     }
//
//     // Handle object with sql property
//     if (typeof input === 'object' && input !== null && 'sql' in input) {
//       const obj = input as { sql: string; bindValues?: Record<string, unknown>; writeTables?: ReadonlySet<string> }
//       return {
//         sql: obj.sql,
//         bindValues: obj.bindValues ?? {},
//         writeTables: obj.writeTables,
//       }
//     }
//
//     // Handle raw string
//     if (typeof input === 'string') {
//       return { sql: input, bindValues: {}, writeTables: undefined }
//     }
//
//     // Fallback
//     return { sql: '', bindValues: {}, writeTables: undefined }
//   }
//
//   if (Array.isArray(materializerResult)) {
//     return materializerResult.flatMap(normalize)
//   }
//   return [normalize(materializerResult)]
// }
//
// /**
//  * Formats SQL statements for logging.
//  */
// export function formatEventSqlForLogging(result: EventSqlResult): string {
//   const parts: string[] = []
//
//   parts.push(`Event: ${result.eventName} (seqNum: ${result.seqNum})`)
//   parts.push('---')
//
//   for (const stmt of result.statements) {
//     parts.push(`SQL: ${stmt.sql}`)
//     parts.push(`Bind values: ${JSON.stringify(stmt.bindValues)}`)
//     if (stmt.writeTables) {
//       parts.push(`Tables: ${[...stmt.writeTables].join(', ')}`)
//     }
//     parts.push('')
//   }
//
//   return parts.join('\n')
// }
//
// /**
//  * Logs extracted SQL statements to the console.
//  */
// export function logExtractedSql(
//   events: ReadonlyArray<{ name: string; args: unknown; seqNum: number; parentSeqNum: number; clientId: string; sessionId: string }>,
//   schema: LiveStoreSchema,
// ): void {
//   const results = extractBatchEventSql(events, schema)
//
//   if (results.length === 0) {
//     console.log('No materializable events found')
//     return
//   }
//
//   console.log('\n========================================')
//   console.log('EXTRACTED SQL FROM EVENTS')
//   console.log('========================================\n')
//
//   for (const result of results) {
//     console.log(formatEventSqlForLogging(result))
//     console.log('----------------------------------------')
//   }
//
//   console.log('\n')
// }
//
// /**
//  * Prepares extracted SQL for transmission to another worker.
//  * Returns JSON-serializable data structure.
//  */
// export function prepareForWorkerTransmission(
//   events: ReadonlyArray<{ name: string; args: unknown; seqNum: number; parentSeqNum: number; clientId: string; sessionId: string }>,
//   schema: LiveStoreSchema,
// ): ReadonlyArray<{
//   eventName: string
//   seqNum: number
//   statements: ReadonlyArray<{
//     sql: string
//     bindValues: Record<string, unknown>
//     writeTables: readonly string[] | null
//   }>
// }> {
//   const results = extractBatchEventSql(events, schema)
//
//   return results.map((result) => ({
//     eventName: result.eventName,
//     seqNum: result.seqNum,
//     statements: result.statements.map((stmt) => ({
//       sql: stmt.sql,
//       bindValues: stmt.bindValues,
//       writeTables: stmt.writeTables ? [...stmt.writeTables] : null,
//     })),
//   }))
// }

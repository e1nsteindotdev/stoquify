import { SessionIdSymbol } from '@livestore/common';
import { State } from '@livestore/common/schema';
import { queryDb } from '@livestore/livestore';
import { shouldNeverHappen } from '@livestore/utils';
import React from 'react';
import { LiveStoreContext } from './LiveStoreContext.js';
import { useQueryRef } from './useQuery.js';
/**
 * Similar to `React.useState` but returns a tuple of `[state, setState, id, query$]` for a given table where ...
 *
 *   - `state` is the current value of the row (fully decoded according to the table schema)
 *   - `setState` is a function that can be used to update the document
 *   - `id` is the id of the document
 *   - `query$` is a `LiveQuery` that e.g. can be used to subscribe to changes to the document
 *
 * `useClientDocument` only works for client-document tables:
 *
 * ```tsx
 * const MyState = State.SQLite.clientDocument({
 *   name: 'MyState',
 *   schema: Schema.Struct({
 *     showSidebar: Schema.Boolean,
 *   }),
 *   default: { id: SessionIdSymbol, value: { showSidebar: true } },
 * })
 *
 * const MyComponent = () => {
 *   const [{ showSidebar }, setState] = useClientDocument(MyState)
 *   return (
 *     <div onClick={() => setState({ showSidebar: !showSidebar })}>
 *       {showSidebar ? 'Sidebar is open' : 'Sidebar is closed'}
 *     </div>
 *   )
 * }
 * ```
 *
 * If the table has a default id, `useClientDocument` can be called without an `id` argument. Otherwise, the `id` argument is required.
 */
export const useClientDocument = (table, idOrOptions, options_, storeArg) => {
    const id = typeof idOrOptions === 'string' || idOrOptions === SessionIdSymbol
        ? idOrOptions
        : table[State.SQLite.ClientDocumentTableDefSymbol].options.default.id;
    const options = typeof idOrOptions === 'string' || idOrOptions === SessionIdSymbol ? options_ : idOrOptions;
    const { default: defaultValues } = options ?? {};
    React.useMemo(() => validateTableOptions(table), [table]);
    const tableName = table.sqliteDef.name;
    const store = storeArg?.store ??
        // eslint-disable-next-line react-hooks/rules-of-hooks
        React.useContext(LiveStoreContext)?.store ??
        shouldNeverHappen(`No store provided to useClientDocument`);
    // console.debug('useClientDocument', tableName, id)
    const idStr = id === SessionIdSymbol ? store.clientSession.sessionId : id;
    const queryDef = React.useMemo(() => queryDb(table.get(id, { default: defaultValues }), {
        deps: [idStr, table.sqliteDef.name, JSON.stringify(defaultValues)],
    }), [table, id, defaultValues, idStr]);
    const queryRef = useQueryRef(queryDef, {
        otelSpanName: `LiveStore:useClientDocument:${tableName}:${idStr}`,
        store: storeArg?.store,
    });
    const setState = React.useMemo(() => (newValueOrFn) => {
        const newValue = typeof newValueOrFn === 'function' ? newValueOrFn(queryRef.valueRef.current) : newValueOrFn;
        if (queryRef.valueRef.current === newValue)
            return;
        store.commit(table.set(removeUndefinedValues(newValue), id));
    }, [id, queryRef.valueRef, store, table]);
    return [queryRef.valueRef.current, setState, idStr, queryRef.queryRcRef.value];
};
const validateTableOptions = (table) => {
    if (State.SQLite.tableIsClientDocumentTable(table) === false) {
        return shouldNeverHappen(`useClientDocument called on table "${table.sqliteDef.name}" which is not a client document table`);
    }
};
const removeUndefinedValues = (value) => {
    if (typeof value === 'object' && value !== null) {
        return Object.fromEntries(Object.entries(value).filter(([_, v]) => v !== undefined));
    }
    return value;
};
//# sourceMappingURL=useClientDocument.js.map
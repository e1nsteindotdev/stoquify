import { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { provideOtel, UnexpectedError } from '@livestore/common';
import { createStore, makeShutdownDeferred, StoreInterrupted } from '@livestore/livestore';
import { errorToString, IS_REACT_NATIVE, LS_DEV } from '@livestore/utils';
import { Cause, Deferred, Effect, Exit, identity, Logger, LogLevel, Schema, Scope, TaskTracing, } from '@livestore/utils/effect';
import React from 'react';
import { LiveStoreContext } from './LiveStoreContext.js';
const defaultRenderError = (error) => IS_REACT_NATIVE ? _jsx(_Fragment, {}) : _jsx(_Fragment, { children: Schema.is(UnexpectedError)(error) ? error.toString() : errorToString(error) });
const defaultRenderShutdown = (cause) => {
    const reason = cause._tag === 'LiveStore.StoreInterrupted'
        ? `interrupted due to: ${cause.reason}`
        : cause.reason === 'devtools-import'
            ? 'devtools import'
            : cause.reason === 'devtools-reset'
                ? 'devtools reset'
                : cause.reason === 'adapter-reset'
                    ? 'adapter reset'
                    : cause.reason === 'manual'
                        ? 'manual shutdown'
                        : 'unknown reason';
    return IS_REACT_NATIVE ? _jsx(_Fragment, {}) : _jsxs(_Fragment, { children: ["LiveStore Shutdown due to ", reason] });
};
const defaultRenderLoading = (status) => IS_REACT_NATIVE ? _jsx(_Fragment, {}) : _jsxs(_Fragment, { children: ["LiveStore is loading (", status.stage, ")..."] });
export const LiveStoreProvider = ({ renderLoading = defaultRenderLoading, renderError = defaultRenderError, renderShutdown = defaultRenderShutdown, otelOptions, children, schema, storeId = 'default', boot, adapter, batchUpdates, disableDevtools, signal, confirmUnsavedChanges = true, syncPayload, debug, }) => {
    const storeCtx = useCreateStore({
        storeId,
        schema,
        otelOptions,
        boot,
        adapter,
        batchUpdates,
        disableDevtools,
        signal,
        confirmUnsavedChanges,
        syncPayload,
        debug,
    });
    if (storeCtx.stage === 'error') {
        return renderError(storeCtx.error);
    }
    if (storeCtx.stage === 'shutdown') {
        return renderShutdown(storeCtx.cause);
    }
    if (storeCtx.stage !== 'running') {
        return renderLoading(storeCtx);
    }
    globalThis.__debugLiveStore ??= {};
    if (Object.keys(globalThis.__debugLiveStore).length === 0) {
        globalThis.__debugLiveStore['_'] = storeCtx.store;
    }
    globalThis.__debugLiveStore[debug?.instanceId ?? storeId] = storeCtx.store;
    return _jsx(LiveStoreContext.Provider, { value: storeCtx, children: children });
};
const useCreateStore = ({ schema, storeId, otelOptions, boot, adapter, batchUpdates, disableDevtools, signal, context, params, confirmUnsavedChanges, syncPayload, debug, }) => {
    const [_, rerender] = React.useState(0);
    const ctxValueRef = React.useRef({
        value: { stage: 'loading' },
        componentScope: undefined,
        shutdownDeferred: undefined,
        previousShutdownDeferred: undefined,
        counter: 0,
    });
    const debugInstanceId = debug?.instanceId;
    // console.debug(`useCreateStore (${ctxValueRef.current.counter})`, ctxValueRef.current.value.stage)
    const inputPropsCacheRef = React.useRef({
        schema,
        otelOptions,
        boot,
        adapter,
        batchUpdates,
        disableDevtools,
        signal,
        context,
        params,
        confirmUnsavedChanges,
        syncPayload,
        debugInstanceId,
    });
    const interrupt = (componentScope, shutdownDeferred, error) => Effect.gen(function* () {
        // console.log('[@livestore/livestore/react] interupting', error)
        yield* Scope.close(componentScope, Exit.fail(error));
        yield* Deferred.fail(shutdownDeferred, error);
    }).pipe(Effect.tapErrorCause((cause) => Effect.logDebug('[@livestore/livestore/react] interupting', cause)), Effect.runFork);
    const inputPropChanges = {
        schema: inputPropsCacheRef.current.schema !== schema,
        otelOptions: inputPropsCacheRef.current.otelOptions !== otelOptions,
        boot: inputPropsCacheRef.current.boot !== boot,
        adapter: inputPropsCacheRef.current.adapter !== adapter,
        batchUpdates: inputPropsCacheRef.current.batchUpdates !== batchUpdates,
        disableDevtools: inputPropsCacheRef.current.disableDevtools !== disableDevtools,
        signal: inputPropsCacheRef.current.signal !== signal,
        context: inputPropsCacheRef.current.context !== context,
        params: inputPropsCacheRef.current.params !== params,
        confirmUnsavedChanges: inputPropsCacheRef.current.confirmUnsavedChanges !== confirmUnsavedChanges,
        syncPayload: inputPropsCacheRef.current.syncPayload !== syncPayload,
        debugInstanceId: inputPropsCacheRef.current.debugInstanceId !== debugInstanceId,
    };
    if (inputPropChanges.schema ||
        inputPropChanges.otelOptions ||
        inputPropChanges.boot ||
        inputPropChanges.adapter ||
        inputPropChanges.batchUpdates ||
        inputPropChanges.disableDevtools ||
        inputPropChanges.signal ||
        inputPropChanges.context ||
        inputPropChanges.params ||
        inputPropChanges.confirmUnsavedChanges ||
        inputPropChanges.syncPayload) {
        inputPropsCacheRef.current = {
            schema,
            otelOptions,
            boot,
            adapter,
            batchUpdates,
            disableDevtools,
            signal,
            context,
            params,
            confirmUnsavedChanges,
            syncPayload,
            debugInstanceId,
        };
        if (ctxValueRef.current.componentScope !== undefined && ctxValueRef.current.shutdownDeferred !== undefined) {
            const changedInputProps = Object.keys(inputPropChanges).filter((key) => inputPropChanges[key]);
            interrupt(ctxValueRef.current.componentScope, ctxValueRef.current.shutdownDeferred, new StoreInterrupted({ reason: `re-rendering due to changed input props: ${changedInputProps.join(', ')}` }));
            ctxValueRef.current.componentScope = undefined;
            ctxValueRef.current.shutdownDeferred = undefined;
        }
        ctxValueRef.current = {
            value: { stage: 'loading' },
            componentScope: undefined,
            shutdownDeferred: undefined,
            previousShutdownDeferred: ctxValueRef.current.shutdownDeferred,
            counter: ctxValueRef.current.counter + 1,
        };
    }
    React.useEffect(() => {
        const counter = ctxValueRef.current.counter;
        const setContextValue = (value) => {
            if (ctxValueRef.current.counter !== counter)
                return;
            ctxValueRef.current.value = value;
            rerender((c) => c + 1);
        };
        signal?.addEventListener('abort', () => {
            if (ctxValueRef.current.componentScope !== undefined &&
                ctxValueRef.current.shutdownDeferred !== undefined &&
                ctxValueRef.current.counter === counter) {
                interrupt(ctxValueRef.current.componentScope, ctxValueRef.current.shutdownDeferred, new StoreInterrupted({ reason: 'Aborted via provided AbortController' }));
                ctxValueRef.current.componentScope = undefined;
                ctxValueRef.current.shutdownDeferred = undefined;
            }
        });
        const cancel = Effect.gen(function* () {
            // Wait for the previous store to fully shutdown before creating a new one
            if (ctxValueRef.current.previousShutdownDeferred) {
                yield* Deferred.await(ctxValueRef.current.previousShutdownDeferred);
            }
            const componentScope = yield* Scope.make().pipe(Effect.acquireRelease(Scope.close));
            const shutdownDeferred = yield* makeShutdownDeferred;
            ctxValueRef.current.componentScope = componentScope;
            ctxValueRef.current.shutdownDeferred = shutdownDeferred;
            yield* Effect.gen(function* () {
                const store = yield* createStore({
                    schema,
                    storeId,
                    boot,
                    adapter,
                    batchUpdates,
                    disableDevtools,
                    shutdownDeferred,
                    context,
                    params,
                    confirmUnsavedChanges,
                    syncPayload,
                    onBootStatus: (status) => {
                        if (ctxValueRef.current.value.stage === 'running' || ctxValueRef.current.value.stage === 'error')
                            return;
                        // NOTE sometimes when status come in in rapid succession, only the last value will be rendered by React
                        setContextValue(status);
                    },
                    debug: { instanceId: debugInstanceId },
                }).pipe(Effect.tapErrorCause((cause) => Deferred.failCause(shutdownDeferred, cause)));
                setContextValue({ stage: 'running', store });
            }).pipe(Scope.extend(componentScope), Effect.forkIn(componentScope));
            const shutdownContext = (cause) => Effect.sync(() => setContextValue({ stage: 'shutdown', cause }));
            yield* Deferred.await(shutdownDeferred).pipe(Effect.tapErrorCause((cause) => Effect.logDebug('[@livestore/livestore/react] shutdown', Cause.pretty(cause))), Effect.catchTag('LiveStore.IntentionalShutdownCause', (cause) => shutdownContext(cause)), Effect.catchTag('LiveStore.StoreInterrupted', (cause) => shutdownContext(cause)), Effect.tapError((error) => Effect.sync(() => setContextValue({ stage: 'error', error }))), Effect.tapDefect((defect) => Effect.sync(() => setContextValue({ stage: 'error', error: defect }))), Effect.exit);
        }).pipe(Effect.scoped, Effect.withSpan('@livestore/react:useCreateStore'), LS_DEV ? TaskTracing.withAsyncTaggingTracing((name) => console.createTask(name)) : identity, provideOtel({ parentSpanContext: otelOptions?.rootSpanContext, otelTracer: otelOptions?.tracer }), Effect.tapCauseLogPretty, Effect.annotateLogs({ thread: 'window' }), Effect.provide(Logger.prettyWithThread('window')), Logger.withMinimumLogLevel(LogLevel.Debug), Effect.runCallback);
        return () => {
            cancel();
            if (ctxValueRef.current.componentScope !== undefined && ctxValueRef.current.shutdownDeferred !== undefined) {
                interrupt(ctxValueRef.current.componentScope, ctxValueRef.current.shutdownDeferred, new StoreInterrupted({ reason: 'unmounting component' }));
                ctxValueRef.current.componentScope = undefined;
                ctxValueRef.current.shutdownDeferred = undefined;
            }
        };
    }, [
        schema,
        otelOptions,
        boot,
        adapter,
        batchUpdates,
        disableDevtools,
        signal,
        storeId,
        context,
        params,
        confirmUnsavedChanges,
        syncPayload,
        debugInstanceId,
    ]);
    return ctxValueRef.current.value;
};
//# sourceMappingURL=LiveStoreProvider.js.map
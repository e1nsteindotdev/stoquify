import { State } from '@livestore/common/schema';
import type { Store } from '@livestore/livestore';
import { Effect, Schema } from '@livestore/utils/effect';
import type * as otel from '@opentelemetry/api';
import * as LiveStoreReact from '../mod.js';
export type Todo = {
    id: string;
    text: string;
    completed: boolean;
};
export type Filter = 'all' | 'active' | 'completed';
export type AppState = {
    newTodoText: string;
    filter: Filter;
};
export declare const events: {
    todoCreated: State.SQLite.EventDef<"todoCreated", {
        readonly id: string;
        readonly text: string;
        readonly completed: boolean;
    }, {
        readonly id: string;
        readonly text: string;
        readonly completed: boolean;
    }, false>;
    todoUpdated: State.SQLite.EventDef<"todoUpdated", {
        readonly id: string;
        readonly text?: string | undefined;
        readonly completed?: boolean | undefined;
    }, {
        readonly id: string;
        readonly text?: string | undefined;
        readonly completed?: boolean | undefined;
    }, false>;
    AppRouterSet: State.SQLite.ClientDocumentTableDef.SetEventDefLike<"AppRouter", {
        readonly currentTaskId: string | null;
    }, {
        partialSet: true;
        default: {
            id: "singleton";
            value: {
                readonly currentTaskId: null;
            };
        };
    }>;
    UserInfoSet: State.SQLite.ClientDocumentTableDef.SetEventDefLike<"UserInfo", {
        readonly text: string;
        readonly username: string;
    }, {
        partialSet: true;
        default: {
            id: undefined;
            value: {
                readonly username: "";
                readonly text: "";
            };
        };
    }>;
};
export declare const tables: {
    todos: State.SQLite.TableDef<State.SQLite.SqliteTableDefForInput<"todos", {
        readonly id: {
            columnType: "text";
            schema: Schema.Schema<string, string, never>;
            default: import("effect/Option").None<never>;
            nullable: false;
            primaryKey: true;
        };
        readonly text: {
            columnType: "text";
            schema: Schema.Schema<string, string, never>;
            default: import("effect/Option").Some<"">;
            nullable: false;
            primaryKey: false;
        };
        readonly completed: {
            columnType: "integer";
            schema: Schema.Schema<boolean, number, never>;
            default: import("effect/Option").Some<false>;
            nullable: false;
            primaryKey: false;
        };
    }>, {
        isClientDocumentTable: false;
        requiredInsertColumnNames: "id";
    }, Schema.Schema<{
        readonly id: string;
        readonly text: string;
        readonly completed: boolean;
    }, {
        readonly id: string;
        readonly text: string;
        readonly completed: number;
    }, never>>;
    app: State.SQLite.TableDef<State.SQLite.SqliteTableDefForInput<"app", {
        readonly id: {
            columnType: "text";
            schema: Schema.Schema<string, string, never>;
            default: import("effect/Option").Some<"static">;
            nullable: false;
            primaryKey: true;
        };
        readonly newTodoText: {
            columnType: "text";
            schema: Schema.Schema<string | null, string | null, never>;
            default: import("effect/Option").Some<"">;
            nullable: true;
            primaryKey: false;
        };
        readonly filter: {
            columnType: "text";
            schema: Schema.Schema<string, string, never>;
            default: import("effect/Option").Some<"all">;
            nullable: false;
            primaryKey: false;
        };
    }>, {
        isClientDocumentTable: false;
        requiredInsertColumnNames: never;
    }, Schema.Schema<{
        readonly id: string;
        readonly newTodoText: string | null;
        readonly filter: string;
    }, {
        readonly id: string;
        readonly newTodoText: string | null;
        readonly filter: string;
    }, never>>;
    userInfo: State.SQLite.ClientDocumentTableDef<"UserInfo", {
        readonly text: string;
        readonly username: string;
    }, {
        readonly text: string;
        readonly username: string;
    }, {
        partialSet: true;
        default: {
            id: undefined;
            value: {
                readonly username: "";
                readonly text: "";
            };
        };
    }>;
    AppRouterSchema: State.SQLite.ClientDocumentTableDef<"AppRouter", {
        readonly currentTaskId: string | null;
    }, {
        readonly currentTaskId: string | null;
    }, {
        partialSet: true;
        default: {
            id: "singleton";
            value: {
                readonly currentTaskId: null;
            };
        };
    }>;
};
export declare const schema: import("@livestore/common/schema").FromInputSchema.DeriveSchema<{
    state: import("@livestore/common/schema").InternalState;
    events: {
        todoCreated: State.SQLite.EventDef<"todoCreated", {
            readonly id: string;
            readonly text: string;
            readonly completed: boolean;
        }, {
            readonly id: string;
            readonly text: string;
            readonly completed: boolean;
        }, false>;
        todoUpdated: State.SQLite.EventDef<"todoUpdated", {
            readonly id: string;
            readonly text?: string | undefined;
            readonly completed?: boolean | undefined;
        }, {
            readonly id: string;
            readonly text?: string | undefined;
            readonly completed?: boolean | undefined;
        }, false>;
        AppRouterSet: State.SQLite.ClientDocumentTableDef.SetEventDefLike<"AppRouter", {
            readonly currentTaskId: string | null;
        }, {
            partialSet: true;
            default: {
                id: "singleton";
                value: {
                    readonly currentTaskId: null;
                };
            };
        }>;
        UserInfoSet: State.SQLite.ClientDocumentTableDef.SetEventDefLike<"UserInfo", {
            readonly text: string;
            readonly username: string;
        }, {
            partialSet: true;
            default: {
                id: undefined;
                value: {
                    readonly username: "";
                    readonly text: "";
                };
            };
        }>;
    };
}>;
export declare const makeTodoMvcReact: ({ otelTracer, otelContext, strictMode, }?: {
    otelTracer?: otel.Tracer;
    otelContext?: otel.Context;
    strictMode?: boolean;
}) => Effect.Effect<{
    wrapper: ({ children }: any) => import("react/jsx-runtime").JSX.Element;
    store: Store<import("@livestore/common/schema").LiveStoreSchema<import("@livestore/common/dist/schema/state/sqlite/db-schema/dsl/mod.js").DbSchema, State.SQLite.EventDefRecord>, {}> & LiveStoreReact.ReactApi;
    renderCount: {
        readonly val: number;
        inc: () => void;
    };
}, import("@livestore/common").UnexpectedError, import("effect/Scope").Scope>;
//# sourceMappingURL=fixture.d.ts.map
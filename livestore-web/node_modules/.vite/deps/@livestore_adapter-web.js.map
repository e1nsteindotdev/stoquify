{
  "version": 3,
  "sources": ["../../.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/src/web-worker/common/worker-disconnect-channel.ts", "../../.pnpm/@livestore+devtools-web-common@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/devtools-web-common/src/web-channel/index.ts", "../../.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/src/web-worker/client-session/client-session-devtools.ts", "../../.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/src/web-worker/client-session/persisted-adapter.ts", "../../.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/src/in-memory/in-memory-adapter.ts"],
  "sourcesContent": ["import { Schema, WebChannel } from '@livestore/utils/effect'\n\nexport class DedicatedWorkerDisconnectBroadcast extends Schema.TaggedStruct('DedicatedWorkerDisconnectBroadcast', {}) {}\n\n/** Used across workers for leader election purposes */\nexport const makeWorkerDisconnectChannel = (storeId: string) =>\n  WebChannel.broadcastChannel({\n    channelName: `livestore.worker-disconnect.${storeId}`,\n    schema: DedicatedWorkerDisconnectBroadcast,\n  })\n", "import { Devtools, UnexpectedError } from '@livestore/common'\nimport { LS_DEV } from '@livestore/utils'\nimport type { Scope, Worker } from '@livestore/utils/effect'\nimport { Deferred, Effect, Schema, Stream, WebChannel } from '@livestore/utils/effect'\nimport type { MeshNode } from '@livestore/webmesh'\nimport { WebmeshSchema } from '@livestore/webmesh'\n\nimport * as WorkerSchema from '../worker/schema.js'\n\nexport * as WorkerSchema from '../worker/schema.js'\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __debugWebmeshNode: any\n}\n\nexport const makeSessionInfoBroadcastChannel: Effect.Effect<\n  WebChannel.WebChannel<Devtools.SessionInfo.Message, Devtools.SessionInfo.Message>,\n  UnexpectedError,\n  Scope.Scope\n> = WebChannel.broadcastChannel({\n  channelName: 'session-info',\n  schema: Devtools.SessionInfo.Message,\n})\n\nexport const makeNodeName = {\n  sharedWorker: ({ storeId }: { storeId: string }) => `shared-worker-${storeId}`,\n  // TODO refactor shared-worker setup so there's only a single shared-worker per origin\n  // sharedWorker: () => `shared-worker`,\n  browserExtension: {\n    contentscriptMain: (tabId: number) => `contentscript-main-${tabId}`,\n    contentscriptIframe: (tabId: number) => `contentscript-iframe-${tabId}`,\n  },\n}\n\nexport const ClientSessionContentscriptMainReq = Schema.TaggedStruct('ClientSessionContentscriptMainReq', {\n  storeId: Schema.String,\n  clientId: Schema.String,\n  sessionId: Schema.String,\n})\n\nexport const ClientSessionContentscriptMainRes = Schema.TaggedStruct('ClientSessionContentscriptMainRes', {\n  tabId: Schema.Number,\n})\n\n// Effect.suspend is needed since `window` is not available in the shared worker\nexport const makeStaticClientSessionChannel = {\n  contentscriptMain: Effect.suspend(() =>\n    WebChannel.windowChannel({\n      // eslint-disable-next-line unicorn/prefer-global-this\n      listenWindow: window,\n      // eslint-disable-next-line unicorn/prefer-global-this\n      sendWindow: window,\n      schema: { listen: ClientSessionContentscriptMainReq, send: ClientSessionContentscriptMainRes },\n      ids: { own: 'contentscript-main-static', other: 'client-session-static' },\n    }),\n  ),\n  clientSession: Effect.suspend(() =>\n    WebChannel.windowChannel({\n      // eslint-disable-next-line unicorn/prefer-global-this\n      listenWindow: window,\n      // eslint-disable-next-line unicorn/prefer-global-this\n      sendWindow: window,\n      schema: { listen: ClientSessionContentscriptMainRes, send: ClientSessionContentscriptMainReq },\n      ids: { own: 'client-session-static', other: 'contentscript-main-static' },\n    }),\n  ),\n}\n\nexport const connectViaWorker = ({\n  node,\n  target,\n  worker,\n}: {\n  node: MeshNode\n  target: string\n  worker: Worker.SerializedWorkerPool<typeof WorkerSchema.Request.Type>\n}) =>\n  Effect.gen(function* () {\n    const mc = new MessageChannel()\n\n    const isConnected = yield* Deferred.make<boolean, never>()\n\n    if (LS_DEV) {\n      yield* Effect.addFinalizerLog(\n        `@livestore/devtools-web-common: closing message channel ${node.nodeName} → ${target}`,\n      )\n    }\n\n    yield* worker.execute(WorkerSchema.CreateConnection.make({ from: node.nodeName, port: mc.port1 })).pipe(\n      Stream.tap(() => Deferred.succeed(isConnected, true)),\n      Stream.runDrain,\n      Effect.tapCauseLogPretty,\n      Effect.forkScoped,\n    )\n\n    yield* isConnected\n\n    const sharedWorkerConnection = yield* WebChannel.messagePortChannel({\n      port: mc.port2,\n      schema: WebmeshSchema.Packet,\n    })\n\n    yield* node.addEdge({ target, edgeChannel: sharedWorkerConnection, replaceIfExists: true })\n\n    if (LS_DEV) {\n      yield* Effect.logDebug(`@livestore/devtools-web-common: initiated connection: ${node.nodeName} → ${target}`)\n    }\n  }).pipe(UnexpectedError.mapToUnexpectedError)\n", "import { Devtools } from '@livestore/common'\nimport type { LiveStoreSchema } from '@livestore/common/schema'\nimport * as DevtoolsWeb from '@livestore/devtools-web-common/web-channel'\nimport { isDevEnv } from '@livestore/utils'\nimport type { Worker } from '@livestore/utils/effect'\nimport { Effect, Stream, WebChannel } from '@livestore/utils/effect'\nimport * as Webmesh from '@livestore/webmesh'\n\nexport const logDevtoolsUrl = ({\n  schema,\n  storeId,\n  clientId,\n  sessionId,\n}: {\n  schema: LiveStoreSchema\n  storeId: string\n  clientId: string\n  sessionId: string\n}) =>\n  Effect.gen(function* () {\n    if (isDevEnv()) {\n      const devtoolsPath = globalThis.LIVESTORE_DEVTOOLS_PATH ?? `/_livestore`\n      const devtoolsBaseUrl = `${location.origin}${devtoolsPath}`\n\n      // Check whether devtools are available and then log the URL\n      const response = yield* Effect.promise(() => fetch(devtoolsBaseUrl))\n      if (response.ok) {\n        const text = yield* Effect.promise(() => response.text())\n        if (text.includes('<meta name=\"livestore-devtools\" content=\"true\" />')) {\n          const url = `${devtoolsBaseUrl}/web/${storeId}/${clientId}/${sessionId}/${schema.devtools.alias}`\n          yield* Effect.log(`[@livestore/adapter-web] Devtools ready on ${url}`)\n        }\n      }\n    }\n  }).pipe(Effect.withSpan('@livestore/adapter-web:client-session:devtools:logDevtoolsUrl'))\n\nexport const connectWebmeshNodeClientSession = Effect.fn(function* ({\n  webmeshNode,\n  sessionInfo,\n  sharedWorker,\n  devtoolsEnabled,\n  schema,\n}: {\n  webmeshNode: Webmesh.MeshNode\n  sessionInfo: Devtools.SessionInfo.SessionInfo\n  sharedWorker: Worker.SerializedWorkerPool<typeof DevtoolsWeb.WorkerSchema.Request.Type>\n  devtoolsEnabled: boolean\n  schema: LiveStoreSchema\n}) {\n  if (devtoolsEnabled) {\n    const { clientId, sessionId, storeId } = sessionInfo\n    yield* logDevtoolsUrl({ clientId, sessionId, schema, storeId })\n\n    // This additional sessioninfo broadcast channel is needed since we can't use the shared worker\n    // as it's currently storeId-specific\n    yield* Devtools.SessionInfo.provideSessionInfo({\n      webChannel: yield* DevtoolsWeb.makeSessionInfoBroadcastChannel,\n      sessionInfo,\n    }).pipe(Effect.tapCauseLogPretty, Effect.forkScoped)\n\n    yield* Effect.gen(function* () {\n      const clientSessionStaticChannel = yield* DevtoolsWeb.makeStaticClientSessionChannel.clientSession\n\n      yield* clientSessionStaticChannel.send(\n        DevtoolsWeb.ClientSessionContentscriptMainReq.make({ clientId, sessionId, storeId }),\n      )\n\n      const { tabId } = yield* clientSessionStaticChannel.listen.pipe(Stream.flatten(), Stream.runHead, Effect.flatten)\n\n      const contentscriptMainNodeName = DevtoolsWeb.makeNodeName.browserExtension.contentscriptMain(tabId)\n\n      const contentscriptMainChannel = yield* WebChannel.windowChannel({\n        listenWindow: window,\n        sendWindow: window,\n        schema: Webmesh.WebmeshSchema.Packet,\n        ids: { own: webmeshNode.nodeName, other: contentscriptMainNodeName },\n      })\n\n      yield* webmeshNode.addEdge({ target: contentscriptMainNodeName, edgeChannel: contentscriptMainChannel })\n    }).pipe(\n      Effect.withSpan('@livestore/adapter-web:client-session:devtools:browser-extension'),\n      Effect.tapCauseLogPretty,\n      Effect.forkScoped,\n    )\n\n    yield* DevtoolsWeb.connectViaWorker({\n      node: webmeshNode,\n      target: DevtoolsWeb.makeNodeName.sharedWorker({ storeId }),\n      worker: sharedWorker,\n    })\n  }\n})\n", "import type { Adapter, ClientSession, LockStatus } from '@livestore/common'\nimport {\n  IntentionalShutdownCause,\n  liveStoreVersion,\n  makeClientSession,\n  StoreInterrupted,\n  UnexpectedError,\n} from '@livestore/common'\n// TODO bring back - this currently doesn't work due to https://github.com/vitejs/vite/issues/8427\n// NOTE We're using a non-relative import here for Vite to properly resolve the import during app builds\n// import LiveStoreSharedWorker from '@livestore/adapter-web/internal-shared-worker?sharedworker'\nimport { EventSequenceNumber, SystemTables } from '@livestore/common/schema'\nimport { sqliteDbFactory } from '@livestore/sqlite-wasm/browser'\nimport { loadSqlite3Wasm } from '@livestore/sqlite-wasm/load-wasm'\nimport { isDevEnv, shouldNeverHappen, tryAsFunctionAndNew } from '@livestore/utils'\nimport {\n  BrowserWorker,\n  Cause,\n  Deferred,\n  Effect,\n  Exit,\n  Fiber,\n  ParseResult,\n  Queue,\n  Schema,\n  Stream,\n  SubscriptionRef,\n  WebLock,\n  Worker,\n  WorkerError,\n} from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\n\nimport * as OpfsUtils from '../../opfs-utils.js'\nimport { readPersistedAppDbFromClientSession, resetPersistedDataFromClientSession } from '../common/persisted-sqlite.js'\nimport { makeShutdownChannel } from '../common/shutdown-channel.js'\nimport { DedicatedWorkerDisconnectBroadcast, makeWorkerDisconnectChannel } from '../common/worker-disconnect-channel.js'\nimport * as WorkerSchema from '../common/worker-schema.js'\nimport { connectWebmeshNodeClientSession } from './client-session-devtools.js'\n\n// NOTE we're starting to initialize the sqlite wasm binary here to speed things up\nconst sqlite3Promise = loadSqlite3Wasm()\n\nif (isDevEnv()) {\n  globalThis.__debugLiveStoreUtils = {\n    opfs: OpfsUtils,\n    runSync: (effect: Effect.Effect<any, any, never>) => Effect.runSync(effect),\n    runFork: (effect: Effect.Effect<any, any, never>) => Effect.runFork(effect),\n  }\n}\n\nexport type WebAdapterOptions = {\n  worker: ((options: { name: string }) => globalThis.Worker) | (new (options: { name: string }) => globalThis.Worker)\n  /**\n   * This is mostly an implementation detail and needed to be exposed into app code\n   * due to a current Vite limitation (https://github.com/vitejs/vite/issues/8427).\n   *\n   * In most cases this should look like:\n   * ```ts\n   * import LiveStoreSharedWorker from '@livestore/adapter-web/shared-worker?sharedworker'\n   *\n   * const adapter = makePersistedAdapter({\n   *   sharedWorker: LiveStoreSharedWorker,\n   *   // ...\n   * })\n   * ```\n   */\n  sharedWorker:\n    | ((options: { name: string }) => globalThis.SharedWorker)\n    | (new (options: { name: string }) => globalThis.SharedWorker)\n  /**\n   * Specifies where to persist data for this adapter\n   */\n  storage: WorkerSchema.StorageTypeEncoded\n  /**\n   * Warning: This will reset both the app and eventlog database.\n   * This should only be used during development.\n   *\n   * @default false\n   */\n  resetPersistence?: boolean\n  /**\n   * By default the adapter will initially generate a random clientId (via `nanoid(5)`),\n   * store it in `localStorage` and restore it for subsequent client sessions. It's the same across all tabs/windows.\n   */\n  clientId?: string\n  /**\n   * By default the adapter will initially generate a random sessionId (via `nanoid(5)`),\n   * store it in `sessionStorage` and restore it for subsequent client sessions in the same tab/window.\n   */\n  sessionId?: string\n  experimental?: {\n    /**\n     * When set to `true`, the adapter will always start with a snapshot from the leader\n     * instead of trying to load a snapshot from storage.\n     *\n     * @default false\n     */\n    disableFastPath?: boolean\n  }\n}\n\n/**\n * Creates a web adapter with persistent storage (currently only supports OPFS).\n * Requires both a web worker and a shared worker.\n *\n * @example\n * ```ts\n * import { makePersistedAdapter } from '@livestore/adapter-web'\n * import LiveStoreWorker from './livestore.worker?worker'\n * import LiveStoreSharedWorker from '@livestore/adapter-web/shared-worker?sharedworker'\n *\n * const adapter = makePersistedAdapter({\n *   worker: LiveStoreWorker,\n *   sharedWorker: LiveStoreSharedWorker,\n *   storage: { type: 'opfs' },\n * })\n * ```\n */\nexport const makePersistedAdapter =\n  (options: WebAdapterOptions): Adapter =>\n  (adapterArgs) =>\n    Effect.gen(function* () {\n      const { schema, storeId, devtoolsEnabled, debugInstanceId, bootStatusQueue, shutdown, syncPayload } = adapterArgs\n\n      yield* ensureBrowserRequirements\n\n      yield* Queue.offer(bootStatusQueue, { stage: 'loading' })\n\n      const sqlite3 = yield* Effect.promise(() => sqlite3Promise)\n\n      const LIVESTORE_TAB_LOCK = `livestore-tab-lock-${storeId}`\n\n      const storageOptions = yield* Schema.decode(WorkerSchema.StorageType)(options.storage)\n\n      const shutdownChannel = yield* makeShutdownChannel(storeId)\n\n      if (options.resetPersistence === true) {\n        yield* shutdownChannel.send(IntentionalShutdownCause.make({ reason: 'adapter-reset' }))\n\n        yield* resetPersistedDataFromClientSession({ storageOptions, storeId })\n      }\n\n      // Note on fast-path booting:\n      // Instead of waiting for the leader worker to boot and then get a database snapshot from it,\n      // we're here trying to get the snapshot directly from storage\n      // we usually speeds up the boot process by a lot.\n      // We need to be extra careful though to not run into any race conditions or inconsistencies.\n      // TODO also verify persisted data\n      const dataFromFile =\n        options.experimental?.disableFastPath === true\n          ? undefined\n          : yield* readPersistedAppDbFromClientSession({ storageOptions, storeId, schema })\n\n      // The same across all client sessions (i.e. tabs, windows)\n      const clientId = options.clientId ?? getPersistedId(`clientId:${storeId}`, 'local')\n      // Unique per client session (i.e. tab, window)\n      const sessionId = options.sessionId ?? getPersistedId(`sessionId:${storeId}`, 'session')\n\n      const workerDisconnectChannel = yield* makeWorkerDisconnectChannel(storeId)\n\n      yield* shutdownChannel.listen.pipe(\n        Stream.flatten(),\n        Stream.tap((error) => shutdown(Cause.fail(error))),\n        Stream.runDrain,\n        Effect.interruptible,\n        Effect.tapCauseLogPretty,\n        Effect.forkScoped,\n      )\n\n      const sharedWebWorker = tryAsFunctionAndNew(options.sharedWorker, { name: `livestore-shared-worker-${storeId}` })\n\n      const sharedWorkerFiber = yield* Worker.makePoolSerialized<typeof WorkerSchema.SharedWorker.Request.Type>({\n        size: 1,\n        concurrency: 100,\n        initialMessage: () =>\n          new WorkerSchema.SharedWorker.InitialMessage({\n            liveStoreVersion,\n            payload: {\n              _tag: 'FromClientSession',\n              initialMessage: new WorkerSchema.LeaderWorkerInner.InitialMessage({\n                storageOptions,\n                storeId,\n                clientId,\n                devtoolsEnabled,\n                debugInstanceId,\n                syncPayload,\n              }),\n            },\n          }),\n      }).pipe(\n        Effect.provide(BrowserWorker.layer(() => sharedWebWorker)),\n        Effect.tapCauseLogPretty,\n        UnexpectedError.mapToUnexpectedError,\n        Effect.tapErrorCause(shutdown),\n        Effect.withSpan('@livestore/adapter-web:client-session:setupSharedWorker'),\n        Effect.forkScoped,\n      )\n\n      const lockDeferred = yield* Deferred.make<void>()\n      // It's important that we resolve the leader election in a blocking way, so there's always a leader.\n      // Otherwise events could end up being dropped.\n      //\n      // Sorry for this pun ...\n      let gotLocky = yield* WebLock.tryGetDeferredLock(lockDeferred, LIVESTORE_TAB_LOCK)\n      const lockStatus = yield* SubscriptionRef.make<LockStatus>(gotLocky ? 'has-lock' : 'no-lock')\n\n      // Ideally we can come up with a simpler implementation that doesn't require this\n      const waitForSharedWorkerInitialized = yield* Deferred.make<void>()\n      if (gotLocky === false) {\n        // Don't need to wait if we're not the leader\n        yield* Deferred.succeed(waitForSharedWorkerInitialized, undefined)\n      }\n\n      const runLocked = Effect.gen(function* () {\n        yield* Effect.logDebug(\n          `[@livestore/adapter-web:client-session] ✅ Got lock '${LIVESTORE_TAB_LOCK}' (clientId: ${clientId}, sessionId: ${sessionId}).`,\n        )\n\n        yield* Effect.addFinalizer(() =>\n          Effect.logDebug(`[@livestore/adapter-web:client-session] Releasing lock for '${LIVESTORE_TAB_LOCK}'`),\n        )\n\n        yield* SubscriptionRef.set(lockStatus, 'has-lock')\n\n        const mc = new MessageChannel()\n\n        // NOTE we're adding the `storeId` to the worker name to make it unique\n        // and adding the `sessionId` to make it easier to debug which session a worker belongs to in logs\n        const worker = tryAsFunctionAndNew(options.worker, { name: `livestore-worker-${storeId}-${sessionId}` })\n\n        yield* Worker.makeSerialized<WorkerSchema.LeaderWorkerOuter.Request>({\n          initialMessage: () =>\n            new WorkerSchema.LeaderWorkerOuter.InitialMessage({ port: mc.port1, storeId, clientId }),\n        }).pipe(\n          Effect.provide(BrowserWorker.layer(() => worker)),\n          UnexpectedError.mapToUnexpectedError,\n          Effect.tapErrorCause(shutdown),\n          Effect.withSpan('@livestore/adapter-web:client-session:setupDedicatedWorker'),\n          Effect.tapCauseLogPretty,\n          Effect.forkScoped,\n        )\n\n        yield* workerDisconnectChannel.send(DedicatedWorkerDisconnectBroadcast.make({}))\n\n        const sharedWorker = yield* Fiber.join(sharedWorkerFiber)\n        yield* sharedWorker\n          .executeEffect(new WorkerSchema.SharedWorker.UpdateMessagePort({ port: mc.port2 }))\n          .pipe(UnexpectedError.mapToUnexpectedError, Effect.tapErrorCause(shutdown))\n\n        yield* Deferred.succeed(waitForSharedWorkerInitialized, undefined)\n\n        yield* Effect.never\n      }).pipe(Effect.withSpan('@livestore/adapter-web:client-session:lock'))\n\n      // TODO take/give up lock when tab becomes active/passive\n      if (gotLocky === false) {\n        yield* Effect.logDebug(\n          `[@livestore/adapter-web:client-session] ⏳ Waiting for lock '${LIVESTORE_TAB_LOCK}' (sessionId: ${sessionId})`,\n        )\n\n        // TODO find a cleaner implementation for the lock handling as we don't make use of the deferred properly right now\n        yield* WebLock.waitForDeferredLock(lockDeferred, LIVESTORE_TAB_LOCK).pipe(\n          Effect.andThen(() => {\n            gotLocky = true\n            return runLocked\n          }),\n          Effect.interruptible,\n          Effect.tapCauseLogPretty,\n          Effect.forkScoped,\n        )\n      } else {\n        yield* runLocked.pipe(Effect.interruptible, Effect.tapCauseLogPretty, Effect.forkScoped)\n      }\n\n      const runInWorker = <TReq extends typeof WorkerSchema.SharedWorker.Request.Type>(\n        req: TReq,\n      ): TReq extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n        ? Effect.Effect<A, UnexpectedError | E, R>\n        : never =>\n        Fiber.join(sharedWorkerFiber).pipe(\n          // NOTE we need to wait for the shared worker to be initialized before we can send requests to it\n          Effect.tap(() => waitForSharedWorkerInitialized),\n          Effect.flatMap((worker) => worker.executeEffect(req) as any),\n          // NOTE we want to treat worker requests as atomic and therefore not allow them to be interrupted\n          // Interruption usually only happens during leader re-election or store shutdown\n          // Effect.uninterruptible,\n          Effect.logWarnIfTakesLongerThan({\n            label: `@livestore/adapter-web:client-session:runInWorker:${req._tag}`,\n            duration: 2000,\n          }),\n          Effect.withSpan(`@livestore/adapter-web:client-session:runInWorker:${req._tag}`),\n          Effect.mapError((cause) =>\n            Schema.is(UnexpectedError)(cause)\n              ? cause\n              : ParseResult.isParseError(cause) || Schema.is(WorkerError.WorkerError)(cause)\n                ? new UnexpectedError({ cause })\n                : cause,\n          ),\n          Effect.catchAllDefect((cause) => new UnexpectedError({ cause })),\n        ) as any\n\n      const runInWorkerStream = <TReq extends typeof WorkerSchema.SharedWorker.Request.Type>(\n        req: TReq,\n      ): TReq extends Schema.WithResult<infer A, infer _I, infer _E, infer _EI, infer R>\n        ? Stream.Stream<A, UnexpectedError, R>\n        : never =>\n        Effect.gen(function* () {\n          const sharedWorker = yield* Fiber.join(sharedWorkerFiber)\n          return sharedWorker.execute(req as any).pipe(\n            Stream.mapError((cause) =>\n              Schema.is(UnexpectedError)(cause)\n                ? cause\n                : ParseResult.isParseError(cause) || Schema.is(WorkerError.WorkerError)(cause)\n                  ? new UnexpectedError({ cause })\n                  : cause,\n            ),\n            Stream.withSpan(`@livestore/adapter-web:client-session:runInWorkerStream:${req._tag}`),\n          )\n        }).pipe(Stream.unwrap) as any\n\n      const bootStatusFiber = yield* runInWorkerStream(new WorkerSchema.LeaderWorkerInner.BootStatusStream()).pipe(\n        Stream.tap((_) => Queue.offer(bootStatusQueue, _)),\n        Stream.runDrain,\n        Effect.tapErrorCause((cause) => (Cause.isInterruptedOnly(cause) ? Effect.void : shutdown(cause))),\n        Effect.interruptible,\n        Effect.tapCauseLogPretty,\n        Effect.forkScoped,\n      )\n\n      yield* Queue.awaitShutdown(bootStatusQueue).pipe(\n        Effect.andThen(Fiber.interrupt(bootStatusFiber)),\n        Effect.tapCauseLogPretty,\n        Effect.forkScoped,\n      )\n\n      // TODO maybe bring back transfering the initially created in-memory db snapshot instead of\n      // re-exporting the db\n      const initialResult =\n        dataFromFile === undefined\n          ? yield* runInWorker(new WorkerSchema.LeaderWorkerInner.GetRecreateSnapshot()).pipe(\n              Effect.map(({ snapshot, migrationsReport }) => ({\n                _tag: 'from-leader-worker' as const,\n                snapshot,\n                migrationsReport,\n              })),\n            )\n          : { _tag: 'fast-path' as const, snapshot: dataFromFile }\n\n      const migrationsReport =\n        initialResult._tag === 'from-leader-worker' ? initialResult.migrationsReport : { migrations: [] }\n\n      const makeSqliteDb = sqliteDbFactory({ sqlite3 })\n      const sqliteDb = yield* makeSqliteDb({ _tag: 'in-memory' })\n\n      sqliteDb.import(initialResult.snapshot)\n\n      const numberOfTables =\n        sqliteDb.select<{ count: number }>(`select count(*) as count from sqlite_master`)[0]?.count ?? 0\n      if (numberOfTables === 0) {\n        yield* UnexpectedError.make({\n          cause: `Encountered empty or corrupted database`,\n          payload: { snapshotByteLength: initialResult.snapshot.byteLength, storageOptions: options.storage },\n        })\n      }\n\n      // We're restoring the leader head from the SESSION_CHANGESET_META_TABLE, not from the eventlog db/table\n      // in order to avoid exporting/transferring the eventlog db/table, which is important to speed up the fast path.\n      const initialLeaderHeadRes = sqliteDb.select<{\n        seqNumGlobal: EventSequenceNumber.GlobalEventSequenceNumber\n        seqNumClient: EventSequenceNumber.ClientEventSequenceNumber\n      }>(\n        `select seqNumGlobal, seqNumClient from ${SystemTables.SESSION_CHANGESET_META_TABLE} order by seqNumGlobal desc, seqNumClient desc limit 1`,\n      )[0]\n\n      const initialLeaderHead = initialLeaderHeadRes\n        ? EventSequenceNumber.make({\n            global: initialLeaderHeadRes.seqNumGlobal,\n            client: initialLeaderHeadRes.seqNumClient,\n          })\n        : EventSequenceNumber.ROOT\n\n      // console.debug('[@livestore/adapter-web:client-session] initialLeaderHead', initialLeaderHead)\n\n      yield* Effect.addFinalizer((ex) =>\n        Effect.gen(function* () {\n          if (\n            Exit.isFailure(ex) &&\n            Exit.isInterrupted(ex) === false &&\n            Schema.is(IntentionalShutdownCause)(Cause.squash(ex.cause)) === false &&\n            Schema.is(StoreInterrupted)(Cause.squash(ex.cause)) === false\n          ) {\n            yield* Effect.logError('[@livestore/adapter-web:client-session] client-session shutdown', ex.cause)\n          } else {\n            yield* Effect.logDebug('[@livestore/adapter-web:client-session] client-session shutdown', gotLocky, ex)\n          }\n\n          if (gotLocky) {\n            yield* Deferred.succeed(lockDeferred, undefined)\n          }\n        }).pipe(Effect.tapCauseLogPretty, Effect.orDie),\n      )\n\n      const leaderThread: ClientSession['leaderThread'] = {\n        export: runInWorker(new WorkerSchema.LeaderWorkerInner.Export()).pipe(\n          Effect.timeout(10_000),\n          UnexpectedError.mapToUnexpectedError,\n          Effect.withSpan('@livestore/adapter-web:client-session:export'),\n        ),\n\n        events: {\n          pull: ({ cursor }) =>\n            runInWorkerStream(new WorkerSchema.LeaderWorkerInner.PullStream({ cursor })).pipe(Stream.orDie),\n          push: (batch) =>\n            runInWorker(new WorkerSchema.LeaderWorkerInner.PushToLeader({ batch })).pipe(\n              Effect.withSpan('@livestore/adapter-web:client-session:pushToLeader', {\n                attributes: { batchSize: batch.length },\n              }),\n            ),\n        },\n\n        initialState: { leaderHead: initialLeaderHead, migrationsReport },\n\n        getEventlogData: runInWorker(new WorkerSchema.LeaderWorkerInner.ExportEventlog()).pipe(\n          Effect.timeout(10_000),\n          UnexpectedError.mapToUnexpectedError,\n          Effect.withSpan('@livestore/adapter-web:client-session:getEventlogData'),\n        ),\n\n        getSyncState: runInWorker(new WorkerSchema.LeaderWorkerInner.GetLeaderSyncState()).pipe(\n          UnexpectedError.mapToUnexpectedError,\n          Effect.withSpan('@livestore/adapter-web:client-session:getLeaderSyncState'),\n        ),\n\n        sendDevtoolsMessage: (message) =>\n          runInWorker(new WorkerSchema.LeaderWorkerInner.ExtraDevtoolsMessage({ message })).pipe(\n            UnexpectedError.mapToUnexpectedError,\n            Effect.withSpan('@livestore/adapter-web:client-session:devtoolsMessageForLeader'),\n          ),\n      }\n\n      const sharedWorker = yield* Fiber.join(sharedWorkerFiber)\n\n      const clientSession = yield* makeClientSession({\n        ...adapterArgs,\n        sqliteDb,\n        lockStatus,\n        clientId,\n        sessionId,\n        // isLeader: gotLocky, // TODO update when leader is changing\n        isLeader: true,\n        leaderThread,\n        webmeshMode: 'direct',\n        connectWebmeshNode: ({ sessionInfo, webmeshNode }) =>\n          connectWebmeshNodeClientSession({ webmeshNode, sessionInfo, sharedWorker, devtoolsEnabled, schema }),\n        registerBeforeUnload: (onBeforeUnload) => {\n          if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n            window.addEventListener('beforeunload', onBeforeUnload)\n            return () => window.removeEventListener('beforeunload', onBeforeUnload)\n          }\n\n          return () => {}\n        },\n      })\n\n      return clientSession\n    }).pipe(UnexpectedError.mapToUnexpectedError)\n\n// NOTE for `local` storage we could also use the eventlog db to store the data\nconst getPersistedId = (key: string, storageType: 'session' | 'local') => {\n  const makeId = () => nanoid(5)\n\n  const storage =\n    typeof window === 'undefined'\n      ? undefined\n      : storageType === 'session'\n        ? sessionStorage\n        : storageType === 'local'\n          ? localStorage\n          : shouldNeverHappen(`[@livestore/adapter-web] Invalid storage type: ${storageType}`)\n\n  // in case of a worker, we need the id of the parent window, to keep the id consistent\n  // we also need to handle the case where there are multiple workers being spawned by the same window\n  if (storage === undefined) {\n    return makeId()\n  }\n\n  const fullKey = `livestore:${key}`\n  const storedKey = storage.getItem(fullKey)\n\n  if (storedKey) return storedKey\n\n  const newKey = makeId()\n  storage.setItem(fullKey, newKey)\n\n  return newKey\n}\n\nconst ensureBrowserRequirements = Effect.gen(function* () {\n  const validate = (condition: boolean, label: string) =>\n    Effect.gen(function* () {\n      if (condition) {\n        yield* UnexpectedError.make({\n          cause: `[@livestore/adapter-web] Browser not supported. The LiveStore web adapter needs '${label}' to work properly`,\n        })\n      }\n    })\n\n  yield* Effect.all([\n    validate(typeof navigator === 'undefined', 'navigator'),\n    validate(navigator.locks === undefined, 'navigator.locks'),\n    validate(navigator.storage === undefined, 'navigator.storage'),\n    validate(crypto.randomUUID === undefined, 'crypto.randomUUID'),\n    validate(typeof window === 'undefined', 'window'),\n    validate(typeof sessionStorage === 'undefined', 'sessionStorage'),\n  ])\n})\n", "import type { Adapter, ClientSessionLeaderThreadProxy, LockStatus, SyncOptions } from '@livestore/common'\nimport { Devtools, makeClientSession, UnexpectedError } from '@livestore/common'\nimport type { DevtoolsOptions, LeaderSqliteDb } from '@livestore/common/leader-thread'\nimport { configureConnection, Eventlog, LeaderThreadCtx, makeLeaderThreadLayer } from '@livestore/common/leader-thread'\nimport type { LiveStoreSchema } from '@livestore/common/schema'\nimport { LiveStoreEvent } from '@livestore/common/schema'\nimport * as DevtoolsWeb from '@livestore/devtools-web-common/web-channel'\nimport type * as WebmeshWorker from '@livestore/devtools-web-common/worker'\nimport type { MakeWebSqliteDb } from '@livestore/sqlite-wasm/browser'\nimport { sqliteDbFactory } from '@livestore/sqlite-wasm/browser'\nimport { loadSqlite3Wasm } from '@livestore/sqlite-wasm/load-wasm'\nimport { tryAsFunctionAndNew } from '@livestore/utils'\nimport type { Schema, Scope } from '@livestore/utils/effect'\nimport { BrowserWorker, Effect, FetchHttpClient, Fiber, Layer, SubscriptionRef, Worker } from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\nimport * as Webmesh from '@livestore/webmesh'\n\nimport { connectWebmeshNodeClientSession } from '../web-worker/client-session/client-session-devtools.js'\nimport { makeShutdownChannel } from '../web-worker/common/shutdown-channel.js'\n\n// NOTE we're starting to initialize the sqlite wasm binary here to speed things up\nconst sqlite3Promise = loadSqlite3Wasm()\n\nexport interface InMemoryAdapterOptions {\n  importSnapshot?: Uint8Array\n  sync?: SyncOptions\n  /**\n   * The client ID to use for the adapter.\n   *\n   * @default a random nanoid\n   */\n  clientId?: string\n  /**\n   * The session ID to use for the adapter.\n   *\n   * @default a random nanoid\n   */\n  sessionId?: string\n  // TODO make the in-memory adapter work with the browser extension\n  /** In order to use the devtools with the in-memory adapter, you need to provide the shared worker. */\n  devtools?: {\n    sharedWorker:\n      | ((options: { name: string }) => globalThis.SharedWorker)\n      | (new (options: { name: string }) => globalThis.SharedWorker)\n  }\n}\n\nexport const makeInMemoryAdapter =\n  (options: InMemoryAdapterOptions = {}): Adapter =>\n  (adapterArgs) =>\n    Effect.gen(function* () {\n      const { schema, shutdown, syncPayload, storeId, devtoolsEnabled } = adapterArgs\n      const sqlite3 = yield* Effect.promise(() => sqlite3Promise)\n\n      const sqliteDb = yield* sqliteDbFactory({ sqlite3 })({ _tag: 'in-memory' })\n\n      const clientId = options.clientId ?? nanoid(6)\n      const sessionId = options.sessionId ?? nanoid(6)\n\n      const sharedWebWorker = options.devtools?.sharedWorker\n        ? tryAsFunctionAndNew(options.devtools.sharedWorker, {\n            name: `livestore-shared-worker-${storeId}`,\n          })\n        : undefined\n\n      const sharedWorkerFiber = sharedWebWorker\n        ? yield* Worker.makePoolSerialized<typeof WebmeshWorker.Schema.Request.Type>({\n            size: 1,\n            concurrency: 100,\n          }).pipe(\n            Effect.provide(BrowserWorker.layer(() => sharedWebWorker)),\n            Effect.tapCauseLogPretty,\n            UnexpectedError.mapToUnexpectedError,\n            Effect.forkScoped,\n          )\n        : undefined\n\n      const { leaderThread, initialSnapshot } = yield* makeLeaderThread({\n        schema,\n        storeId,\n        clientId,\n        makeSqliteDb: sqliteDbFactory({ sqlite3 }),\n        syncOptions: options.sync,\n        syncPayload,\n        importSnapshot: options.importSnapshot,\n        devtoolsEnabled,\n        sharedWorkerFiber,\n      })\n\n      sqliteDb.import(initialSnapshot)\n\n      const lockStatus = yield* SubscriptionRef.make<LockStatus>('has-lock')\n\n      const clientSession = yield* makeClientSession({\n        ...adapterArgs,\n        sqliteDb,\n        clientId,\n        sessionId,\n        isLeader: true,\n        leaderThread,\n        lockStatus,\n        shutdown,\n        webmeshMode: 'direct',\n        connectWebmeshNode: ({ sessionInfo, webmeshNode }) =>\n          Effect.gen(function* () {\n            if (sharedWorkerFiber === undefined || devtoolsEnabled === false) {\n              return\n            }\n\n            const sharedWorker = yield* sharedWorkerFiber.pipe(Fiber.join)\n\n            yield* connectWebmeshNodeClientSession({ webmeshNode, sessionInfo, sharedWorker, devtoolsEnabled, schema })\n          }),\n        registerBeforeUnload: (onBeforeUnload) => {\n          if (typeof window !== 'undefined' && typeof window.addEventListener === 'function') {\n            window.addEventListener('beforeunload', onBeforeUnload)\n            return () => window.removeEventListener('beforeunload', onBeforeUnload)\n          }\n\n          return () => {}\n        },\n      })\n\n      return clientSession\n    }).pipe(UnexpectedError.mapToUnexpectedError, Effect.provide(FetchHttpClient.layer))\n\nexport interface MakeLeaderThreadArgs {\n  schema: LiveStoreSchema\n  storeId: string\n  clientId: string\n  makeSqliteDb: MakeWebSqliteDb\n  syncOptions: SyncOptions | undefined\n  syncPayload: Schema.JsonValue | undefined\n  importSnapshot: Uint8Array | undefined\n  devtoolsEnabled: boolean\n  sharedWorkerFiber: SharedWorkerFiber | undefined\n}\n\nconst makeLeaderThread = ({\n  schema,\n  storeId,\n  clientId,\n  makeSqliteDb,\n  syncOptions,\n  syncPayload,\n  importSnapshot,\n  devtoolsEnabled,\n  sharedWorkerFiber,\n}: MakeLeaderThreadArgs) =>\n  Effect.gen(function* () {\n    const runtime = yield* Effect.runtime<never>()\n\n    const makeDb = (_kind: 'state' | 'eventlog') => {\n      return makeSqliteDb({\n        _tag: 'in-memory',\n        configureDb: (db) =>\n          configureConnection(db, { foreignKeys: true }).pipe(Effect.provide(runtime), Effect.runSync),\n      })\n    }\n\n    const shutdownChannel = yield* makeShutdownChannel(storeId)\n\n    // Might involve some async work, so we're running them concurrently\n    const [dbState, dbEventlog] = yield* Effect.all([makeDb('state'), makeDb('eventlog')], { concurrency: 2 })\n\n    if (importSnapshot) {\n      dbState.import(importSnapshot)\n    }\n\n    const devtoolsOptions = yield* makeDevtoolsOptions({\n      devtoolsEnabled,\n      sharedWorkerFiber,\n      dbState,\n      dbEventlog,\n      storeId,\n      clientId,\n    })\n\n    const layer = yield* Layer.build(\n      makeLeaderThreadLayer({\n        schema,\n        storeId,\n        clientId,\n        makeSqliteDb,\n        syncOptions,\n        dbState,\n        dbEventlog,\n        devtoolsOptions,\n        shutdownChannel,\n        syncPayload,\n      }),\n    )\n\n    return yield* Effect.gen(function* () {\n      const { dbState, dbEventlog, syncProcessor, extraIncomingMessagesQueue, initialState } = yield* LeaderThreadCtx\n\n      const initialLeaderHead = Eventlog.getClientHeadFromDb(dbEventlog)\n\n      const leaderThread = {\n        events: {\n          pull: ({ cursor }) => syncProcessor.pull({ cursor }),\n          push: (batch) =>\n            syncProcessor.push(\n              batch.map((item) => new LiveStoreEvent.EncodedWithMeta(item)),\n              { waitForProcessing: true },\n            ),\n        },\n        initialState: { leaderHead: initialLeaderHead, migrationsReport: initialState.migrationsReport },\n        export: Effect.sync(() => dbState.export()),\n        getEventlogData: Effect.sync(() => dbEventlog.export()),\n        getSyncState: syncProcessor.syncState,\n        sendDevtoolsMessage: (message) => extraIncomingMessagesQueue.offer(message),\n      } satisfies ClientSessionLeaderThreadProxy\n\n      const initialSnapshot = dbState.export()\n\n      return { leaderThread, initialSnapshot }\n    }).pipe(Effect.provide(layer))\n  })\n\ntype SharedWorkerFiber = Fiber.Fiber<\n  Worker.SerializedWorkerPool<typeof WebmeshWorker.Schema.Request.Type>,\n  UnexpectedError\n>\n\nconst makeDevtoolsOptions = ({\n  devtoolsEnabled,\n  sharedWorkerFiber,\n  dbState,\n  dbEventlog,\n  storeId,\n  clientId,\n}: {\n  devtoolsEnabled: boolean\n  sharedWorkerFiber: SharedWorkerFiber | undefined\n  dbState: LeaderSqliteDb\n  dbEventlog: LeaderSqliteDb\n  storeId: string\n  clientId: string\n}): Effect.Effect<DevtoolsOptions, UnexpectedError, Scope.Scope> =>\n  Effect.gen(function* () {\n    if (devtoolsEnabled === false || sharedWorkerFiber === undefined) {\n      return { enabled: false }\n    }\n\n    return {\n      enabled: true,\n      boot: Effect.gen(function* () {\n        const persistenceInfo = {\n          state: dbState.metadata.persistenceInfo,\n          eventlog: dbEventlog.metadata.persistenceInfo,\n        }\n\n        const node = yield* Webmesh.makeMeshNode(Devtools.makeNodeName.client.leader({ storeId, clientId }))\n        // @ts-expect-error TODO type this\n        globalThis.__debugWebmeshNodeLeader = node\n\n        const sharedWorker = yield* sharedWorkerFiber.pipe(Fiber.join)\n\n        // TODO also make this work with the browser extension\n        // basic idea: instead of also connecting to the shared worker,\n        // connect to the client session node above which will already connect to the shared worker + browser extension\n\n        yield* DevtoolsWeb.connectViaWorker({\n          node,\n          worker: sharedWorker,\n          target: DevtoolsWeb.makeNodeName.sharedWorker({ storeId }),\n        }).pipe(Effect.tapCauseLogPretty, Effect.forkScoped)\n\n        return { node, persistenceInfo, mode: 'direct' }\n      }),\n    }\n  })\n"],
  "mappings": "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",
  "names": ["mod_exports", "mod_exports", "sharedWorker", "migrationsReport", "sqlite3Promise", "dbState", "dbEventlog", "mod_exports"]
}

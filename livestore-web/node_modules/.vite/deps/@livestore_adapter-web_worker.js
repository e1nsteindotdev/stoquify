import {
  CacheService,
  CreateConnection2 as CreateConnection,
  LeaderThreadCtx,
  LeaderWorkerInner,
  LeaderWorkerOuter,
  configureConnection,
  eventlog_exports,
  getStateDbFileName,
  loadSqlite3Wasm,
  makeLeaderThreadLayer,
  makeShutdownChannel,
  opfs_utils_exports,
  sanitizeOpfsDir,
  sqliteDbFactory
} from "./chunk-OFAEZEPS.js";
import {
  BrowserWorkerRunner_exports,
  Effect_exports,
  FetchHttpClient_exports,
  LS_DEV,
  Layer_exports,
  LiveStoreEvent_exports,
  LogLevel_exports,
  Logger_exports,
  Scheduler_exports,
  Stream_exports,
  TaskTracing_exports,
  Tracer_exports,
  UnexpectedError,
  WorkerRunner_exports,
  identity,
  isDevEnv,
  mod_exports4 as mod_exports
} from "./chunk-J7UPD3II.js";
import "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/dist/web-worker/leader-worker/make-leader-worker.js
if (isDevEnv()) {
  globalThis.__debugLiveStoreUtils = {
    opfs: opfs_utils_exports,
    blobUrl: (buffer) => URL.createObjectURL(new Blob([buffer], { type: "application/octet-stream" })),
    runSync: (effect) => Effect_exports.runSync(effect),
    runFork: (effect) => Effect_exports.runFork(effect)
  };
}
var makeWorker = (options) => {
  makeWorkerEffect(options).pipe(Effect_exports.runFork);
};
var makeWorkerEffect = (options) => {
  var _a;
  const TracingLive = ((_a = options.otelOptions) == null ? void 0 : _a.tracer) ? Layer_exports.unwrapEffect(Effect_exports.map(Tracer_exports.make, Layer_exports.setTracer)).pipe(Layer_exports.provideMerge(Layer_exports.succeed(Tracer_exports.OtelTracer, options.otelOptions.tracer))) : void 0;
  return makeWorkerRunnerOuter(options).pipe(
    Layer_exports.provide(BrowserWorkerRunner_exports.layer),
    WorkerRunner_exports.launch,
    Effect_exports.scoped,
    Effect_exports.tapCauseLogPretty,
    Effect_exports.annotateLogs({ thread: self.name }),
    Effect_exports.provide(Logger_exports.prettyWithThread(self.name)),
    Effect_exports.provide(FetchHttpClient_exports.layer),
    LS_DEV ? TaskTracing_exports.withAsyncTaggingTracing((name) => console.createTask(name)) : identity,
    TracingLive ? Effect_exports.provide(TracingLive) : identity,
    // We're using this custom scheduler to improve op batching behaviour and reduce the overhead
    // of the Effect fiber runtime given we have different tradeoffs on a worker thread.
    // Despite the "message channel" name, is has nothing to do with the `incomingRequestsPort` above.
    Effect_exports.withScheduler(Scheduler_exports.messageChannel()),
    // We're increasing the Effect ops limit here to allow for larger chunks of operations at a time
    Effect_exports.withMaxOpsBeforeYield(4096),
    Logger_exports.withMinimumLogLevel(LogLevel_exports.Debug)
  );
};
var makeWorkerRunnerOuter = (workerOptions) => WorkerRunner_exports.layerSerialized(LeaderWorkerOuter.InitialMessage, {
  // Port coming from client session and forwarded via the shared worker
  InitialMessage: ({ port: incomingRequestsPort, storeId, clientId }) => Effect_exports.gen(function* () {
    yield* makeWorkerRunnerInner(workerOptions).pipe(Layer_exports.provide(BrowserWorkerRunner_exports.layerMessagePort(incomingRequestsPort)), WorkerRunner_exports.launch, Effect_exports.scoped, Effect_exports.withSpan("@livestore/adapter-web:worker:wrapper:InitialMessage:innerFiber"), Effect_exports.tapCauseLogPretty, Effect_exports.provide(CacheService.layer({ nodeName: mod_exports.makeNodeName.client.leader({ storeId, clientId }) })), Effect_exports.forkScoped);
    return Layer_exports.empty;
  }).pipe(Effect_exports.withSpan("@livestore/adapter-web:worker:wrapper:InitialMessage"), Layer_exports.unwrapScoped)
});
var makeWorkerRunnerInner = ({ schema, sync: syncOptions }) => WorkerRunner_exports.layerSerialized(LeaderWorkerInner.Request, {
  InitialMessage: ({ storageOptions, storeId, clientId, devtoolsEnabled, debugInstanceId, syncPayload }) => Effect_exports.gen(function* () {
    const sqlite3 = yield* Effect_exports.promise(() => loadSqlite3Wasm());
    const makeSqliteDb = sqliteDbFactory({ sqlite3 });
    const runtime = yield* Effect_exports.runtime();
    const makeDb = (kind) => makeSqliteDb({
      _tag: "opfs",
      opfsDirectory: sanitizeOpfsDir(storageOptions.directory, storeId),
      fileName: kind === "state" ? getStateDbFileName(schema) : "eventlog.db",
      configureDb: (db) => configureConnection(db, {
        //  The persisted databases use the AccessHandlePoolVFS which always uses a single database connection.
        //  Multiple connections are not supported. This means that we can use the exclusive locking mode to
        //  avoid unnecessary system calls and enable the use of the WAL journal mode without the use of shared memory.
        // TODO bring back exclusive locking mode when `WAL` is working properly
        // lockingMode: 'EXCLUSIVE',
        foreignKeys: true
      }).pipe(Effect_exports.provide(runtime), Effect_exports.runSync)
    }).pipe(Effect_exports.acquireRelease((db) => Effect_exports.try(() => db.close()).pipe(Effect_exports.ignoreLogged)));
    const [dbState, dbEventlog] = yield* Effect_exports.all([makeDb("state"), makeDb("eventlog")], {
      concurrency: 2
    });
    const devtoolsOptions = yield* makeDevtoolsOptions({ devtoolsEnabled, dbState, dbEventlog });
    const shutdownChannel = yield* makeShutdownChannel(storeId);
    return makeLeaderThreadLayer({
      schema,
      storeId,
      clientId,
      makeSqliteDb,
      syncOptions,
      dbState,
      dbEventlog,
      devtoolsOptions,
      shutdownChannel,
      syncPayload
    });
  }).pipe(Effect_exports.tapCauseLogPretty, UnexpectedError.mapToUnexpectedError, Effect_exports.withPerformanceMeasure("@livestore/adapter-web:worker:InitialMessage"), Effect_exports.withSpan("@livestore/adapter-web:worker:InitialMessage"), Effect_exports.annotateSpans({ debugInstanceId }), Layer_exports.unwrapScoped),
  GetRecreateSnapshot: () => Effect_exports.gen(function* () {
    const workerCtx = yield* LeaderThreadCtx;
    const snapshot = workerCtx.dbState.export();
    return { snapshot, migrationsReport: workerCtx.initialState.migrationsReport };
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:GetRecreateSnapshot")),
  PullStream: ({ cursor }) => Effect_exports.gen(function* () {
    const { syncProcessor } = yield* LeaderThreadCtx;
    return syncProcessor.pull({ cursor });
  }).pipe(Stream_exports.unwrapScoped),
  PushToLeader: ({ batch }) => Effect_exports.andThen(LeaderThreadCtx, ({ syncProcessor }) => syncProcessor.push(
    batch.map((event) => new LiveStoreEvent_exports.EncodedWithMeta(event)),
    // We'll wait in order to keep back pressure on the client session
    { waitForProcessing: true }
  )).pipe(Effect_exports.uninterruptible, Effect_exports.withSpan("@livestore/adapter-web:worker:PushToLeader")),
  Export: () => Effect_exports.andThen(LeaderThreadCtx, (_) => _.dbState.export()).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:Export")),
  ExportEventlog: () => Effect_exports.andThen(LeaderThreadCtx, (_) => _.dbEventlog.export()).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:ExportEventlog")),
  BootStatusStream: () => Effect_exports.andThen(LeaderThreadCtx, (_) => Stream_exports.fromQueue(_.bootStatusQueue)).pipe(Stream_exports.unwrap),
  GetLeaderHead: () => Effect_exports.gen(function* () {
    const workerCtx = yield* LeaderThreadCtx;
    return eventlog_exports.getClientHeadFromDb(workerCtx.dbEventlog);
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:GetLeaderHead")),
  GetLeaderSyncState: () => Effect_exports.gen(function* () {
    const workerCtx = yield* LeaderThreadCtx;
    return yield* workerCtx.syncProcessor.syncState;
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:GetLeaderSyncState")),
  Shutdown: () => Effect_exports.gen(function* () {
    yield* Effect_exports.logDebug("[@livestore/adapter-web:worker] Shutdown");
    yield* Effect_exports.sleep(300);
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:Shutdown")),
  ExtraDevtoolsMessage: ({ message }) => Effect_exports.andThen(LeaderThreadCtx, (_) => _.extraIncomingMessagesQueue.offer(message)).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:worker:ExtraDevtoolsMessage")),
  "DevtoolsWebCommon.CreateConnection": CreateConnection
});
var makeDevtoolsOptions = ({ devtoolsEnabled, dbState, dbEventlog }) => Effect_exports.gen(function* () {
  if (devtoolsEnabled === false) {
    return { enabled: false };
  }
  const { node } = yield* CacheService;
  return {
    enabled: true,
    boot: Effect_exports.gen(function* () {
      const persistenceInfo = {
        state: dbState.metadata.persistenceInfo,
        eventlog: dbEventlog.metadata.persistenceInfo
      };
      return { node, persistenceInfo, mode: "direct" };
    })
  };
});
export {
  makeWorker,
  makeWorkerEffect
};
//# sourceMappingURL=@livestore_adapter-web_worker.js.map

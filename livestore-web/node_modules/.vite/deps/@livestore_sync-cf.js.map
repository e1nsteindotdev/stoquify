{
  "version": 3,
  "sources": ["../../.pnpm/@livestore+sync-cf@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/sync-cf/src/common/ws-message-types.ts", "../../.pnpm/@livestore+sync-cf@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/sync-cf/src/common/mod.ts", "../../.pnpm/@livestore+sync-cf@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/sync-cf/src/sync-impl/ws-impl.ts"],
  "sourcesContent": ["import { LiveStoreEvent } from '@livestore/common/schema'\nimport { Schema } from '@livestore/utils/effect'\n\nexport const PullReq = Schema.TaggedStruct('WSMessage.PullReq', {\n  requestId: Schema.String,\n  /** Omitting the cursor will start from the beginning */\n  cursor: Schema.optional(Schema.Number),\n}).annotations({ title: '@livestore/sync-cf:PullReq' })\n\nexport type PullReq = typeof PullReq.Type\n\nexport const SyncMetadata = Schema.Struct({\n  /** ISO date format */\n  createdAt: Schema.String,\n}).annotations({ title: '@livestore/sync-cf:SyncMetadata' })\n\nexport type SyncMetadata = typeof SyncMetadata.Type\n\nexport const PullRes = Schema.TaggedStruct('WSMessage.PullRes', {\n  batch: Schema.Array(\n    Schema.Struct({\n      eventEncoded: LiveStoreEvent.AnyEncodedGlobal,\n      metadata: Schema.Option(SyncMetadata),\n    }),\n  ),\n  requestId: Schema.Struct({ context: Schema.Literal('pull', 'push'), requestId: Schema.String }),\n  remaining: Schema.Number,\n}).annotations({ title: '@livestore/sync-cf:PullRes' })\n\nexport type PullRes = typeof PullRes.Type\n\nexport const PushReq = Schema.TaggedStruct('WSMessage.PushReq', {\n  requestId: Schema.String,\n  batch: Schema.Array(LiveStoreEvent.AnyEncodedGlobal),\n}).annotations({ title: '@livestore/sync-cf:PushReq' })\n\nexport type PushReq = typeof PushReq.Type\n\nexport const PushAck = Schema.TaggedStruct('WSMessage.PushAck', {\n  requestId: Schema.String,\n}).annotations({ title: '@livestore/sync-cf:PushAck' })\n\nexport type PushAck = typeof PushAck.Type\n\nexport const Error = Schema.TaggedStruct('WSMessage.Error', {\n  requestId: Schema.String,\n  message: Schema.String,\n}).annotations({ title: '@livestore/sync-cf:Error' })\n\nexport type Error = typeof Error.Type\n\nexport const Ping = Schema.TaggedStruct('WSMessage.Ping', {\n  requestId: Schema.Literal('ping'),\n}).annotations({ title: '@livestore/sync-cf:Ping' })\n\nexport type Ping = typeof Ping.Type\n\nexport const Pong = Schema.TaggedStruct('WSMessage.Pong', {\n  requestId: Schema.Literal('ping'),\n}).annotations({ title: '@livestore/sync-cf:Pong' })\n\nexport type Pong = typeof Pong.Type\n\nexport const AdminResetRoomReq = Schema.TaggedStruct('WSMessage.AdminResetRoomReq', {\n  requestId: Schema.String,\n  adminSecret: Schema.String,\n}).annotations({ title: '@livestore/sync-cf:AdminResetRoomReq' })\n\nexport type AdminResetRoomReq = typeof AdminResetRoomReq.Type\n\nexport const AdminResetRoomRes = Schema.TaggedStruct('WSMessage.AdminResetRoomRes', {\n  requestId: Schema.String,\n}).annotations({ title: '@livestore/sync-cf:AdminResetRoomRes' })\n\nexport type AdminResetRoomRes = typeof AdminResetRoomRes.Type\n\nexport const AdminInfoReq = Schema.TaggedStruct('WSMessage.AdminInfoReq', {\n  requestId: Schema.String,\n  adminSecret: Schema.String,\n}).annotations({ title: '@livestore/sync-cf:AdminInfoReq' })\n\nexport type AdminInfoReq = typeof AdminInfoReq.Type\n\nexport const AdminInfoRes = Schema.TaggedStruct('WSMessage.AdminInfoRes', {\n  requestId: Schema.String,\n  info: Schema.Struct({\n    durableObjectId: Schema.String,\n  }),\n}).annotations({ title: '@livestore/sync-cf:AdminInfoRes' })\n\nexport type AdminInfoRes = typeof AdminInfoRes.Type\n\nexport const Message = Schema.Union(\n  PullReq,\n  PullRes,\n  PushReq,\n  PushAck,\n  Error,\n  Ping,\n  Pong,\n  AdminResetRoomReq,\n  AdminResetRoomRes,\n  AdminInfoReq,\n  AdminInfoRes,\n).annotations({ title: '@livestore/sync-cf:Message' })\n\nexport type Message = typeof Message.Type\nexport type MessageEncoded = typeof Message.Encoded\n\nexport const BackendToClientMessage = Schema.Union(PullRes, PushAck, AdminResetRoomRes, AdminInfoRes, Error, Pong)\nexport type BackendToClientMessage = typeof BackendToClientMessage.Type\n\nexport const ClientToBackendMessage = Schema.Union(PullReq, PushReq, AdminResetRoomReq, AdminInfoReq, Ping)\nexport type ClientToBackendMessage = typeof ClientToBackendMessage.Type\n", "import { Schema } from '@livestore/utils/effect'\n\nexport * as WSMessage from './ws-message-types.js'\n\nexport const SearchParamsSchema = Schema.Struct({\n  storeId: Schema.String,\n  payload: Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(Schema.JsonValue)).pipe(Schema.UndefinedOr),\n})\n", "/// <reference lib=\"dom\" />\n\nimport type { SyncBackend, SyncBackendConstructor } from '@livestore/common'\nimport { InvalidPullError, InvalidPushError, UnexpectedError } from '@livestore/common'\nimport { EventSequenceNumber } from '@livestore/common/schema'\nimport { LS_DEV, shouldNeverHappen } from '@livestore/utils'\nimport {\n  Deferred,\n  Effect,\n  Option,\n  PubSub,\n  Queue,\n  Schedule,\n  Schema,\n  Stream,\n  SubscriptionRef,\n  UrlParams,\n  WebSocket,\n} from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\n\nimport { SearchParamsSchema, WSMessage } from '../common/mod.js'\nimport type { SyncMetadata } from '../common/ws-message-types.js'\n\nexport interface WsSyncOptions {\n  url: string\n}\n\nexport const makeCfSync =\n  (options: WsSyncOptions): SyncBackendConstructor<SyncMetadata> =>\n  ({ storeId, payload }) =>\n    Effect.gen(function* () {\n      const urlParamsData = yield* Schema.encode(SearchParamsSchema)({\n        storeId,\n        payload,\n      }).pipe(UnexpectedError.mapToUnexpectedError)\n\n      const urlParams = UrlParams.fromInput(urlParamsData)\n      const wsUrl = `${options.url}/websocket?${UrlParams.toString(urlParams)}`\n\n      const { isConnected, incomingMessages, send } = yield* connect(wsUrl)\n\n      /**\n       * We need to account for the scenario where push-caused PullRes message arrive before the pull-caused PullRes message.\n       * i.e. a scenario where the WS connection is created but before the server processed the initial pull, a push from\n       * another client triggers a PullRes message sent to this client which we need to stash until our pull-caused\n       * PullRes message arrives at which point we can combine the stashed events with the pull-caused events and continue.\n       */\n      const stashedPullBatch: WSMessage.PullRes['batch'][number][] = []\n\n      // We currently only support one pull stream for a sync backend.\n      let pullStarted = false\n\n      const api = {\n        isConnected,\n        // Currently we're already eagerly connecting when the sync backend is created but we might want to refactor this later to clean this up\n        connect: Effect.void,\n        pull: (args) =>\n          Effect.gen(function* () {\n            if (pullStarted) {\n              return shouldNeverHappen(`Pull already started for this sync backend.`)\n            }\n\n            pullStarted = true\n\n            let pullResponseReceived = false\n\n            const requestId = nanoid()\n            const cursor = Option.getOrUndefined(args)?.cursor.global\n\n            yield* send(WSMessage.PullReq.make({ cursor, requestId }))\n\n            return Stream.fromPubSub(incomingMessages).pipe(\n              Stream.tap((_) =>\n                _._tag === 'WSMessage.Error' && _.requestId === requestId\n                  ? new InvalidPullError({ message: _.message })\n                  : Effect.void,\n              ),\n              Stream.filterMap((msg) => {\n                if (msg._tag === 'WSMessage.PullRes') {\n                  if (msg.requestId.context === 'pull') {\n                    if (msg.requestId.requestId === requestId) {\n                      pullResponseReceived = true\n\n                      if (stashedPullBatch.length > 0 && msg.remaining === 0) {\n                        const pullResHead = msg.batch.at(-1)?.eventEncoded.seqNum ?? EventSequenceNumber.ROOT.global\n                        // Index where stashed events are greater than pullResHead\n                        const newPartialBatchIndex = stashedPullBatch.findIndex(\n                          (batchItem) => batchItem.eventEncoded.seqNum > pullResHead,\n                        )\n                        const batchWithNewStashedEvents =\n                          newPartialBatchIndex === -1 ? [] : stashedPullBatch.slice(newPartialBatchIndex)\n                        const combinedBatch = [...msg.batch, ...batchWithNewStashedEvents]\n                        return Option.some({ ...msg, batch: combinedBatch, remaining: 0 })\n                      } else {\n                        return Option.some(msg)\n                      }\n                    } else {\n                      // Ignore\n                      return Option.none()\n                    }\n                  } else {\n                    if (pullResponseReceived) {\n                      return Option.some(msg)\n                    } else {\n                      stashedPullBatch.push(...msg.batch)\n                      return Option.none()\n                    }\n                  }\n                }\n\n                return Option.none()\n              }),\n            )\n          }).pipe(Stream.unwrap),\n\n        push: (batch) =>\n          Effect.gen(function* () {\n            const pushAck = yield* Deferred.make<void, InvalidPushError>()\n            const requestId = nanoid()\n\n            yield* Stream.fromPubSub(incomingMessages).pipe(\n              Stream.tap((_) =>\n                _._tag === 'WSMessage.Error' && _.requestId === requestId\n                  ? Deferred.fail(pushAck, new InvalidPushError({ reason: { _tag: 'Unexpected', message: _.message } }))\n                  : Effect.void,\n              ),\n              Stream.filter((_) => _._tag === 'WSMessage.PushAck' && _.requestId === requestId),\n              Stream.take(1),\n              Stream.tap(() => Deferred.succeed(pushAck, void 0)),\n              Stream.runDrain,\n              Effect.tapCauseLogPretty,\n              Effect.fork,\n            )\n\n            yield* send(WSMessage.PushReq.make({ batch, requestId }))\n\n            yield* pushAck\n          }),\n        metadata: {\n          name: '@livestore/cf-sync',\n          description: 'LiveStore sync backend implementation using Cloudflare Workers & Durable Objects',\n          protocol: 'ws',\n          url: options.url,\n        },\n      } satisfies SyncBackend<SyncMetadata>\n\n      return api\n    })\n\nconst connect = (wsUrl: string) =>\n  Effect.gen(function* () {\n    const isConnected = yield* SubscriptionRef.make(false)\n    const socketRef: { current: globalThis.WebSocket | undefined } = { current: undefined }\n\n    const incomingMessages = yield* PubSub.unbounded<Exclude<WSMessage.BackendToClientMessage, WSMessage.Pong>>().pipe(\n      Effect.acquireRelease(PubSub.shutdown),\n    )\n\n    const waitUntilOnline = isConnected.changes.pipe(Stream.filter(Boolean), Stream.take(1), Stream.runDrain)\n\n    const send = (message: WSMessage.Message) =>\n      Effect.gen(function* () {\n        // Wait first until we're online\n        yield* waitUntilOnline\n\n        // TODO use MsgPack instead of JSON to speed up the serialization / reduce the size of the messages\n        socketRef.current!.send(Schema.encodeSync(Schema.parseJson(WSMessage.Message))(message))\n\n        if (LS_DEV) {\n          yield* Effect.spanEvent(\n            `Sent message: ${message._tag}`,\n            message._tag === 'WSMessage.PushReq'\n              ? {\n                  seqNum: message.batch[0]!.seqNum,\n                  parentSeqNum: message.batch[0]!.parentSeqNum,\n                  batchLength: message.batch.length,\n                }\n              : message._tag === 'WSMessage.PullReq'\n                ? { cursor: message.cursor ?? '-' }\n                : {},\n          )\n        }\n      })\n\n    const innerConnect = Effect.gen(function* () {\n      // If the browser already tells us we're offline, then we'll at least wait until the browser\n      // thinks we're online again. (We'll only know for sure once the WS conneciton is established.)\n      while (typeof navigator !== 'undefined' && navigator.onLine === false) {\n        yield* Effect.sleep(1000)\n      }\n      // TODO bring this back in a cross-platform way\n      // if (navigator.onLine === false) {\n      //   yield* Effect.async((cb) => self.addEventListener('online', () => cb(Effect.void)))\n      // }\n\n      const socket = yield* WebSocket.makeWebSocket({ url: wsUrl, reconnect: Schedule.exponential(100) })\n      // socket.binaryType = 'arraybuffer'\n\n      yield* SubscriptionRef.set(isConnected, true)\n      socketRef.current = socket\n\n      const connectionClosed = yield* Deferred.make<void>()\n\n      const pongMessages = yield* Queue.unbounded<WSMessage.Pong>().pipe(Effect.acquireRelease(Queue.shutdown))\n\n      yield* Effect.eventListener(socket, 'message', (event: MessageEvent) =>\n        Effect.gen(function* () {\n          const decodedEventRes = Schema.decodeUnknownEither(Schema.parseJson(WSMessage.BackendToClientMessage))(\n            event.data,\n          )\n\n          if (decodedEventRes._tag === 'Left') {\n            console.error('Sync: Invalid message received', decodedEventRes.left)\n            return\n          } else {\n            if (decodedEventRes.right._tag === 'WSMessage.Pong') {\n              yield* Queue.offer(pongMessages, decodedEventRes.right)\n            } else {\n              // yield* Effect.logDebug(`decodedEventRes: ${decodedEventRes.right._tag}`)\n              yield* PubSub.publish(incomingMessages, decodedEventRes.right)\n            }\n          }\n        }),\n      )\n\n      yield* Effect.eventListener(socket, 'close', () => Deferred.succeed(connectionClosed, void 0))\n\n      yield* Effect.eventListener(socket, 'error', () =>\n        Effect.gen(function* () {\n          socket.close(3000, 'Sync: WebSocket error')\n          yield* Deferred.succeed(connectionClosed, void 0)\n        }),\n      )\n\n      // NOTE it seems that this callback doesn't work reliably on a worker but only via `window.addEventListener`\n      // We might need to proxy the event from the main thread to the worker if we want this to work reliably.\n      // eslint-disable-next-line unicorn/prefer-global-this\n      if (typeof self !== 'undefined' && typeof self.addEventListener === 'function') {\n        // TODO support an Expo equivalent for this\n        // eslint-disable-next-line unicorn/prefer-global-this\n        yield* Effect.eventListener(self, 'offline', () => Deferred.succeed(connectionClosed, void 0))\n      }\n\n      yield* Effect.addFinalizer(() =>\n        Effect.gen(function* () {\n          socketRef.current = undefined\n          yield* SubscriptionRef.set(isConnected, false)\n        }),\n      )\n\n      const checkPingPong = Effect.gen(function* () {\n        // TODO include pong latency infomation in network status\n        yield* send({ _tag: 'WSMessage.Ping', requestId: 'ping' })\n\n        // NOTE those numbers might need more fine-tuning to allow for bad network conditions\n        yield* Queue.take(pongMessages).pipe(Effect.timeout(5000))\n\n        yield* Effect.sleep(25_000)\n      }).pipe(Effect.withSpan('@livestore/sync-cf:connect:checkPingPong'), Effect.ignore)\n\n      yield* waitUntilOnline.pipe(\n        Effect.andThen(checkPingPong.pipe(Effect.forever)),\n        Effect.tapErrorCause(() => Deferred.succeed(connectionClosed, void 0)),\n        Effect.forkScoped,\n      )\n\n      yield* connectionClosed\n    }).pipe(Effect.scoped, Effect.withSpan('@livestore/sync-cf:connect'))\n\n    yield* innerConnect.pipe(Effect.forever, Effect.interruptible, Effect.tapCauseLogPretty, Effect.forkScoped)\n\n    return { isConnected, incomingMessages, send }\n  })\n"],
  "mappings": "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",
  "names": ["_a"]
}

import {
  createStore,
  extractStackInfoFromStackTrace,
  makeShutdownDeferred,
  queryDb,
  stackInfoToString
} from "./chunk-L7G2HKHX.js";
import {
  require_jsx_runtime
} from "./chunk-PVOJWVQJ.js";
import {
  Cause_exports,
  Deferred_exports,
  Effect_exports,
  Exit_exports,
  IS_REACT_NATIVE,
  LS_DEV,
  LogLevel_exports,
  Logger_exports,
  Schema_exports,
  Scope_exports,
  SessionIdSymbol,
  StoreInterrupted,
  TaskTracing_exports,
  UnexpectedError,
  context,
  deepEqual,
  identity,
  indent,
  mod_exports3 as mod_exports,
  objectToString,
  provideOtel,
  shouldNeverHappen,
  trace
} from "./chunk-J7UPD3II.js";
import {
  require_react
} from "./chunk-ADNINGB3.js";
import {
  __toESM
} from "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/LiveStoreContext.js
var import_react = __toESM(require_react(), 1);
var LiveStoreContext = import_react.default.createContext(void 0);

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useStore.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useClientDocument.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useQuery.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useRcResource.js
var React2 = __toESM(require_react(), 1);
var useRcResource = (key, create, dispose, _options) => {
  const keyRef = React2.useRef(void 0);
  const didDisposeInMemo = React2.useRef(false);
  const resource = React2.useMemo(() => {
    if (didDisposeInMemo.current) {
      const cachedItem2 = cache.get(key);
      if (cachedItem2 !== void 0 && cachedItem2._tag === "active") {
        return cachedItem2.resource;
      }
    }
    if (keyRef.current !== void 0 && keyRef.current !== key) {
      const previousKey = keyRef.current;
      const cachedItemForPreviousKey = cache.get(previousKey);
      if (cachedItemForPreviousKey !== void 0 && cachedItemForPreviousKey._tag === "active") {
        cachedItemForPreviousKey.rc--;
        if (cachedItemForPreviousKey.rc === 0) {
          dispose(cachedItemForPreviousKey.resource);
          cache.set(previousKey, { _tag: "destroyed" });
          didDisposeInMemo.current = true;
        }
      }
    }
    const cachedItem = cache.get(key);
    if (cachedItem !== void 0 && cachedItem._tag === "active") {
      cachedItem.rc++;
      return cachedItem.resource;
    }
    const resource2 = create();
    cache.set(key, { _tag: "active", rc: 1, resource: resource2 });
    return resource2;
  }, [key]);
  React2.useEffect(() => {
    return () => {
      if (didDisposeInMemo.current) {
        didDisposeInMemo.current = false;
        return;
      }
      const cachedItem = cache.get(key);
      if (cachedItem === void 0 || cachedItem._tag === "destroyed")
        return;
      cachedItem.rc--;
      if (cachedItem.rc === 0) {
        dispose(cachedItem.resource);
        cache.delete(key);
      }
    };
  }, [key]);
  keyRef.current = key;
  return resource;
};
var cache = /* @__PURE__ */ new Map();

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/utils/stack-info.js
var import_react2 = __toESM(require_react(), 1);
var originalStackLimit = Error.stackTraceLimit;
var useStackInfo = () => import_react2.default.useMemo(() => {
  Error.stackTraceLimit = 10;
  const stack = new Error().stack;
  Error.stackTraceLimit = originalStackLimit;
  return extractStackInfoFromStackTrace(stack);
}, []);

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/utils/useStateRefWithReactiveInput.js
var import_react3 = __toESM(require_react(), 1);
var useStateRefWithReactiveInput = (inputState) => {
  const [_, rerender] = import_react3.default.useState(0);
  const lastKnownInputStateRef = import_react3.default.useRef(inputState);
  const stateRef = import_react3.default.useRef(inputState);
  if (lastKnownInputStateRef.current !== inputState) {
    lastKnownInputStateRef.current = inputState;
    stateRef.current = inputState;
  }
  const setStateAndRerender = import_react3.default.useCallback((newState) => {
    const val = typeof newState === "function" ? newState(stateRef.current) : newState;
    stateRef.current = val;
    rerender((c) => c + 1);
  }, [rerender]);
  return [stateRef, setStateAndRerender];
};

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useQuery.js
var useQuery = (queryDef, options) => useQueryRef(queryDef, options).valueRef.current;
var useQueryRef = (queryDef, options) => {
  var _a;
  const store = (options == null ? void 0 : options.store) ?? ((_a = import_react4.default.useContext(LiveStoreContext)) == null ? void 0 : _a.store) ?? shouldNeverHappen(`No store provided to useQuery`);
  const rcRefKey = `${store.storeId}_${store.clientId}_${store.sessionId}_${queryDef.hash}`;
  const stackInfo = import_react4.default.useMemo(() => {
    Error.stackTraceLimit = 10;
    const stack = new Error().stack;
    Error.stackTraceLimit = originalStackLimit;
    return extractStackInfoFromStackTrace(stack);
  }, []);
  const { queryRcRef, span, otelContext } = useRcResource(
    rcRefKey,
    () => {
      const queryDefLabel = queryDef.label;
      const span2 = store.otel.tracer.startSpan((options == null ? void 0 : options.otelSpanName) ?? `LiveStore:useQuery:${queryDefLabel}`, { attributes: { label: queryDefLabel, firstStackInfo: JSON.stringify(stackInfo) } }, (options == null ? void 0 : options.otelContext) ?? store.otel.queriesSpanContext);
      const otelContext2 = trace.setSpan(context.active(), span2);
      const queryRcRef2 = queryDef.make(store.reactivityGraph.context, otelContext2);
      return { queryRcRef: queryRcRef2, span: span2, otelContext: otelContext2 };
    },
    // We need to keep the queryRcRef alive a bit longer, so we have a second `useRcResource` below
    // which takes care of disposing the queryRcRef
    () => {
    }
  );
  const query$ = queryRcRef.value;
  import_react4.default.useDebugValue(`LiveStore:useQuery:${query$.id}:${query$.label}`);
  const initialResult = import_react4.default.useMemo(() => {
    try {
      return query$.run({
        otelContext,
        debugRefreshReason: {
          _tag: "react",
          api: "useQuery",
          label: `useQuery:initial-run:${query$.label}`,
          stackInfo
        }
      });
    } catch (cause) {
      console.error("[@livestore/react:useQuery] Error running query", cause);
      throw new Error(`[@livestore/react:useQuery] Error running query: ${cause.name}

Query: ${query$.label}

React trace:

${indent(stackInfoToString(stackInfo), 4)}

Stack trace:
`, { cause });
    }
  }, [otelContext, query$, stackInfo]);
  const [valueRef, setValue] = useStateRefWithReactiveInput(initialResult);
  import_react4.default.useEffect(() => {
    query$.activeSubscriptions.add(stackInfo);
    span.updateName((options == null ? void 0 : options.otelSpanName) ?? `LiveStore:useQuery:${query$.label}`);
    return store.subscribe(query$, {
      onUpdate: (newValue) => {
        if (deepEqual(newValue, valueRef.current) === false) {
          setValue(newValue);
        }
      },
      onUnsubsubscribe: () => {
        query$.activeSubscriptions.delete(stackInfo);
      },
      label: query$.label,
      otelContext
    });
  }, [stackInfo, query$, setValue, store, valueRef, otelContext, span, options == null ? void 0 : options.otelSpanName]);
  useRcResource(rcRefKey, () => ({ queryRcRef, span }), ({ queryRcRef: queryRcRef2, span: span2 }) => {
    queryRcRef2.deref();
    span2.end();
  });
  return { valueRef, queryRcRef };
};

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useClientDocument.js
var useClientDocument = (table, idOrOptions, options_, storeArg) => {
  var _a;
  const id = typeof idOrOptions === "string" || idOrOptions === SessionIdSymbol ? idOrOptions : table[mod_exports.SQLite.ClientDocumentTableDefSymbol].options.default.id;
  const options = typeof idOrOptions === "string" || idOrOptions === SessionIdSymbol ? options_ : idOrOptions;
  const { default: defaultValues } = options ?? {};
  import_react5.default.useMemo(() => validateTableOptions(table), [table]);
  const tableName = table.sqliteDef.name;
  const store = (storeArg == null ? void 0 : storeArg.store) ?? // eslint-disable-next-line react-hooks/rules-of-hooks
  ((_a = import_react5.default.useContext(LiveStoreContext)) == null ? void 0 : _a.store) ?? shouldNeverHappen(`No store provided to useClientDocument`);
  const idStr = id === SessionIdSymbol ? store.clientSession.sessionId : id;
  const queryDef = import_react5.default.useMemo(() => queryDb(table.get(id, { default: defaultValues }), {
    deps: [idStr, table.sqliteDef.name, JSON.stringify(defaultValues)]
  }), [table, id, defaultValues, idStr]);
  const queryRef = useQueryRef(queryDef, {
    otelSpanName: `LiveStore:useClientDocument:${tableName}:${idStr}`,
    store: storeArg == null ? void 0 : storeArg.store
  });
  const setState = import_react5.default.useMemo(() => (newValueOrFn) => {
    const newValue = typeof newValueOrFn === "function" ? newValueOrFn(queryRef.valueRef.current) : newValueOrFn;
    if (queryRef.valueRef.current === newValue)
      return;
    store.commit(table.set(removeUndefinedValues(newValue), id));
  }, [id, queryRef.valueRef, store, table]);
  return [queryRef.valueRef.current, setState, idStr, queryRef.queryRcRef.value];
};
var validateTableOptions = (table) => {
  if (mod_exports.SQLite.tableIsClientDocumentTable(table) === false) {
    return shouldNeverHappen(`useClientDocument called on table "${table.sqliteDef.name}" which is not a client document table`);
  }
};
var removeUndefinedValues = (value) => {
  if (typeof value === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).filter(([_, v]) => v !== void 0));
  }
  return value;
};

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/useStore.js
var withReactApi = (store) => {
  store.useQuery = (queryDef) => useQuery(queryDef, { store });
  store.useClientDocument = (table, idOrOptions, options) => useClientDocument(table, idOrOptions, options, { store });
  return store;
};
var useStore = (options) => {
  if ((options == null ? void 0 : options.store) !== void 0) {
    return { store: withReactApi(options.store) };
  }
  const storeContext = import_react6.default.useContext(LiveStoreContext);
  if (storeContext === void 0) {
    throw new Error(`useStore can only be used inside StoreContext.Provider`);
  }
  if (storeContext.stage !== "running") {
    throw new Error(`useStore can only be used after the store is running`);
  }
  return { store: withReactApi(storeContext.store) };
};

// node_modules/.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/dist/LiveStoreProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var defaultRenderError = (error) => IS_REACT_NATIVE ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: Schema_exports.is(UnexpectedError)(error) ? error.toString() : objectToString(error) });
var defaultRenderShutdown = (cause) => {
  const reason = cause._tag === "LiveStore.StoreInterrupted" ? `interrupted due to: ${cause.reason}` : cause.reason === "devtools-import" ? "devtools import" : cause.reason === "devtools-reset" ? "devtools reset" : cause.reason === "adapter-reset" ? "adapter reset" : cause.reason === "manual" ? "manual shutdown" : "unknown reason";
  return IS_REACT_NATIVE ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: ["LiveStore Shutdown due to ", reason] });
};
var defaultRenderLoading = (status) => IS_REACT_NATIVE ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: ["LiveStore is loading (", status.stage, ")..."] });
var LiveStoreProvider = ({ renderLoading = defaultRenderLoading, renderError = defaultRenderError, renderShutdown = defaultRenderShutdown, otelOptions, children, schema, storeId = "default", boot, adapter, batchUpdates, disableDevtools, signal, confirmUnsavedChanges = true, syncPayload, debug }) => {
  const storeCtx = useCreateStore({
    storeId,
    schema,
    otelOptions,
    boot,
    adapter,
    batchUpdates,
    disableDevtools,
    signal,
    confirmUnsavedChanges,
    syncPayload,
    debug
  });
  if (storeCtx.stage === "error") {
    return renderError(storeCtx.error);
  }
  if (storeCtx.stage === "shutdown") {
    return renderShutdown(storeCtx.cause);
  }
  if (storeCtx.stage !== "running") {
    return renderLoading(storeCtx);
  }
  globalThis.__debugLiveStore ?? (globalThis.__debugLiveStore = {});
  if (Object.keys(globalThis.__debugLiveStore).length === 0) {
    globalThis.__debugLiveStore["_"] = storeCtx.store;
  }
  globalThis.__debugLiveStore[(debug == null ? void 0 : debug.instanceId) ?? storeId] = storeCtx.store;
  return (0, import_jsx_runtime.jsx)(LiveStoreContext.Provider, { value: storeCtx, children });
};
var useCreateStore = ({ schema, storeId, otelOptions, boot, adapter, batchUpdates, disableDevtools, signal, context: context2, params, confirmUnsavedChanges, syncPayload, debug }) => {
  const [_, rerender] = import_react7.default.useState(0);
  const ctxValueRef = import_react7.default.useRef({
    value: { stage: "loading" },
    componentScope: void 0,
    shutdownDeferred: void 0,
    previousShutdownDeferred: void 0,
    counter: 0
  });
  const debugInstanceId = debug == null ? void 0 : debug.instanceId;
  const inputPropsCacheRef = import_react7.default.useRef({
    schema,
    otelOptions,
    boot,
    adapter,
    batchUpdates,
    disableDevtools,
    signal,
    context: context2,
    params,
    confirmUnsavedChanges,
    syncPayload,
    debugInstanceId
  });
  const interrupt = (componentScope, shutdownDeferred, error) => Effect_exports.gen(function* () {
    yield* Scope_exports.close(componentScope, Exit_exports.fail(error));
    yield* Deferred_exports.fail(shutdownDeferred, error);
  }).pipe(Effect_exports.tapErrorCause((cause) => Effect_exports.logDebug("[@livestore/livestore/react] interupting", cause)), Effect_exports.runFork);
  const inputPropChanges = {
    schema: inputPropsCacheRef.current.schema !== schema,
    otelOptions: inputPropsCacheRef.current.otelOptions !== otelOptions,
    boot: inputPropsCacheRef.current.boot !== boot,
    adapter: inputPropsCacheRef.current.adapter !== adapter,
    batchUpdates: inputPropsCacheRef.current.batchUpdates !== batchUpdates,
    disableDevtools: inputPropsCacheRef.current.disableDevtools !== disableDevtools,
    signal: inputPropsCacheRef.current.signal !== signal,
    context: inputPropsCacheRef.current.context !== context2,
    params: inputPropsCacheRef.current.params !== params,
    confirmUnsavedChanges: inputPropsCacheRef.current.confirmUnsavedChanges !== confirmUnsavedChanges,
    syncPayload: inputPropsCacheRef.current.syncPayload !== syncPayload,
    debugInstanceId: inputPropsCacheRef.current.debugInstanceId !== debugInstanceId
  };
  if (inputPropChanges.schema || inputPropChanges.otelOptions || inputPropChanges.boot || inputPropChanges.adapter || inputPropChanges.batchUpdates || inputPropChanges.disableDevtools || inputPropChanges.signal || inputPropChanges.context || inputPropChanges.params || inputPropChanges.confirmUnsavedChanges || inputPropChanges.syncPayload) {
    inputPropsCacheRef.current = {
      schema,
      otelOptions,
      boot,
      adapter,
      batchUpdates,
      disableDevtools,
      signal,
      context: context2,
      params,
      confirmUnsavedChanges,
      syncPayload,
      debugInstanceId
    };
    if (ctxValueRef.current.componentScope !== void 0 && ctxValueRef.current.shutdownDeferred !== void 0) {
      const changedInputProps = Object.keys(inputPropChanges).filter((key) => inputPropChanges[key]);
      interrupt(ctxValueRef.current.componentScope, ctxValueRef.current.shutdownDeferred, new StoreInterrupted({ reason: `re-rendering due to changed input props: ${changedInputProps.join(", ")}` }));
      ctxValueRef.current.componentScope = void 0;
      ctxValueRef.current.shutdownDeferred = void 0;
    }
    ctxValueRef.current = {
      value: { stage: "loading" },
      componentScope: void 0,
      shutdownDeferred: void 0,
      previousShutdownDeferred: ctxValueRef.current.shutdownDeferred,
      counter: ctxValueRef.current.counter + 1
    };
  }
  import_react7.default.useEffect(() => {
    const counter = ctxValueRef.current.counter;
    const setContextValue = (value) => {
      if (ctxValueRef.current.counter !== counter)
        return;
      ctxValueRef.current.value = value;
      rerender((c) => c + 1);
    };
    signal == null ? void 0 : signal.addEventListener("abort", () => {
      if (ctxValueRef.current.componentScope !== void 0 && ctxValueRef.current.shutdownDeferred !== void 0 && ctxValueRef.current.counter === counter) {
        interrupt(ctxValueRef.current.componentScope, ctxValueRef.current.shutdownDeferred, new StoreInterrupted({ reason: "Aborted via provided AbortController" }));
        ctxValueRef.current.componentScope = void 0;
        ctxValueRef.current.shutdownDeferred = void 0;
      }
    });
    const cancel = Effect_exports.gen(function* () {
      if (ctxValueRef.current.previousShutdownDeferred) {
        yield* Deferred_exports.await(ctxValueRef.current.previousShutdownDeferred);
      }
      const componentScope = yield* Scope_exports.make().pipe(Effect_exports.acquireRelease(Scope_exports.close));
      const shutdownDeferred = yield* makeShutdownDeferred;
      ctxValueRef.current.componentScope = componentScope;
      ctxValueRef.current.shutdownDeferred = shutdownDeferred;
      yield* Effect_exports.gen(function* () {
        const store = yield* createStore({
          schema,
          storeId,
          boot,
          adapter,
          batchUpdates,
          disableDevtools,
          shutdownDeferred,
          context: context2,
          params,
          confirmUnsavedChanges,
          syncPayload,
          onBootStatus: (status) => {
            if (ctxValueRef.current.value.stage === "running" || ctxValueRef.current.value.stage === "error")
              return;
            setContextValue(status);
          },
          debug: { instanceId: debugInstanceId }
        }).pipe(Effect_exports.tapErrorCause((cause) => Deferred_exports.failCause(shutdownDeferred, cause)));
        setContextValue({ stage: "running", store });
      }).pipe(Scope_exports.extend(componentScope), Effect_exports.forkIn(componentScope));
      const shutdownContext = (cause) => Effect_exports.sync(() => setContextValue({ stage: "shutdown", cause }));
      yield* Deferred_exports.await(shutdownDeferred).pipe(Effect_exports.tapErrorCause((cause) => Effect_exports.logDebug("[@livestore/livestore/react] shutdown", Cause_exports.pretty(cause))), Effect_exports.catchTag("LiveStore.IntentionalShutdownCause", (cause) => shutdownContext(cause)), Effect_exports.catchTag("LiveStore.StoreInterrupted", (cause) => shutdownContext(cause)), Effect_exports.tapError((error) => Effect_exports.sync(() => setContextValue({ stage: "error", error }))), Effect_exports.tapDefect((defect) => Effect_exports.sync(() => setContextValue({ stage: "error", error: defect }))), Effect_exports.exit);
    }).pipe(Effect_exports.scoped, Effect_exports.withSpan("@livestore/react:useCreateStore"), LS_DEV ? TaskTracing_exports.withAsyncTaggingTracing((name) => console.createTask(name)) : identity, provideOtel({ parentSpanContext: otelOptions == null ? void 0 : otelOptions.rootSpanContext, otelTracer: otelOptions == null ? void 0 : otelOptions.tracer }), Effect_exports.tapCauseLogPretty, Effect_exports.annotateLogs({ thread: "window" }), Effect_exports.provide(Logger_exports.prettyWithThread("window")), Logger_exports.withMinimumLogLevel(LogLevel_exports.Debug), Effect_exports.runCallback);
    return () => {
      cancel();
      if (ctxValueRef.current.componentScope !== void 0 && ctxValueRef.current.shutdownDeferred !== void 0) {
        interrupt(ctxValueRef.current.componentScope, ctxValueRef.current.shutdownDeferred, new StoreInterrupted({ reason: "unmounting component" }));
        ctxValueRef.current.componentScope = void 0;
        ctxValueRef.current.shutdownDeferred = void 0;
      }
    };
  }, [
    schema,
    otelOptions,
    boot,
    adapter,
    batchUpdates,
    disableDevtools,
    signal,
    storeId,
    context2,
    params,
    confirmUnsavedChanges,
    syncPayload,
    debugInstanceId
  ]);
  return ctxValueRef.current.value;
};
export {
  LiveStoreContext,
  LiveStoreProvider,
  useClientDocument,
  useQuery,
  useQueryRef,
  useStackInfo,
  useStore,
  withReactApi
};
//# sourceMappingURL=@livestore_react.js.map

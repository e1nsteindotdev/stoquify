import {
  BoundArray,
  BoundMap,
  BoundSet,
  Cause_exports,
  Context_exports,
  Deferred_exports,
  Effect_exports,
  Exit_exports,
  Fiber_exports,
  Inspectable_exports,
  IntentionalShutdownCause,
  LS_DEV,
  Layer_exports,
  LiveStoreEvent_exports,
  LogLevel_exports,
  Logger_exports,
  Option_exports,
  Predicate_exports,
  QueryBuilderAstSymbol,
  Queue_exports,
  Runtime_exports,
  Schema_exports,
  Scope_exports,
  SessionIdSymbol,
  SpanStatusCode,
  SqliteError,
  Stream_exports,
  TaskTracing_exports,
  Tracer_exports,
  TreeFormatter,
  UnexpectedError,
  assertNever,
  context,
  deepEqual,
  getDurationMsFromSpan,
  getEventDef,
  getExecStatementsFromMaterializer,
  getResultSchema,
  getStartTimeHighResFromSpan,
  hashMaterializerResults,
  identity,
  isDevEnv,
  isNotNil,
  isQueryBuilder,
  liveStoreVersion,
  makeClientSessionSyncProcessor,
  mod_exports3 as mod_exports,
  mod_exports4 as mod_exports2,
  nanoid,
  notYetImplemented,
  prepareBindValues,
  provideOtel,
  replaceSessionIdSymbol,
  shouldNeverHappen,
  sql,
  sqlite_db_helper_exports,
  system_tables_exports,
  throttle,
  trace
} from "./chunk-J7UPD3II.js";
import {
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/reactive.js
var NOT_REFRESHED_YET = Symbol.for("NOT_REFRESHED_YET");
var isThunk = (obj) => {
  return typeof obj === "object" && obj !== null && "_tag" in obj && obj._tag === "thunk";
};
var unknownRefreshReason = () => {
  return { _tag: "unknown" };
};
var encodedOptionSome = (value) => ({ _tag: "Some", value });
var encodedOptionNone = () => ({ _tag: "None" });
var globalGraphIdCounter = 0;
var uniqueGraphId = () => `graph-${++globalGraphIdCounter}`;
var ReactiveGraph = class {
  constructor() {
    __publicField(this, "id", uniqueGraphId());
    __publicField(this, "atoms", /* @__PURE__ */ new Set());
    __publicField(this, "effects", /* @__PURE__ */ new Set());
    __publicField(this, "context");
    __publicField(this, "debugRefreshInfos", new BoundArray(200));
    __publicField(this, "currentDebugRefresh");
    __publicField(this, "deferredEffects", /* @__PURE__ */ new Map());
    __publicField(this, "refreshCallbacks", /* @__PURE__ */ new Set());
    __publicField(this, "nodeIdCounter", 0);
    __publicField(this, "uniqueNodeId", () => `node-${++this.nodeIdCounter}`);
    __publicField(this, "refreshInfoIdCounter", 0);
    __publicField(this, "uniqueRefreshInfoId", () => `refresh-info-${++this.refreshInfoIdCounter}`);
    __publicField(this, "runEffects", (effectsToRefresh, options) => {
      var _a2;
      const effectsWrapper = ((_a2 = this.context) == null ? void 0 : _a2.effectsWrapper) ?? ((runEffects) => runEffects());
      effectsWrapper(() => {
        this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() };
        for (const effect of effectsToRefresh) {
          effect.doEffect(options == null ? void 0 : options.otelContext, options.debugRefreshReason);
        }
        const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms;
        const durationMs = performance.now() - this.currentDebugRefresh.startMs;
        this.currentDebugRefresh = void 0;
        const refreshDebugInfo = {
          id: this.uniqueRefreshInfoId(),
          reason: options.debugRefreshReason,
          skippedRefresh: false,
          refreshedAtoms,
          durationMs,
          completedTimestamp: Date.now(),
          graphSnapshot: this.getSnapshot({ includeResults: false })
        };
        this.debugRefreshInfos.push(refreshDebugInfo);
        this.runRefreshCallbacks();
      });
    });
    __publicField(this, "runDeferredEffects", (options) => {
      for (const [effect, debugRefreshReasons] of this.deferredEffects) {
        this.runEffects(/* @__PURE__ */ new Set([effect]), {
          debugRefreshReason: {
            _tag: "runDeferredEffects",
            originalRefreshReasons: Array.from(debugRefreshReasons),
            manualRefreshReason: options == null ? void 0 : options.debugRefreshReason
          },
          otelContext: options == null ? void 0 : options.otelContext
        });
      }
    });
    __publicField(this, "runRefreshCallbacks", () => {
      for (const cb of this.refreshCallbacks) {
        cb();
      }
    });
    // NOTE This function is performance-optimized (i.e. not using `Array.from`)
    __publicField(this, "getSnapshot", (opts) => {
      const { includeResults = false } = opts ?? {};
      const atoms = [];
      for (const atom of this.atoms) {
        atoms.push(serializeAtom(atom, includeResults));
      }
      const effects = [];
      for (const effect of this.effects) {
        effects.push(serializeEffect(effect));
      }
      const deferredEffects = [];
      for (const [effect] of this.deferredEffects) {
        deferredEffects.push(effect.id);
      }
      return { atoms, effects, deferredEffects };
    });
    __publicField(this, "subscribeToRefresh", (cb) => {
      this.refreshCallbacks.add(cb);
      return () => {
        this.refreshCallbacks.delete(cb);
      };
    });
  }
  makeRef(val, options) {
    const ref = {
      _tag: "ref",
      id: this.uniqueNodeId(),
      isDirty: false,
      isDestroyed: false,
      previousResult: val,
      computeResult: () => ref.previousResult,
      sub: /* @__PURE__ */ new Set(),
      super: /* @__PURE__ */ new Set(),
      label: options == null ? void 0 : options.label,
      meta: options == null ? void 0 : options.meta,
      equal: (options == null ? void 0 : options.equal) ?? deepEqual,
      refreshes: 0
    };
    this.atoms.add(ref);
    return ref;
  }
  makeThunk(getResult, options) {
    const thunk = {
      _tag: "thunk",
      id: this.uniqueNodeId(),
      previousResult: NOT_REFRESHED_YET,
      isDirty: true,
      isDestroyed: false,
      computeResult: (otelContext, debugRefreshReason) => {
        if (thunk.isDirty) {
          const neededCurrentRefresh = this.currentDebugRefresh === void 0;
          if (neededCurrentRefresh) {
            this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() };
          }
          thunk.sub = /* @__PURE__ */ new Set();
          const getAtom = (atom, otelContext2) => {
            this.addEdge(thunk, atom);
            return compute(atom, otelContext2, debugRefreshReason);
          };
          let debugInfo = void 0;
          const setDebugInfo = (debugInfo_) => {
            debugInfo = debugInfo_;
          };
          const result = getResult(getAtom, setDebugInfo, this.context ?? throwContextNotSetError(this), otelContext, debugRefreshReason);
          const resultChanged = thunk.equal(thunk.previousResult, result) === false;
          const debugInfoForAtom = {
            atom: serializeAtom(thunk, false),
            resultChanged,
            debugInfo: debugInfo ?? unknownRefreshReason()
          };
          this.currentDebugRefresh.refreshedAtoms.push(debugInfoForAtom);
          thunk.isDirty = false;
          thunk.previousResult = result;
          thunk.recomputations++;
          if (neededCurrentRefresh) {
            const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms;
            const durationMs = performance.now() - this.currentDebugRefresh.startMs;
            this.currentDebugRefresh = void 0;
            this.debugRefreshInfos.push({
              id: this.uniqueRefreshInfoId(),
              reason: debugRefreshReason ?? { _tag: "makeThunk", label: options == null ? void 0 : options.label },
              skippedRefresh: false,
              refreshedAtoms,
              durationMs,
              completedTimestamp: Date.now(),
              graphSnapshot: this.getSnapshot({ includeResults: false })
            });
          }
          return result;
        } else {
          return thunk.previousResult;
        }
      },
      sub: /* @__PURE__ */ new Set(),
      super: /* @__PURE__ */ new Set(),
      recomputations: 0,
      label: options == null ? void 0 : options.label,
      meta: options == null ? void 0 : options.meta,
      equal: (options == null ? void 0 : options.equal) ?? deepEqual,
      __getResult: getResult
    };
    this.atoms.add(thunk);
    return thunk;
  }
  destroyNode(node) {
    if (node._tag === "ref" || node._tag === "thunk") {
      for (const superComp of node.super) {
        this.destroyNode(superComp);
      }
    }
    if (node._tag !== "ref") {
      for (const subComp of node.sub) {
        this.removeEdge(node, subComp);
      }
    }
    if (node._tag === "effect") {
      this.deferredEffects.delete(node);
      this.effects.delete(node);
    } else {
      this.atoms.delete(node);
    }
    node.isDestroyed = true;
  }
  destroy() {
    for (const node of this.atoms) {
      this.destroyNode(node);
    }
  }
  makeEffect(doEffect, options) {
    const effect = {
      _tag: "effect",
      id: this.uniqueNodeId(),
      isDestroyed: false,
      doEffect: (otelContext, debugRefreshReason) => {
        effect.invocations++;
        effect.sub = /* @__PURE__ */ new Set();
        const getAtom = (atom, otelContext2, debugRefreshReason2) => {
          this.addEdge(effect, atom);
          return compute(atom, otelContext2, debugRefreshReason2);
        };
        doEffect(getAtom, otelContext, debugRefreshReason);
      },
      sub: /* @__PURE__ */ new Set(),
      label: options == null ? void 0 : options.label,
      invocations: 0
    };
    this.effects.add(effect);
    return effect;
  }
  setRef(ref, val, options) {
    this.setRefs([[ref, val]], options);
  }
  setRefs(refs, options) {
    const effectsToRefresh = /* @__PURE__ */ new Set();
    for (const [ref, val] of refs) {
      ref.previousResult = val;
      ref.refreshes++;
      markSuperCompDirtyRec(ref, effectsToRefresh);
    }
    if (options == null ? void 0 : options.skipRefresh) {
      for (const effect of effectsToRefresh) {
        if (this.deferredEffects.has(effect) === false) {
          this.deferredEffects.set(effect, /* @__PURE__ */ new Set());
        }
        if ((options == null ? void 0 : options.debugRefreshReason) !== void 0) {
          this.deferredEffects.get(effect).add(options.debugRefreshReason);
        }
      }
    } else {
      this.runEffects(effectsToRefresh, {
        debugRefreshReason: (options == null ? void 0 : options.debugRefreshReason) ?? unknownRefreshReason(),
        otelContext: options == null ? void 0 : options.otelContext
      });
    }
  }
  addEdge(superComp, subComp) {
    superComp.sub.add(subComp);
    subComp.super.add(superComp);
    if (this.currentDebugRefresh === void 0) {
      this.runRefreshCallbacks();
    }
  }
  removeEdge(superComp, subComp) {
    superComp.sub.delete(subComp);
    const effectsToRefresh = /* @__PURE__ */ new Set();
    markSuperCompDirtyRec(subComp, effectsToRefresh);
    for (const effect of effectsToRefresh) {
      this.deferredEffects.set(effect, /* @__PURE__ */ new Set());
    }
    subComp.super.delete(superComp);
    if (this.currentDebugRefresh === void 0) {
      this.runRefreshCallbacks();
    }
  }
};
var compute = (atom, otelContext, debugRefreshReason) => {
  if (atom.isDestroyed) {
    shouldNeverHappen(`LiveStore Error: Attempted to compute destroyed ${atom._tag} (${atom.id}): ${atom.label ?? ""}`);
  }
  if (atom.isDirty) {
    const result = atom.computeResult(otelContext, debugRefreshReason);
    atom.isDirty = false;
    atom.previousResult = result;
    return result;
  } else {
    return atom.previousResult;
  }
};
var markSuperCompDirtyRec = (atom, effectsToRefresh) => {
  for (const superComp of atom.super) {
    if (superComp._tag === "thunk") {
      superComp.isDirty = true;
      markSuperCompDirtyRec(superComp, effectsToRefresh);
    } else {
      effectsToRefresh.add(superComp);
    }
  }
};
var throwContextNotSetError = (graph) => {
  throw new Error(`LiveStore Error: \`context\` not set on ReactiveGraph (${graph.id})`);
};
var serializeAtom = (atom, includeResult) => {
  const sub = [];
  for (const a of atom.sub) {
    sub.push(a.id);
  }
  const super_ = [];
  for (const a of atom.super) {
    super_.push(a.id);
  }
  const previousResult = includeResult ? encodedOptionSome(atom.previousResult === NOT_REFRESHED_YET ? '"SYMBOL_NOT_REFRESHED_YET"' : JSON.stringify(atom.previousResult)) : encodedOptionNone();
  if (atom._tag === "ref") {
    return {
      _tag: atom._tag,
      id: atom.id,
      label: atom.label,
      meta: atom.meta,
      isDirty: atom.isDirty,
      sub,
      super: super_,
      isDestroyed: atom.isDestroyed,
      refreshes: atom.refreshes,
      previousResult
    };
  }
  return {
    _tag: "thunk",
    id: atom.id,
    label: atom.label,
    meta: atom.meta,
    isDirty: atom.isDirty,
    sub,
    super: super_,
    isDestroyed: atom.isDestroyed,
    recomputations: atom.recomputations,
    previousResult
  };
};
var serializeEffect = (effect) => {
  const sub = [];
  for (const a of effect.sub) {
    sub.push(a.id);
  }
  return {
    _tag: effect._tag,
    id: effect.id,
    label: effect.label,
    sub,
    invocations: effect.invocations,
    isDestroyed: effect.isDestroyed
  };
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/live-queries/base-class.js
var makeReactivityGraph = () => new ReactiveGraph();
var queryIdCounter = 0;
var TypeId = Symbol.for("LiveQuery");
var depsToString = (deps) => {
  if (typeof deps === "string" || typeof deps === "number") {
    return deps.toString();
  }
  return deps.filter(isNotNil).join(",");
};
var _a;
_a = TypeId;
var LiveStoreQueryBase = class {
  constructor() {
    __publicField(this, "__result!");
    __publicField(this, "id", queryIdCounter++);
    __publicField(this, _a, TypeId);
    __publicField(this, "activeSubscriptions", /* @__PURE__ */ new Set());
    __publicField(this, "executionTimes", []);
    // TODO double check if this is needed
    __publicField(this, "isDestroyed", false);
    __publicField(this, "run", (args) => {
      return this.results$.computeResult(args.otelContext, args.debugRefreshReason);
    });
    __publicField(this, "dependencyQueriesRef", /* @__PURE__ */ new Set());
  }
  get runs() {
    if (this.results$._tag === "thunk") {
      return this.results$.recomputations;
    }
    return 0;
  }
};
var makeGetAtomResult = (get, ctx, otelContext, dependencyQueriesRef) => {
  const getAtom = (atom, _otelContext, debugRefreshReason) => {
    if (atom._tag === "thunk" || atom._tag === "ref")
      return get(atom, otelContext, debugRefreshReason);
    if (atom._tag === "def" || atom._tag === "signal-def") {
      const query = atom.make(ctx);
      dependencyQueriesRef.add(query);
      return getAtom(query.value, _otelContext, debugRefreshReason);
    }
    if (atom._tag === "signal" && Predicate_exports.hasProperty(atom, "ref")) {
      return get(atom.ref, otelContext, debugRefreshReason);
    }
    return get(atom.results$, otelContext, debugRefreshReason);
  };
  return getAtom;
};
var withRCMap = (id, make) => {
  return (ctx, otelContext) => {
    let item = ctx.defRcMap.get(id);
    if (item) {
      item.rc++;
      return item;
    }
    const query$ = make(ctx, otelContext);
    item = {
      rc: 1,
      value: query$,
      deref: () => {
        item.rc--;
        if (item.rc === 0) {
          item.value.destroy();
          ctx.defRcMap.delete(id);
        }
      }
    };
    ctx.defRcMap.set(id, item);
    return item;
  };
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/live-queries/client-document-get-query.js
var rowQueryLabel = (table, id) => `${table.sqliteDef.name}.get:${id === void 0 ? table.default.id : id === SessionIdSymbol ? "sessionId" : id}`;
var makeExecBeforeFirstRun = ({ id, explicitDefaultValues, table, otelContext: otelContext_ }) => ({ store }) => {
  if (mod_exports.SQLite.tableIsClientDocumentTable(table) === false) {
    return shouldNeverHappen(`Cannot insert row for table "${table.sqliteDef.name}" which does not have 'deriveEvents: true' set`);
  }
  const otelContext = otelContext_ ?? store.otel.queriesSpanContext;
  const idVal = id === SessionIdSymbol ? store.sessionId : id;
  const rowExists = store.sqliteDbWrapper.cachedSelect(`SELECT 1 FROM '${table.sqliteDef.name}' WHERE id = ?`, [idVal], { otelContext }).length === 1;
  if (rowExists)
    return;
  store.commit({ otelContext, skipRefresh: true, label: `${table.sqliteDef.name}.set:${idVal}` }, table.set(explicitDefaultValues, idVal));
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/QueryCache.js
var Symbols;
/* @__PURE__ */ (function(Symbols2) {
})(Symbols || (Symbols = {}));
var ignore = ["begin", "rollback", "commit", "savepoint", "release"];
var cacheSize = 200;
var _entries, _dependencies, _dependencyTrackerEvicted;
var QueryCache = class {
  constructor() {
    __privateAdd(this, _entries, new BoundMap(cacheSize));
    __privateAdd(this, _dependencies, /* @__PURE__ */ new Map());
    __publicField(this, "getKey", (sql2, bindValues) => {
      if (bindValues == null) {
        return sql2;
      }
      if (Array.isArray(bindValues)) {
        return sql2 + "\n" + bindValues.join("\n");
      }
      return sql2 + "\n" + Object.values(bindValues).join("\n");
    });
    __publicField(this, "get", (key) => {
      return __privateGet(this, _entries).get(key);
    });
    __publicField(this, "set", (queriedTables, key, results) => {
      __privateGet(this, _entries).set(key, results);
      for (const table of queriedTables) {
        let keys = __privateGet(this, _dependencies).get(table);
        if (keys == null) {
          keys = new BoundSet(cacheSize);
          keys.onEvict = __privateGet(this, _dependencyTrackerEvicted);
          __privateGet(this, _dependencies).set(table, keys);
        }
        keys.add(key);
      }
    });
    __privateAdd(this, _dependencyTrackerEvicted, (key) => {
      __privateGet(this, _entries).delete(key);
    });
    __publicField(this, "ignoreQuery", (query) => {
      return ignore.some((prefix) => query.startsWith(prefix));
    });
    // The next simplest step is to create a specific implementation for invalidating
    // the expensive track list queries only when constraints data in a write overlaps with read constraints.
    //
    // As well as either:
    // a. removeing the big view (since we'll have our cache)
    // b. incrementally updating the view on insert by the EventImporter
    //
    // We'll not try to tackle any generalized approach until we have a proof of concept working.
    __publicField(this, "invalidate", (queriedTables) => {
      for (const table of queriedTables) {
        const keys = __privateGet(this, _dependencies).get(table);
        if (keys == null) {
          continue;
        }
        for (const k of keys) {
          __privateGet(this, _entries).delete(k);
        }
      }
    });
  }
};
_entries = new WeakMap();
_dependencies = new WeakMap();
_dependencyTrackerEvicted = new WeakMap();

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/SqliteDbWrapper.js
var emptyDebugInfo = () => ({
  slowQueries: new BoundArray(200),
  queryFrameDuration: 0,
  queryFrameCount: 0,
  events: new BoundArray(1e3)
});
var SqliteDbWrapper = class {
  constructor({ db, otel }) {
    __publicField(this, "_tag", "SqliteDb");
    // TODO: how many unique active statements are expected?
    __publicField(this, "cachedStmts", new BoundMap(200));
    __publicField(this, "tablesUsedCache", new BoundMap(200));
    __publicField(this, "resultCache", new QueryCache());
    __publicField(this, "db");
    __publicField(this, "otelTracer");
    __publicField(this, "otelRootSpanContext");
    __publicField(this, "tablesUsedStmt");
    __publicField(this, "debugInfo", emptyDebugInfo());
    __publicField(this, "metadata");
    __publicField(this, "execute", sqlite_db_helper_exports.makeExecute((queryStr, bindValues) => this.cachedExecute(queryStr, bindValues)));
    __publicField(this, "select", sqlite_db_helper_exports.makeSelect((queryStr, bindValues) => this.cachedSelect(queryStr, bindValues)));
    this.db = db;
    this.otelTracer = otel.tracer;
    this.otelRootSpanContext = otel.rootSpanContext;
    this.tablesUsedStmt = db.prepare(`SELECT tbl_name FROM tables_used(?) AS u JOIN sqlite_master ON sqlite_master.name = u.name WHERE u.schema = 'main';`);
    this.cachedStmts.onEvict = (_queryStr, stmt) => stmt.finalize();
    configureSQLite(this);
  }
  prepare(queryStr) {
    return this.db.prepare(queryStr);
  }
  import(data) {
    return this.db.import(data);
  }
  close() {
    this.db.close();
  }
  destroy() {
    this.db.destroy();
  }
  session() {
    return this.db.session();
  }
  makeChangeset(data) {
    return this.db.makeChangeset(data);
  }
  txn(callback) {
    this.execute(sql`begin transaction;`);
    let errored = false;
    let result;
    try {
      result = callback();
    } catch (e) {
      errored = true;
      this.execute(sql`rollback;`);
      throw e;
    }
    if (!errored) {
      this.execute(sql`commit;`);
    }
    return result;
  }
  withChangeset(callback) {
    const session = this.db.session();
    const result = callback();
    const changeset = session.changeset();
    session.finish();
    return {
      result,
      changeset: changeset ? { _tag: "sessionChangeset", data: changeset, debug: null } : { _tag: "no-op" }
    };
  }
  rollback(changeset) {
    const invertedChangeset = this.db.makeChangeset(changeset).invert();
    invertedChangeset.apply();
  }
  getTablesUsed(query) {
    const tableNameFromPlainDeleteQuery = tryGetTableNameFromPlainDeleteQuery(query);
    if (tableNameFromPlainDeleteQuery !== void 0) {
      return /* @__PURE__ */ new Set([tableNameFromPlainDeleteQuery]);
    }
    const cached = this.tablesUsedCache.get(query);
    if (cached) {
      return cached;
    }
    const stmt = this.tablesUsedStmt;
    const tablesUsed = /* @__PURE__ */ new Set();
    try {
      const results = stmt.select([query]);
      for (const row of results) {
        tablesUsed.add(row.tbl_name);
      }
    } catch (e) {
      console.error("Error getting tables used", e, "for query", query);
      return /* @__PURE__ */ new Set();
    }
    this.tablesUsedCache.set(query, tablesUsed);
    return tablesUsed;
  }
  cachedExecute(queryStr, bindValues, options) {
    return this.otelTracer.startActiveSpan(
      "livestore.in-memory-db:execute",
      // TODO truncate query string
      { attributes: { "sql.query": queryStr } },
      (options == null ? void 0 : options.otelContext) ?? this.otelRootSpanContext,
      (span) => {
        try {
          let stmt = this.cachedStmts.get(queryStr);
          if (stmt === void 0) {
            stmt = this.db.prepare(queryStr);
            this.cachedStmts.set(queryStr, stmt);
          }
          stmt.execute(bindValues);
          if ((options == null ? void 0 : options.hasNoEffects) !== true && !this.resultCache.ignoreQuery(queryStr)) {
            this.resultCache.invalidate((options == null ? void 0 : options.writeTables) ?? this.getTablesUsed(queryStr));
          }
          span.end();
          const durationMs = getDurationMsFromSpan(span);
          this.debugInfo.queryFrameDuration += durationMs;
          this.debugInfo.queryFrameCount++;
          if (durationMs > 5 && isDevEnv()) {
            this.debugInfo.slowQueries.push({
              queryStr,
              bindValues,
              durationMs,
              rowsCount: void 0,
              queriedTables: /* @__PURE__ */ new Set(),
              startTimePerfNow: getStartTimeHighResFromSpan(span)
            });
          }
          return { durationMs };
        } catch (cause) {
          span.recordException(cause);
          span.end();
          if (LS_DEV) {
            debugger;
          }
          throw new SqliteError({ cause, query: { bindValues: bindValues ?? {}, sql: queryStr } });
        }
      }
    );
  }
  cachedSelect(queryStr, bindValues, options) {
    const { queriedTables, skipCache = false, otelContext } = options ?? {};
    return this.otelTracer.startActiveSpan("sql-in-memory-select", {}, otelContext ?? this.otelRootSpanContext, (span) => {
      try {
        span.setAttribute("sql.query", queryStr);
        const key = this.resultCache.getKey(queryStr, bindValues);
        const cachedResult = this.resultCache.get(key);
        if (skipCache === false && cachedResult !== void 0) {
          span.setAttribute("sql.rowsCount", cachedResult.length);
          span.setAttribute("sql.cached", true);
          span.end();
          return cachedResult;
        }
        let stmt = this.cachedStmts.get(queryStr);
        if (stmt === void 0) {
          stmt = this.db.prepare(queryStr);
          this.cachedStmts.set(queryStr, stmt);
        }
        const result = stmt.select(bindValues);
        span.setAttribute("sql.rowsCount", result.length);
        span.setAttribute("sql.cached", false);
        const queriedTables_ = queriedTables ?? this.getTablesUsed(queryStr);
        this.resultCache.set(queriedTables_, key, result);
        span.end();
        const durationMs = getDurationMsFromSpan(span);
        this.debugInfo.queryFrameDuration += durationMs;
        this.debugInfo.queryFrameCount++;
        if (durationMs > 5 && isDevEnv()) {
          this.debugInfo.slowQueries.push({
            queryStr,
            bindValues,
            durationMs,
            rowsCount: result.length,
            queriedTables: queriedTables_,
            startTimePerfNow: getStartTimeHighResFromSpan(span)
          });
        }
        return result;
      } finally {
        span.end();
      }
    });
  }
  export() {
    for (const key of this.cachedStmts.keys()) {
      this.cachedStmts.delete(key);
    }
    return this.db.export();
  }
};
var configureSQLite = (db) => {
  db.execute(
    // TODO: revisit these tuning parameters for max performance
    sql`
      PRAGMA page_size=32768;
      PRAGMA cache_size=10000;
      PRAGMA synchronous='OFF';
      PRAGMA temp_store='MEMORY';
      PRAGMA foreign_keys='ON'; -- we want foreign key constraints to be enforced
    `
  );
};
var tryGetTableNameFromPlainDeleteQuery = (query) => {
  const [_, tableName] = query.trim().match(/^delete\s+from\s+(\w+)$/i) ?? [];
  return tableName;
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/utils/data-structures.js
var ReferenceCountedSet = class {
  constructor() {
    __publicField(this, "map");
    __publicField(this, "add", (key) => {
      const count = this.map.get(key) ?? 0;
      this.map.set(key, count + 1);
    });
    __publicField(this, "remove", (key) => {
      const count = this.map.get(key) ?? 0;
      if (count === 1) {
        this.map.delete(key);
      } else {
        this.map.set(key, count - 1);
      }
    });
    __publicField(this, "has", (key) => {
      return this.map.has(key);
    });
    this.map = /* @__PURE__ */ new Map();
  }
  get size() {
    return this.map.size;
  }
  *[Symbol.iterator]() {
    for (const key of this.map.keys()) {
      yield key;
    }
  }
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/utils/dev.js
var downloadBlob = (data, fileName, mimeType = "application/octet-stream") => {
  const blob = data instanceof Blob ? data : new Blob([data], { type: mimeType });
  const url = window.URL.createObjectURL(blob);
  downloadURL(url, fileName);
  setTimeout(() => window.URL.revokeObjectURL(url), 1e3);
};
var downloadURL = (data, fileName) => {
  const a = document.createElement("a");
  a.href = data;
  a.download = fileName;
  document.body.append(a);
  a.style.display = "none";
  a.click();
  a.remove();
};
var exposeDebugUtils = () => {
  if (isDevEnv()) {
    globalThis.__debugLiveStoreUtils = {
      downloadBlob,
      runSync: (effect) => Effect_exports.runSync(effect),
      runFork: (effect) => Effect_exports.runFork(effect)
    };
  }
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/store/store.js
if (isDevEnv()) {
  exposeDebugUtils();
}
var Store = class extends Inspectable_exports.Class {
  // #region constructor
  constructor({ clientSession, schema, otelOptions, context: context2, batchUpdates, storeId, effectContext, params, confirmUnsavedChanges, __runningInDevtools }) {
    super();
    __publicField(this, "storeId");
    __publicField(this, "reactivityGraph");
    __publicField(this, "sqliteDbWrapper");
    __publicField(this, "clientSession");
    __publicField(this, "schema");
    __publicField(this, "context");
    __publicField(this, "otel");
    /**
     * Note we're using `Ref<null>` here as we don't care about the value but only about *that* something has changed.
     * This only works in combination with `equal: () => false` which will always trigger a refresh.
     */
    __publicField(this, "tableRefs");
    __publicField(this, "effectContext");
    /** RC-based set to see which queries are currently subscribed to */
    __publicField(this, "activeQueries");
    // NOTE this is currently exposed for the Devtools databrowser to commit events
    __publicField(this, "__eventSchema");
    __publicField(this, "syncProcessor");
    __publicField(this, "boot");
    /**
     * Subscribe to the results of a query
     * Returns a function to cancel the subscription.
     *
     * @example
     * ```ts
     * const unsubscribe = store.subscribe(query$, { onUpdate: (result) => console.log(result) })
     * ```
     */
    __publicField(this, "subscribe", (query, options) => this.otel.tracer.startActiveSpan(`LiveStore.subscribe`, { attributes: { label: options == null ? void 0 : options.label, queryLabel: query.label } }, (options == null ? void 0 : options.otelContext) ?? this.otel.queriesSpanContext, (span) => {
      var _a2;
      const otelContext = trace.setSpan(context.active(), span);
      const queryRcRef = query._tag === "def" || query._tag === "signal-def" ? query.make(this.reactivityGraph.context) : {
        value: query,
        deref: () => {
        }
      };
      const query$ = queryRcRef.value;
      const label = `subscribe:${options == null ? void 0 : options.label}`;
      const effect = this.reactivityGraph.makeEffect((get, _otelContext, debugRefreshReason) => options.onUpdate(get(query$.results$, otelContext, debugRefreshReason)), { label });
      if (options == null ? void 0 : options.stackInfo) {
        query$.activeSubscriptions.add(options.stackInfo);
      }
      (_a2 = options == null ? void 0 : options.onSubscribe) == null ? void 0 : _a2.call(options, query$);
      this.activeQueries.add(query$);
      if ((options == null ? void 0 : options.skipInitialRun) !== true && !query$.isDestroyed) {
        effect.doEffect(otelContext, { _tag: "subscribe.initial", label: `subscribe-initial-run:${options == null ? void 0 : options.label}` });
      }
      const unsubscribe = () => {
        var _a3;
        try {
          this.reactivityGraph.destroyNode(effect);
          this.activeQueries.remove(query$);
          if (options == null ? void 0 : options.stackInfo) {
            query$.activeSubscriptions.delete(options.stackInfo);
          }
          queryRcRef.deref();
          (_a3 = options == null ? void 0 : options.onUnsubsubscribe) == null ? void 0 : _a3.call(options);
        } finally {
          span.end();
        }
      };
      return unsubscribe;
    }));
    __publicField(this, "subscribeStream", (query$, options) => Stream_exports.asyncPush((emit) => Effect_exports.gen(this, function* () {
      const otelSpan = yield* Tracer_exports.currentOtelSpan.pipe(Effect_exports.catchTag("NoSuchElementException", () => Effect_exports.succeed(void 0)));
      const otelContext = otelSpan ? trace.setSpan(context.active(), otelSpan) : context.active();
      yield* Effect_exports.acquireRelease(Effect_exports.sync(() => this.subscribe(query$, {
        onUpdate: (result) => emit.single(result),
        otelContext,
        label: options == null ? void 0 : options.label
      })), (unsub) => Effect_exports.sync(() => unsub()));
    })));
    /**
     * Synchronously queries the database without creating a LiveQuery.
     * This is useful for queries that don't need to be reactive.
     *
     * Example: Query builder
     * ```ts
     * const completedTodos = store.query(tables.todo.where({ complete: true }))
     * ```
     *
     * Example: Raw SQL query
     * ```ts
     * const completedTodos = store.query({ query: 'SELECT * FROM todo WHERE complete = 1', bindValues: {} })
     * ```
     */
    __publicField(this, "query", (query, options) => {
      if (typeof query === "object" && "query" in query && "bindValues" in query) {
        return this.sqliteDbWrapper.cachedSelect(query.query, prepareBindValues(query.bindValues, query.query), {
          otelContext: options == null ? void 0 : options.otelContext
        });
      } else if (isQueryBuilder(query)) {
        const ast = query[QueryBuilderAstSymbol];
        if (ast._tag === "RowQuery") {
          makeExecBeforeFirstRun({
            table: ast.tableDef,
            id: ast.id,
            explicitDefaultValues: ast.explicitDefaultValues,
            otelContext: options == null ? void 0 : options.otelContext
          })(this.reactivityGraph.context);
        }
        const sqlRes = query.asSql();
        const schema = getResultSchema(query);
        const rawRes = this.sqliteDbWrapper.cachedSelect(sqlRes.query, sqlRes.bindValues, {
          otelContext: options == null ? void 0 : options.otelContext,
          queriedTables: /* @__PURE__ */ new Set([query[QueryBuilderAstSymbol].tableDef.sqliteDef.name])
        });
        return Schema_exports.decodeSync(schema)(rawRes);
      } else if (query._tag === "def") {
        const query$ = query.make(this.reactivityGraph.context);
        const result = this.query(query$.value, options);
        query$.deref();
        return result;
      } else if (query._tag === "signal-def") {
        const signal$ = query.make(this.reactivityGraph.context);
        return signal$.value.get();
      } else {
        return query.run({ otelContext: options == null ? void 0 : options.otelContext, debugRefreshReason: options == null ? void 0 : options.debugRefreshReason });
      }
    });
    /**
     * Set the value of a signal
     *
     * @example
     * ```ts
     * const count$ = signal(0, { label: 'count$' })
     * store.setSignal(count$, 2)
     * ```
     *
     * @example
     * ```ts
     * const count$ = signal(0, { label: 'count$' })
     * store.setSignal(count$, (prev) => prev + 1)
     * ```
     */
    __publicField(this, "setSignal", (signalDef, value) => {
      const signalRef = signalDef.make(this.reactivityGraph.context);
      const newValue = typeof value === "function" ? value(signalRef.value.get()) : value;
      signalRef.value.set(newValue);
      if (signalRef.rc > 1) {
        signalRef.deref();
      }
    });
    // #region commit
    /**
     * Commit a list of events to the store which will immediately update the local database
     * and sync the events across other clients (similar to a `git commit`).
     *
     * @example
     * ```ts
     * store.commit(events.todoCreated({ id: nanoid(), text: 'Make coffee' }))
     * ```
     *
     * You can call `commit` with multiple events to apply them in a single database transaction.
     *
     * @example
     * ```ts
     * const todoId = nanoid()
     * store.commit(
     *   events.todoCreated({ id: todoId, text: 'Make coffee' }),
     *   events.todoCompleted({ id: todoId }))
     * ```
     *
     * For more advanced transaction scenarios, you can pass a synchronous function to `commit` which will receive a callback
     * to which you can pass multiple events to be committed in the same database transaction.
     * Under the hood this will simply collect all events and apply them in a single database transaction.
     *
     * @example
     * ```ts
     * store.commit((commit) => {
     *   const todoId = nanoid()
     *   if (Math.random() > 0.5) {
     *     commit(events.todoCreated({ id: todoId, text: 'Make coffee' }))
     *   } else {
     *     commit(events.todoCompleted({ id: todoId }))
     *   }
     * })
     * ```
     *
     * When committing a large batch of events, you can also skip the database refresh to improve performance
     * and call `store.manualRefresh()` after all events have been committed.
     *
     * @example
     * ```ts
     * const todos = [
     *   { id: nanoid(), text: 'Make coffee' },
     *   { id: nanoid(), text: 'Buy groceries' },
     *   // ... 1000 more todos
     * ]
     * for (const todo of todos) {
     *   store.commit({ skipRefresh: true }, events.todoCreated({ id: todo.id, text: todo.text }))
     * }
     * store.manualRefresh()
     * ```
     */
    __publicField(this, "commit", (firstEventOrTxnFnOrOptions, ...restEvents) => {
      const { events, options } = this.getCommitArgs(firstEventOrTxnFnOrOptions, restEvents);
      for (const event of events) {
        replaceSessionIdSymbol(event.args, this.clientSession.sessionId);
      }
      if (events.length === 0)
        return;
      const skipRefresh = (options == null ? void 0 : options.skipRefresh) ?? false;
      const commitsSpan = trace.getSpan(this.otel.commitsSpanContext);
      commitsSpan.addEvent("commit");
      let durationMs;
      return this.otel.tracer.startActiveSpan("LiveStore:commit", {
        attributes: {
          "livestore.eventsCount": events.length,
          "livestore.eventTags": events.map((_) => _.name),
          "livestore.commitLabel": options == null ? void 0 : options.label
        },
        links: options == null ? void 0 : options.spanLinks
      }, (options == null ? void 0 : options.otelContext) ?? this.otel.commitsSpanContext, (span) => {
        const otelContext = trace.setSpan(context.active(), span);
        try {
          const { writeTables } = (() => {
            try {
              const materializeEvents = () => this.syncProcessor.push(events, { otelContext });
              if (events.length > 1) {
                return this.sqliteDbWrapper.txn(materializeEvents);
              } else {
                return materializeEvents();
              }
            } catch (e) {
              console.error(e);
              span.setStatus({ code: SpanStatusCode.ERROR, message: e.toString() });
              throw e;
            } finally {
              span.end();
            }
          })();
          const tablesToUpdate = [];
          for (const tableName of writeTables) {
            const tableRef = this.tableRefs[tableName];
            assertNever(tableRef !== void 0, `No table ref found for ${tableName}`);
            tablesToUpdate.push([tableRef, null]);
          }
          const debugRefreshReason = {
            _tag: "commit",
            events,
            writeTables: Array.from(writeTables)
          };
          this.reactivityGraph.setRefs(tablesToUpdate, { debugRefreshReason, otelContext, skipRefresh });
        } catch (e) {
          console.error(e);
          span.setStatus({ code: SpanStatusCode.ERROR, message: e.toString() });
          throw e;
        } finally {
          span.end();
          durationMs = getDurationMsFromSpan(span);
        }
        return { durationMs };
      });
    });
    // #endregion commit
    /**
     * Returns an async iterable of events.
     *
     * @example
     * ```ts
     * for await (const event of store.events()) {
     *   console.log(event)
     * }
     * ```
     *
     * @example
     * ```ts
     * // Get all events from the beginning of time
     * for await (const event of store.events({ cursor: EventSequenceNumber.ROOT })) {
     *   console.log(event)
     * }
     * ```
     */
    __publicField(this, "events", (_options) => {
      return notYetImplemented(`store.events() is not yet implemented but planned soon`);
    });
    __publicField(this, "eventsStream", (_options) => {
      return notYetImplemented(`store.eventsStream() is not yet implemented but planned soon`);
    });
    /**
     * This can be used in combination with `skipRefresh` when committing events.
     * We might need a better solution for this. Let's see.
     */
    __publicField(this, "manualRefresh", (options) => {
      const { label } = options ?? {};
      this.otel.tracer.startActiveSpan("LiveStore:manualRefresh", { attributes: { "livestore.manualRefreshLabel": label } }, this.otel.commitsSpanContext, (span) => {
        const otelContext = trace.setSpan(context.active(), span);
        this.reactivityGraph.runDeferredEffects({ otelContext });
        span.end();
      });
    });
    /**
     * Shuts down the store and closes the client session.
     *
     * This is called automatically when the store was created using the React or Effect API.
     */
    __publicField(this, "shutdown", async (cause) => {
      await this.clientSession.shutdown(cause ?? Cause_exports.fail(IntentionalShutdownCause.make({ reason: "manual" }))).pipe(this.runEffectFork, Fiber_exports.join, Effect_exports.runPromise);
    });
    /**
     * Helper methods useful during development
     *
     * @internal
     */
    __publicField(this, "_dev", {
      downloadDb: (source = "local") => {
        Effect_exports.gen(this, function* () {
          const data = source === "local" ? this.sqliteDbWrapper.export() : yield* this.clientSession.leaderThread.export;
          downloadBlob(data, `livestore-${Date.now()}.db`);
        }).pipe(this.runEffectFork);
      },
      downloadEventlogDb: () => {
        Effect_exports.gen(this, function* () {
          const data = yield* this.clientSession.leaderThread.getEventlogData;
          downloadBlob(data, `livestore-eventlog-${Date.now()}.db`);
        }).pipe(this.runEffectFork);
      },
      hardReset: (mode = "all-data") => {
        Effect_exports.gen(this, function* () {
          const clientId = this.clientSession.clientId;
          yield* this.clientSession.leaderThread.sendDevtoolsMessage(mod_exports2.Leader.ResetAllData.Request.make({ liveStoreVersion, mode, requestId: nanoid(), clientId }));
        }).pipe(this.runEffectFork);
      },
      overrideNetworkStatus: (status) => {
        const clientId = this.clientSession.clientId;
        this.clientSession.leaderThread.sendDevtoolsMessage(mod_exports2.Leader.SetSyncLatch.Request.make({
          clientId,
          closeLatch: status === "offline",
          liveStoreVersion,
          requestId: nanoid()
        })).pipe(this.runEffectFork);
      },
      syncStates: () => {
        Effect_exports.gen(this, function* () {
          const session = yield* this.syncProcessor.syncState;
          console.log("Session sync state:", session.toJSON());
          const leader = yield* this.clientSession.leaderThread.getSyncState;
          console.log("Leader sync state:", leader.toJSON());
        }).pipe(this.runEffectFork);
      },
      version: liveStoreVersion,
      otel: {
        rootSpanContext: () => {
          var _a2;
          return (_a2 = trace.getSpan(this.otel.rootSpanContext)) == null ? void 0 : _a2.spanContext();
        }
      }
    });
    // NOTE This is needed because when booting a Store via Effect it seems to call `toJSON` in the error path
    __publicField(this, "toJSON", () => ({
      _tag: "livestore.Store",
      reactivityGraph: this.reactivityGraph.getSnapshot({ includeResults: true })
    }));
    __publicField(this, "runEffectFork", (effect) => effect.pipe(Effect_exports.forkIn(this.effectContext.lifetimeScope), Effect_exports.tapCauseLogPretty, Runtime_exports.runFork(this.effectContext.runtime)));
    __publicField(this, "getCommitArgs", (firstEventOrTxnFnOrOptions, restEvents) => {
      let events;
      let options;
      if (typeof firstEventOrTxnFnOrOptions === "function") {
        events = firstEventOrTxnFnOrOptions((arg) => events.push(arg));
      } else if ((firstEventOrTxnFnOrOptions == null ? void 0 : firstEventOrTxnFnOrOptions.label) !== void 0 || (firstEventOrTxnFnOrOptions == null ? void 0 : firstEventOrTxnFnOrOptions.skipRefresh) !== void 0 || (firstEventOrTxnFnOrOptions == null ? void 0 : firstEventOrTxnFnOrOptions.otelContext) !== void 0 || (firstEventOrTxnFnOrOptions == null ? void 0 : firstEventOrTxnFnOrOptions.spanLinks) !== void 0) {
        options = firstEventOrTxnFnOrOptions;
        events = restEvents;
      } else if (firstEventOrTxnFnOrOptions === void 0) {
        events = [];
      } else {
        events = [firstEventOrTxnFnOrOptions, ...restEvents];
      }
      return { events, options };
    });
    this.storeId = storeId;
    this.sqliteDbWrapper = new SqliteDbWrapper({ otel: otelOptions, db: clientSession.sqliteDb });
    this.clientSession = clientSession;
    this.schema = schema;
    this.context = context2;
    this.effectContext = effectContext;
    const reactivityGraph = makeReactivityGraph();
    const syncSpan = otelOptions.tracer.startSpan("LiveStore:sync", {}, otelOptions.rootSpanContext);
    this.syncProcessor = makeClientSessionSyncProcessor({
      schema,
      clientSession,
      runtime: effectContext.runtime,
      materializeEvent: (eventDecoded, { otelContext, withChangeset, materializerHashLeader }) => {
        const { eventDef, materializer } = getEventDef(schema, eventDecoded.name);
        const execArgsArr = getExecStatementsFromMaterializer({
          eventDef,
          materializer,
          dbState: this.sqliteDbWrapper,
          event: { decoded: eventDecoded, encoded: void 0 }
        });
        const materializerHash = isDevEnv() ? Option_exports.some(hashMaterializerResults(execArgsArr)) : Option_exports.none();
        if (materializerHashLeader._tag === "Some" && materializerHash._tag === "Some" && materializerHashLeader.value !== materializerHash.value) {
          void this.shutdown(Cause_exports.fail(UnexpectedError.make({
            cause: `Materializer hash mismatch detected for event "${eventDecoded.name}".`,
            note: `Please make sure your event materializer is a pure function without side effects.`
          })));
        }
        const writeTablesForEvent = /* @__PURE__ */ new Set();
        const exec = () => {
          for (const { statementSql, bindValues, writeTables = this.sqliteDbWrapper.getTablesUsed(statementSql) } of execArgsArr) {
            try {
              this.sqliteDbWrapper.cachedExecute(statementSql, bindValues, { otelContext, writeTables });
            } catch (cause) {
              throw UnexpectedError.make({
                cause,
                note: `Error executing materializer for event "${eventDecoded.name}".
Statement: ${statementSql}
Bind values: ${JSON.stringify(bindValues)}`
              });
            }
            for (const table of writeTables) {
              writeTablesForEvent.add(table);
            }
          }
        };
        let sessionChangeset = { _tag: "unset" };
        if (withChangeset === true) {
          sessionChangeset = this.sqliteDbWrapper.withChangeset(exec).changeset;
        } else {
          exec();
        }
        return { writeTables: writeTablesForEvent, sessionChangeset, materializerHash };
      },
      rollback: (changeset) => {
        this.sqliteDbWrapper.rollback(changeset);
      },
      refreshTables: (tables) => {
        const tablesToUpdate = [];
        for (const tableName of tables) {
          const tableRef = this.tableRefs[tableName];
          assertNever(tableRef !== void 0, `No table ref found for ${tableName}`);
          tablesToUpdate.push([tableRef, null]);
        }
        reactivityGraph.setRefs(tablesToUpdate);
      },
      span: syncSpan,
      params: {
        leaderPushBatchSize: params.leaderPushBatchSize
      },
      confirmUnsavedChanges
    });
    this.__eventSchema = LiveStoreEvent_exports.makeEventDefSchemaMemo(schema);
    this.tableRefs = {};
    this.activeQueries = new ReferenceCountedSet();
    const commitsSpan = otelOptions.tracer.startSpan("LiveStore:commits", {}, otelOptions.rootSpanContext);
    const otelMuationsSpanContext = trace.setSpan(context.active(), commitsSpan);
    const queriesSpan = otelOptions.tracer.startSpan("LiveStore:queries", {}, otelOptions.rootSpanContext);
    const otelQueriesSpanContext = trace.setSpan(context.active(), queriesSpan);
    this.reactivityGraph = reactivityGraph;
    this.reactivityGraph.context = {
      store: this,
      defRcMap: /* @__PURE__ */ new Map(),
      reactivityGraph: new WeakRef(reactivityGraph),
      otelTracer: otelOptions.tracer,
      rootOtelContext: otelQueriesSpanContext,
      effectsWrapper: batchUpdates
    };
    this.otel = {
      tracer: otelOptions.tracer,
      rootSpanContext: otelOptions.rootSpanContext,
      commitsSpanContext: otelMuationsSpanContext,
      queriesSpanContext: otelQueriesSpanContext
    };
    const allTableNames = new Set(
      // NOTE we're excluding the LiveStore schema and events tables as they are not user-facing
      // unless LiveStore is running in the devtools
      __runningInDevtools ? this.schema.state.sqlite.tables.keys() : Array.from(this.schema.state.sqlite.tables.keys()).filter((_) => !system_tables_exports.isStateSystemTable(_))
    );
    const existingTableRefs = new Map(Array.from(this.reactivityGraph.atoms.values()).filter((_) => {
      var _a2;
      return _._tag === "ref" && ((_a2 = _.label) == null ? void 0 : _a2.startsWith("tableRef:")) === true;
    }).map((_) => [_.label.slice("tableRef:".length), _]));
    for (const tableName of allTableNames) {
      this.tableRefs[tableName] = existingTableRefs.get(tableName) ?? this.reactivityGraph.makeRef(null, {
        equal: () => false,
        label: `tableRef:${tableName}`,
        meta: { liveStoreRefType: "table" }
      });
    }
    this.boot = Effect_exports.gen(this, function* () {
      yield* Effect_exports.addFinalizer(() => Effect_exports.sync(() => {
        for (const tableRef of Object.values(this.tableRefs)) {
          for (const superComp of tableRef.super) {
            this.reactivityGraph.removeEdge(superComp, tableRef);
          }
        }
        syncSpan.end();
        commitsSpan.end();
        queriesSpan.end();
      }));
      yield* this.syncProcessor.boot;
    });
  }
  // #endregion constructor
  get sessionId() {
    return this.clientSession.sessionId;
  }
  get clientId() {
    return this.clientSession.clientId;
  }
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/store/devtools.js
var requestNextTick = globalThis.requestAnimationFrame === void 0 ? (cb) => setTimeout(cb, 1e3) : globalThis.requestAnimationFrame;
var cancelTick = globalThis.cancelAnimationFrame === void 0 ? (id) => clearTimeout(id) : globalThis.cancelAnimationFrame;
var connectDevtoolsToStore = ({ storeDevtoolsChannel, store }) => Effect_exports.gen(function* () {
  const reactivityGraphSubcriptions = /* @__PURE__ */ new Map();
  const liveQueriesSubscriptions = /* @__PURE__ */ new Map();
  const debugInfoHistorySubscriptions = /* @__PURE__ */ new Map();
  const syncHeadClientSessionSubscriptions = /* @__PURE__ */ new Map();
  const { clientId, sessionId } = store.clientSession;
  yield* Effect_exports.addFinalizer(() => Effect_exports.sync(() => {
    for (const unsub of reactivityGraphSubcriptions.values())
      unsub();
    for (const unsub of liveQueriesSubscriptions.values())
      unsub();
    for (const unsub of debugInfoHistorySubscriptions.values())
      unsub();
    for (const unsub of syncHeadClientSessionSubscriptions.values())
      unsub();
  }));
  const handledRequestIds = /* @__PURE__ */ new Set();
  const sendToDevtools = (message) => storeDevtoolsChannel.send(message).pipe(Effect_exports.tapCauseLogPretty, Effect_exports.runFork);
  const onMessage = (decodedMessage) => {
    var _a2, _b, _c, _d;
    if (decodedMessage.clientId !== clientId || decodedMessage.sessionId !== sessionId) {
      return;
    }
    if (decodedMessage._tag === "LSD.ClientSession.Disconnect") {
      return;
    }
    const requestId = decodedMessage.requestId;
    if (handledRequestIds.has(requestId)) {
      return;
    }
    handledRequestIds.add(requestId);
    const requestIdleCallback = globalThis.requestIdleCallback ?? ((cb) => cb());
    switch (decodedMessage._tag) {
      case "LSD.ClientSession.ReactivityGraphSubscribe": {
        const includeResults = decodedMessage.includeResults;
        const { subscriptionId } = decodedMessage;
        const send = () => (
          // In order to not add more work to the current tick, we use requestIdleCallback
          // to send the reactivity graph updates to the devtools
          requestIdleCallback(() => sendToDevtools(mod_exports2.ClientSession.ReactivityGraphRes.make({
            reactivityGraph: store.reactivityGraph.getSnapshot({ includeResults }),
            requestId: nanoid(10),
            clientId,
            sessionId,
            liveStoreVersion,
            subscriptionId
          })), { timeout: 500 })
        );
        send();
        const throttledSend = throttle(send, 20);
        reactivityGraphSubcriptions.set(subscriptionId, store.reactivityGraph.subscribeToRefresh(throttledSend));
        break;
      }
      case "LSD.ClientSession.DebugInfoReq": {
        sendToDevtools(mod_exports2.ClientSession.DebugInfoRes.make({
          debugInfo: store.sqliteDbWrapper.debugInfo,
          requestId,
          clientId,
          sessionId,
          liveStoreVersion
        }));
        break;
      }
      case "LSD.ClientSession.DebugInfoHistorySubscribe": {
        const { subscriptionId } = decodedMessage;
        const buffer = [];
        let hasStopped = false;
        let tickHandle;
        const tick = () => {
          buffer.push(store.sqliteDbWrapper.debugInfo);
          store.sqliteDbWrapper.debugInfo = emptyDebugInfo();
          if (buffer.length > 10) {
            sendToDevtools(mod_exports2.ClientSession.DebugInfoHistoryRes.make({
              debugInfoHistory: buffer,
              requestId: nanoid(10),
              clientId,
              sessionId,
              liveStoreVersion,
              subscriptionId
            }));
            buffer.length = 0;
          }
          if (hasStopped === false) {
            tickHandle = requestNextTick(tick);
          }
        };
        tickHandle = requestNextTick(tick);
        const unsub = () => {
          hasStopped = true;
          if (tickHandle !== void 0) {
            cancelTick(tickHandle);
            tickHandle = void 0;
          }
        };
        debugInfoHistorySubscriptions.set(subscriptionId, unsub);
        break;
      }
      case "LSD.ClientSession.DebugInfoHistoryUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        (_a2 = debugInfoHistorySubscriptions.get(subscriptionId)) == null ? void 0 : _a2();
        debugInfoHistorySubscriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.DebugInfoResetReq": {
        store.sqliteDbWrapper.debugInfo.slowQueries.clear();
        sendToDevtools(mod_exports2.ClientSession.DebugInfoResetRes.make({ requestId, clientId, sessionId, liveStoreVersion }));
        break;
      }
      case "LSD.ClientSession.DebugInfoRerunQueryReq": {
        const { queryStr, bindValues, queriedTables } = decodedMessage;
        store.sqliteDbWrapper.cachedSelect(queryStr, bindValues, { queriedTables, skipCache: true });
        sendToDevtools(mod_exports2.ClientSession.DebugInfoRerunQueryRes.make({ requestId, clientId, sessionId, liveStoreVersion }));
        break;
      }
      case "LSD.ClientSession.ReactivityGraphUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        (_b = reactivityGraphSubcriptions.get(subscriptionId)) == null ? void 0 : _b();
        reactivityGraphSubcriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.LiveQueriesSubscribe": {
        const { subscriptionId } = decodedMessage;
        const send = () => requestIdleCallback(() => sendToDevtools(mod_exports2.ClientSession.LiveQueriesRes.make({
          liveQueries: [...store.activeQueries].map((q) => ({
            _tag: q._tag,
            id: q.id,
            label: q.label,
            hash: q.def.hash,
            runs: q.runs,
            executionTimes: q.executionTimes.map((_) => Number(_.toString().slice(0, 5))),
            lastestResult: q.results$.previousResult === NOT_REFRESHED_YET ? "SYMBOL_NOT_REFRESHED_YET" : q.results$.previousResult,
            activeSubscriptions: Array.from(q.activeSubscriptions)
          })),
          requestId: nanoid(10),
          liveStoreVersion,
          clientId,
          sessionId,
          subscriptionId
        })), { timeout: 500 });
        send();
        const throttledSend = throttle(send, 20);
        liveQueriesSubscriptions.set(subscriptionId, store.reactivityGraph.subscribeToRefresh(throttledSend));
        break;
      }
      case "LSD.ClientSession.LiveQueriesUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        (_c = liveQueriesSubscriptions.get(subscriptionId)) == null ? void 0 : _c();
        liveQueriesSubscriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.SyncHeadSubscribe": {
        const { subscriptionId } = decodedMessage;
        const send = (syncState) => sendToDevtools(mod_exports2.ClientSession.SyncHeadRes.make({
          local: syncState.localHead,
          upstream: syncState.upstreamHead,
          requestId: nanoid(10),
          clientId,
          sessionId,
          liveStoreVersion,
          subscriptionId
        }));
        send(store.syncProcessor.syncState.pipe(Effect_exports.runSync));
        syncHeadClientSessionSubscriptions.set(subscriptionId, store.syncProcessor.syncState.changes.pipe(Stream_exports.tap((syncState) => send(syncState)), Stream_exports.runDrain, Effect_exports.interruptible, Effect_exports.tapCauseLogPretty, Effect_exports.runCallback));
        break;
      }
      case "LSD.ClientSession.SyncHeadUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        (_d = syncHeadClientSessionSubscriptions.get(subscriptionId)) == null ? void 0 : _d();
        syncHeadClientSessionSubscriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.Ping": {
        sendToDevtools(mod_exports2.ClientSession.Pong.make({ requestId, clientId, sessionId, liveStoreVersion }));
        break;
      }
      default: {
        console.warn(`[LSD.ClientSession] Unknown message`, decodedMessage);
      }
    }
  };
  yield* storeDevtoolsChannel.listen.pipe(
    // Stream.tapLogWithLabel('@livestore/livestore:store:devtools:onMessage'),
    Stream_exports.flatten(),
    Stream_exports.tapSync((message) => onMessage(message)),
    Stream_exports.runDrain,
    Effect_exports.withSpan("LSD.devtools.onMessage")
  );
}).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("LSD.devtools.connectStoreToDevtools"));

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/store/create-store.js
var DEFAULT_PARAMS = {
  leaderPushBatchSize: 100
};
var _LiveStoreContextRunning = class _LiveStoreContextRunning extends Context_exports.Tag("@livestore/livestore/effect/LiveStoreContextRunning")() {
};
__publicField(_LiveStoreContextRunning, "fromDeferred", Effect_exports.gen(function* () {
  const deferred = yield* DeferredStoreContext;
  const ctx = yield* deferred;
  return Layer_exports.succeed(_LiveStoreContextRunning, ctx);
}).pipe(Layer_exports.unwrapScoped));
var LiveStoreContextRunning = _LiveStoreContextRunning;
var DeferredStoreContext = class extends Context_exports.Tag("@livestore/livestore/effect/DeferredStoreContext")() {
};
var createStorePromise = async ({ signal: signal2, otelOptions, ...options }) => Effect_exports.gen(function* () {
  const scope = yield* Scope_exports.make();
  const runtime = yield* Effect_exports.runtime();
  if (signal2 !== void 0) {
    signal2.addEventListener("abort", () => {
      Scope_exports.close(scope, Exit_exports.void).pipe(Effect_exports.tapCauseLogPretty, Runtime_exports.runFork(runtime));
    });
  }
  return yield* createStore({ ...options }).pipe(Scope_exports.extend(scope));
}).pipe(Effect_exports.withSpan("createStore", {
  attributes: { storeId: options.storeId, disableDevtools: options.disableDevtools }
}), provideOtel({ parentSpanContext: otelOptions == null ? void 0 : otelOptions.rootSpanContext, otelTracer: otelOptions == null ? void 0 : otelOptions.tracer }), Effect_exports.tapCauseLogPretty, Effect_exports.annotateLogs({ thread: "window" }), Effect_exports.provide(Logger_exports.prettyWithThread("window")), Logger_exports.withMinimumLogLevel(LogLevel_exports.Debug), Effect_exports.runPromise);
var createStore = ({ schema, adapter, storeId, context: context2 = {}, boot, batchUpdates, disableDevtools, onBootStatus, shutdownDeferred, params, debug, confirmUnsavedChanges = true, syncPayload }) => Effect_exports.gen(function* () {
  const lifetimeScope = yield* Scope_exports.make();
  yield* validateStoreId(storeId);
  yield* Effect_exports.addFinalizer((_) => Scope_exports.close(lifetimeScope, _));
  const debugInstanceId = (debug == null ? void 0 : debug.instanceId) ?? nanoid(10);
  return yield* Effect_exports.gen(function* () {
    const span = yield* Tracer_exports.currentOtelSpan.pipe(Effect_exports.orDie);
    const otelRootSpanContext = trace.setSpan(context.active(), span);
    const otelTracer = yield* Tracer_exports.OtelTracer;
    const bootStatusQueue = yield* Queue_exports.unbounded().pipe(Effect_exports.acquireRelease(Queue_exports.shutdown));
    yield* Queue_exports.take(bootStatusQueue).pipe(Effect_exports.tapSync((status) => onBootStatus == null ? void 0 : onBootStatus(status)), Effect_exports.tap((status) => status.stage === "done" ? Queue_exports.shutdown(bootStatusQueue) : Effect_exports.void), Effect_exports.forever, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
    const storeDeferred = yield* Deferred_exports.make();
    const connectDevtoolsToStore_ = (storeDevtoolsChannel) => Effect_exports.gen(function* () {
      const store2 = yield* storeDeferred;
      yield* connectDevtoolsToStore({ storeDevtoolsChannel, store: store2 });
    });
    const runtime = yield* Effect_exports.runtime();
    const shutdown = (cause) => Effect_exports.gen(function* () {
      yield* Scope_exports.close(lifetimeScope, Exit_exports.failCause(cause)).pipe(Effect_exports.logWarnIfTakesLongerThan({ label: "@livestore/livestore:shutdown", duration: 500 }), Effect_exports.timeout(1e3), Effect_exports.catchTag("TimeoutException", () => Effect_exports.logError("@livestore/livestore:shutdown: Timed out after 1 second")));
      if (shutdownDeferred) {
        yield* Deferred_exports.failCause(shutdownDeferred, cause);
      }
      yield* Effect_exports.logDebug("LiveStore shutdown complete");
    }).pipe(
      Effect_exports.withSpan("@livestore/livestore:shutdown"),
      Effect_exports.provide(runtime),
      Effect_exports.tapCauseLogPretty,
      // Given that the shutdown flow might also interrupt the effect that is calling the shutdown,
      // we want to detach the shutdown effect so it's not interrupted by itself
      Effect_exports.runFork,
      Fiber_exports.join
    );
    const clientSession = yield* adapter({
      schema,
      storeId,
      devtoolsEnabled: getDevtoolsEnabled(disableDevtools),
      bootStatusQueue,
      shutdown,
      connectDevtoolsToStore: connectDevtoolsToStore_,
      debugInstanceId,
      syncPayload
    }).pipe(Effect_exports.withPerformanceMeasure("livestore:makeAdapter"), Effect_exports.withSpan("createStore:makeAdapter"));
    if (LS_DEV && clientSession.leaderThread.initialState.migrationsReport.migrations.length > 0) {
      yield* Effect_exports.logDebug("[@livestore/livestore:createStore] migrationsReport", ...clientSession.leaderThread.initialState.migrationsReport.migrations.map((m) => m.hashes.actual === void 0 ? `Table '${m.tableName}' doesn't exist yet. Creating table...` : `Schema hash mismatch for table '${m.tableName}' (DB: ${m.hashes.actual}, expected: ${m.hashes.expected}), migrating table...`));
    }
    const store = new Store({
      clientSession,
      schema,
      context: context2,
      otelOptions: { tracer: otelTracer, rootSpanContext: otelRootSpanContext },
      effectContext: { lifetimeScope, runtime },
      // TODO find a better way to detect if we're running LiveStore in the LiveStore devtools
      // But for now this is a good enough approximation with little downsides
      __runningInDevtools: getDevtoolsEnabled(disableDevtools) === false,
      confirmUnsavedChanges,
      // NOTE during boot we're not yet executing events in a batched context
      // but only set the provided `batchUpdates` function after boot
      batchUpdates: (run) => run(),
      storeId,
      params: {
        leaderPushBatchSize: (params == null ? void 0 : params.leaderPushBatchSize) ?? DEFAULT_PARAMS.leaderPushBatchSize
      }
    });
    yield* store.boot;
    if (boot !== void 0) {
      yield* Effect_exports.tryAll(() => boot(store, { migrationsReport: clientSession.leaderThread.initialState.migrationsReport, parentSpan: span })).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.provide(Layer_exports.succeed(LiveStoreContextRunning, { stage: "running", store })), Effect_exports.withSpan("createStore:boot"));
    }
    yield* Effect_exports.yieldNow();
    if (batchUpdates !== void 0) {
      store.reactivityGraph.context.effectsWrapper = batchUpdates;
    }
    yield* Deferred_exports.succeed(storeDeferred, store);
    return store;
  }).pipe(Effect_exports.withSpan("createStore", { attributes: { debugInstanceId, storeId } }), Effect_exports.annotateLogs({ debugInstanceId, storeId }), LS_DEV ? TaskTracing_exports.withAsyncTaggingTracing((name) => console.createTask(name)) : identity, Scope_exports.extend(lifetimeScope));
});
var validateStoreId = (storeId) => Effect_exports.gen(function* () {
  const validChars = /^[a-zA-Z0-9_-]+$/;
  if (!validChars.test(storeId)) {
    return yield* UnexpectedError.make({
      cause: `Invalid storeId: ${storeId}. Only alphanumeric characters, underscores, and hyphens are allowed.`,
      payload: { storeId }
    });
  }
});
var getDevtoolsEnabled = (disableDevtools) => {
  if (disableDevtools === true || disableDevtools === false) {
    return !disableDevtools;
  }
  if (isDevEnv() === true) {
    return true;
  }
  return false;
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/store/store-types.js
var makeShutdownDeferred = Deferred_exports.make();

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/utils/function-string.js
var REACT_NATIVE_BAD_FUNCTION_STRING = "function() { [bytecode] }";
var isValidFunctionString = (fnStr) => {
  if (fnStr === REACT_NATIVE_BAD_FUNCTION_STRING) {
    return { _tag: "invalid", reason: "react-native" };
  }
  return { _tag: "valid" };
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/live-queries/computed.js
var computed = (fn, options) => {
  const hash = (options == null ? void 0 : options.deps) ? depsToString(options.deps) : fn.toString();
  if (isValidFunctionString(hash)._tag === "invalid") {
    throw new Error(`On Expo/React Native, computed queries must provide a \`deps\` option`);
  }
  const def = {
    _tag: "def",
    make: withRCMap(hash, (ctx, _otelContext) => {
      return new LiveStoreComputedQuery({
        fn,
        label: (options == null ? void 0 : options.label) ?? fn.toString(),
        reactivityGraph: ctx.reactivityGraph.deref(),
        def
      });
    }),
    label: (options == null ? void 0 : options.label) ?? fn.toString(),
    // NOTE We're using the `makeQuery` function body string to make sure the key is unique across the app
    // TODO we should figure out whether this could cause some problems and/or if there's a better way to do this
    // NOTE `fn.toString()` doesn't work in Expo as it always produces `[native code]`
    hash
  };
  return def;
};
var LiveStoreComputedQuery = class extends LiveStoreQueryBase {
  constructor({ fn, label, reactivityGraph, def }) {
    super();
    __publicField(this, "_tag", "computed");
    /** A reactive thunk representing the query results */
    __publicField(this, "results$");
    __publicField(this, "label");
    __publicField(this, "reactivityGraph");
    __publicField(this, "def");
    __publicField(this, "destroy", () => {
      this.isDestroyed = true;
      this.reactivityGraph.destroyNode(this.results$);
      for (const query of this.dependencyQueriesRef) {
        query.deref();
      }
    });
    this.label = label;
    this.reactivityGraph = reactivityGraph;
    this.def = def;
    const queryLabel = `${label}:results`;
    this.results$ = this.reactivityGraph.makeThunk((get, setDebugInfo, ctx, otelContext) => ctx.otelTracer.startActiveSpan(`js:${label}`, {}, otelContext ?? ctx.rootOtelContext, (span) => {
      const otelContext2 = trace.setSpan(context.active(), span);
      const res = fn(makeGetAtomResult(get, ctx, otelContext2, this.dependencyQueriesRef));
      span.end();
      const durationMs = getDurationMsFromSpan(span);
      this.executionTimes.push(durationMs);
      setDebugInfo({ _tag: "computed", label, query: fn.toString(), durationMs });
      return res;
    }), { label: queryLabel, meta: { liveStoreThunkType: "computed" } });
  }
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/live-queries/db-query.js
var isQueryInputRaw = (value) => Predicate_exports.hasProperty(value, "query") && Predicate_exports.hasProperty(value, "schema");
var queryDb = (queryInput, options) => {
  const { queryString, extraDeps } = getQueryStringAndExtraDeps(queryInput);
  const hash = [queryString, (options == null ? void 0 : options.deps) ? depsToString(options.deps) : void 0, depsToString(extraDeps)].filter(Boolean).join("-");
  if (isValidFunctionString(hash)._tag === "invalid") {
    throw new Error(`On Expo/React Native, db queries must provide a \`deps\` option`);
  }
  if (hash.trim() === "") {
    return shouldNeverHappen(`Invalid query hash for query: ${queryInput}`);
  }
  const label = (options == null ? void 0 : options.label) ?? queryString;
  const def = {
    _tag: "def",
    make: withRCMap(hash, (ctx, otelContext) => {
      return new LiveStoreDbQuery({
        reactivityGraph: ctx.reactivityGraph.deref(),
        queryInput,
        label,
        map: options == null ? void 0 : options.map,
        otelContext,
        def
      });
    }),
    label,
    hash
  };
  return def;
};
var bindValuesToDepKey = (bindValues) => {
  if (bindValues === void 0) {
    return [];
  }
  return Object.entries(bindValues).map(([key, value]) => `${key}:${value === SessionIdSymbol ? "SessionIdSymbol" : value}`).join(",");
};
var getQueryStringAndExtraDeps = (queryInput) => {
  if (isQueryBuilder(queryInput)) {
    const { query, bindValues } = queryInput.asSql();
    return { queryString: query, extraDeps: bindValuesToDepKey(bindValues) };
  }
  if (isQueryInputRaw(queryInput)) {
    return { queryString: queryInput.query, extraDeps: bindValuesToDepKey(queryInput.bindValues) };
  }
  if (typeof queryInput === "function") {
    return { queryString: queryInput.toString(), extraDeps: [] };
  }
  return shouldNeverHappen(`Invalid query input: ${queryInput}`);
};
var LiveStoreDbQuery = class extends LiveStoreQueryBase {
  constructor({ queryInput, label: inputLabel, reactivityGraph, map, otelContext, def }) {
    super();
    __publicField(this, "_tag", "db");
    /** A reactive thunk representing the query text */
    __publicField(this, "queryInput$");
    /** A reactive thunk representing the query results */
    __publicField(this, "results$");
    __publicField(this, "label");
    __publicField(this, "reactivityGraph");
    __publicField(this, "mapResult");
    __publicField(this, "def");
    __publicField(this, "destroy", () => {
      this.isDestroyed = true;
      if (this.queryInput$ !== void 0) {
        this.reactivityGraph.destroyNode(this.queryInput$);
      }
      this.reactivityGraph.destroyNode(this.results$);
      for (const query of this.dependencyQueriesRef) {
        query.deref();
      }
    });
    let label = inputLabel ?? "db(unknown)";
    this.reactivityGraph = reactivityGraph;
    this.def = def;
    this.mapResult = map === void 0 ? (rows) => rows : map;
    const schemaRef = {
      current: typeof queryInput === "function" ? void 0 : isQueryBuilder(queryInput) ? void 0 : queryInput.schema
    };
    const execBeforeFirstRunRef = {
      current: void 0
    };
    let queryInputRaw$OrQueryInputRaw;
    const fromQueryBuilder = (qb, otelContext2) => {
      try {
        const qbRes = qb.asSql();
        const schema = getResultSchema(qb);
        const ast = qb[QueryBuilderAstSymbol];
        return {
          queryInputRaw: {
            query: qbRes.query,
            schema,
            bindValues: qbRes.bindValues,
            queriedTables: /* @__PURE__ */ new Set([ast.tableDef.sqliteDef.name])
          },
          label: ast._tag === "RowQuery" ? rowQueryLabel(ast.tableDef, ast.id) : qb.toString(),
          execBeforeFirstRun: ast._tag === "RowQuery" ? makeExecBeforeFirstRun({
            table: ast.tableDef,
            explicitDefaultValues: ast.explicitDefaultValues,
            id: ast.id,
            otelContext: otelContext2
          }) : void 0
        };
      } catch (cause) {
        throw new UnexpectedError({ cause, note: `Error building query for ${qb.toString()}`, payload: { qb } });
      }
    };
    if (typeof queryInput === "function") {
      queryInputRaw$OrQueryInputRaw = this.reactivityGraph.makeThunk((get, setDebugInfo, ctx, otelContext2) => {
        const startMs = performance.now();
        const queryInputResult = queryInput(makeGetAtomResult(get, ctx, otelContext2 ?? ctx.rootOtelContext, this.dependencyQueriesRef), ctx);
        const durationMs = performance.now() - startMs;
        let queryInputRaw;
        if (isQueryBuilder(queryInputResult)) {
          const res = fromQueryBuilder(queryInputResult, otelContext2);
          queryInputRaw = res.queryInputRaw;
          this.label = res.label;
          execBeforeFirstRunRef.current = res.execBeforeFirstRun;
        } else {
          queryInputRaw = queryInputResult;
        }
        setDebugInfo({ _tag: "computed", label: `${this.label}:queryInput`, query: queryInputRaw.query, durationMs });
        schemaRef.current = queryInputRaw.schema;
        return queryInputRaw;
      }, {
        label: `${label}:query`,
        meta: { liveStoreThunkType: "db.query" },
        // NOTE we're not checking the schema here as we assume the query string to always change when the schema might change
        equal: (a, b) => a.query === b.query && deepEqual(a.bindValues, b.bindValues)
      });
      this.queryInput$ = queryInputRaw$OrQueryInputRaw;
    } else {
      let queryInputRaw;
      if (isQueryBuilder(queryInput)) {
        const res = fromQueryBuilder(queryInput, otelContext);
        queryInputRaw = res.queryInputRaw;
        label = res.label;
        execBeforeFirstRunRef.current = res.execBeforeFirstRun;
      } else {
        queryInputRaw = queryInput;
      }
      schemaRef.current = queryInputRaw.schema;
      queryInputRaw$OrQueryInputRaw = queryInputRaw;
      if (inputLabel === void 0 && isQueryBuilder(queryInput)) {
        const ast = queryInput[QueryBuilderAstSymbol];
        if (ast._tag === "RowQuery") {
          label = `db(${rowQueryLabel(ast.tableDef, ast.id)})`;
        }
      }
    }
    const queriedTablesRef = { current: void 0 };
    const makeResultsEqual = (resultSchema) => (a, b) => a === NOT_REFRESHED_YET || b === NOT_REFRESHED_YET ? false : Schema_exports.equivalence(resultSchema)(a, b);
    const resultsEqual = map === void 0 ? schemaRef.current === void 0 ? (a, b) => makeResultsEqual(schemaRef.current)(a, b) : makeResultsEqual(schemaRef.current) : void 0;
    const results$ = this.reactivityGraph.makeThunk((get, setDebugInfo, queryContext, otelContext2, debugRefreshReason) => queryContext.otelTracer.startActiveSpan(
      "db:...",
      // NOTE span name will be overridden further down
      {
        attributes: {
          "livestore.debugRefreshReason": Predicate_exports.hasProperty(debugRefreshReason, "label") ? debugRefreshReason.label : debugRefreshReason == null ? void 0 : debugRefreshReason._tag
        }
      },
      otelContext2 ?? queryContext.rootOtelContext,
      (span) => {
        const otelContext3 = trace.setSpan(context.active(), span);
        const { store } = queryContext;
        if (execBeforeFirstRunRef.current !== void 0) {
          execBeforeFirstRunRef.current(queryContext, otelContext3);
          execBeforeFirstRunRef.current = void 0;
        }
        const queryInputResult = isThunk(queryInputRaw$OrQueryInputRaw) ? get(queryInputRaw$OrQueryInputRaw, otelContext3, debugRefreshReason) : queryInputRaw$OrQueryInputRaw;
        const sqlString = queryInputResult.query;
        const bindValues = queryInputResult.bindValues;
        if (queriedTablesRef.current === void 0) {
          queriedTablesRef.current = store.sqliteDbWrapper.getTablesUsed(sqlString);
        }
        if (bindValues !== void 0) {
          replaceSessionIdSymbol(bindValues, store.clientSession.sessionId);
        }
        for (const tableName of queriedTablesRef.current) {
          const tableRef = store.tableRefs[tableName] ?? shouldNeverHappen(`No table ref found for ${tableName}`);
          get(tableRef, otelContext3, debugRefreshReason);
        }
        span.setAttribute("sql.query", sqlString);
        span.updateName(`db:${sqlString.slice(0, 50)}`);
        const rawDbResults = store.sqliteDbWrapper.cachedSelect(sqlString, bindValues ? prepareBindValues(bindValues, sqlString) : void 0, {
          queriedTables: queriedTablesRef.current,
          otelContext: otelContext3
        });
        span.setAttribute("sql.rowsCount", rawDbResults.length);
        const parsedResult = Schema_exports.decodeEither(schemaRef.current)(rawDbResults);
        if (parsedResult._tag === "Left") {
          const parseErrorStr = TreeFormatter.formatErrorSync(parsedResult.left);
          const expectedSchemaStr = String(schemaRef.current.ast);
          const bindValuesStr = bindValues === void 0 ? "" : `
Bind values: ${JSON.stringify(bindValues)}`;
          return shouldNeverHappen(`Error parsing SQL query result (${label}).

Query: ${sqlString}${bindValuesStr}

Expected schema: ${expectedSchemaStr}

Error: ${parseErrorStr}

Result:`, rawDbResults, "\n");
        }
        const result = this.mapResult(parsedResult.right);
        span.end();
        const durationMs = getDurationMsFromSpan(span);
        this.executionTimes.push(durationMs);
        setDebugInfo({ _tag: "db", label: `${label}:results`, query: sqlString, durationMs });
        return result;
      }
    ), { label: `${label}:results`, meta: { liveStoreThunkType: "db.result" }, equal: resultsEqual });
    this.results$ = results$;
    this.label = label;
  }
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/live-queries/signal.js
var signal = (defaultValue, options) => {
  const id = nanoid();
  const def = {
    _tag: "signal-def",
    defaultValue,
    hash: id,
    label: (options == null ? void 0 : options.label) ?? "Signal",
    make: withRCMap(id, (ctx) => new Signal({
      defaultValue,
      reactivityGraph: ctx.reactivityGraph.deref(),
      label: (options == null ? void 0 : options.label) ?? "Signal",
      def
    }))
  };
  return def;
};
var Signal = class extends LiveStoreQueryBase {
  constructor({ defaultValue, reactivityGraph, label, def }) {
    super();
    __publicField(this, "_tag", "signal");
    __publicField(this, "ref");
    __publicField(this, "label");
    __publicField(this, "reactivityGraph");
    __publicField(this, "results$");
    __publicField(this, "def");
    __publicField(this, "set", (value) => {
      this.reactivityGraph.setRef(this.ref, value);
    });
    __publicField(this, "get", () => {
      return this.ref.computeResult();
    });
    __publicField(this, "destroy", () => {
      this.reactivityGraph.destroyNode(this.ref);
    });
    this.ref = reactivityGraph.makeRef(defaultValue, { label });
    this.label = label;
    this.reactivityGraph = reactivityGraph;
    this.def = def;
    this.results$ = this.ref;
  }
};

// node_modules/.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/dist/utils/stack-info.js
var extractStackInfoFromStackTrace = (stackTrace) => {
  const namePattern = /at (\S+) \((.+)\)/g;
  let match;
  const frames = [];
  let hasReachedStart = false;
  while ((match = namePattern.exec(stackTrace)) !== null) {
    const [, name, filePath] = match;
    if ((name.startsWith("use") || name.startsWith("Module.use")) && name.endsWith("QueryRef") === false) {
      hasReachedStart = true;
      frames.unshift({ name: name.replace(/^Module\./, ""), filePath });
    } else if (hasReachedStart) {
      if (name !== "Object.react-stack-bottom-frame") {
        frames.unshift({ name, filePath });
      }
      break;
    }
  }
  return { frames };
};
var stackInfoToString = (stackInfo) => stackInfo.frames.map((f) => `${f.name} (${f.filePath})`).join("\n");

export {
  emptyDebugInfo,
  SqliteDbWrapper,
  Store,
  createStorePromise,
  createStore,
  makeShutdownDeferred,
  computed,
  queryDb,
  signal,
  extractStackInfoFromStackTrace,
  stackInfoToString
};
//# sourceMappingURL=chunk-L7G2HKHX.js.map

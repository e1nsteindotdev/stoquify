{
  "version": 3,
  "sources": ["../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/LiveStoreContext.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/useStore.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/useClientDocument.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/useQuery.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/useRcResource.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/utils/stack-info.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/utils/useStateRefWithReactiveInput.ts", "../../.pnpm/@livestore+react@0.3.1_f267772f79853f95de3f4cf7c2aa770b/node_modules/@livestore/react/src/LiveStoreProvider.tsx"],
  "sourcesContent": ["import type { LiveStoreContextRunning } from '@livestore/livestore'\nimport React from 'react'\n\nimport type { useClientDocument } from './useClientDocument.js'\nimport type { useQuery } from './useQuery.js'\n\nexport type ReactApi = {\n  useQuery: typeof useQuery\n  useClientDocument: typeof useClientDocument\n}\n\nexport const LiveStoreContext = React.createContext<\n  { stage: 'running'; store: LiveStoreContextRunning['store'] & ReactApi } | undefined\n>(undefined)\n", "import type { Store } from '@livestore/livestore'\nimport React from 'react'\n\nimport type { ReactApi } from './LiveStoreContext.js'\nimport { LiveStoreContext } from './LiveStoreContext.js'\nimport { useClientDocument } from './useClientDocument.js'\nimport { useQuery } from './useQuery.js'\n\nexport const withReactApi = (store: Store): Store & ReactApi => {\n  // @ts-expect-error TODO properly implement this\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  store.useQuery = (queryDef) => useQuery(queryDef, { store })\n  // @ts-expect-error TODO properly implement this\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  store.useClientDocument = (table, idOrOptions, options) => useClientDocument(table, idOrOptions, options, { store })\n  return store as Store & ReactApi\n}\n\nexport const useStore = (options?: { store?: Store }): { store: Store & ReactApi } => {\n  if (options?.store !== undefined) {\n    return { store: withReactApi(options.store) }\n  }\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const storeContext = React.useContext(LiveStoreContext)\n\n  if (storeContext === undefined) {\n    throw new Error(`useStore can only be used inside StoreContext.Provider`)\n  }\n\n  if (storeContext.stage !== 'running') {\n    throw new Error(`useStore can only be used after the store is running`)\n  }\n\n  return { store: withReactApi(storeContext.store) }\n}\n", "import type { RowQuery } from '@livestore/common'\nimport { SessionIdSymbol } from '@livestore/common'\nimport { State } from '@livestore/common/schema'\nimport type { LiveQuery, LiveQueryDef, Store } from '@livestore/livestore'\nimport { queryDb } from '@livestore/livestore'\nimport { shouldNeverHappen } from '@livestore/utils'\nimport React from 'react'\n\nimport { LiveStoreContext } from './LiveStoreContext.js'\nimport { useQueryRef } from './useQuery.js'\n\nexport type UseRowResult<TTableDef extends State.SQLite.ClientDocumentTableDef.TraitAny> = [\n  row: TTableDef['Value'],\n  setRow: StateSetters<TTableDef>,\n  id: string,\n  query$: LiveQuery<TTableDef['Value']>,\n]\n\n/**\n * Similar to `React.useState` but returns a tuple of `[state, setState, id, query$]` for a given table where ...\n *\n *   - `state` is the current value of the row (fully decoded according to the table schema)\n *   - `setState` is a function that can be used to update the document\n *   - `id` is the id of the document\n *   - `query$` is a `LiveQuery` that e.g. can be used to subscribe to changes to the document\n *\n * `useClientDocument` only works for client-document tables:\n *\n * ```tsx\n * const MyState = State.SQLite.clientDocument({\n *   name: 'MyState',\n *   schema: Schema.Struct({\n *     showSidebar: Schema.Boolean,\n *   }),\n *   default: { id: SessionIdSymbol, value: { showSidebar: true } },\n * })\n *\n * const MyComponent = () => {\n *   const [{ showSidebar }, setState] = useClientDocument(MyState)\n *   return (\n *     <div onClick={() => setState({ showSidebar: !showSidebar })}>\n *       {showSidebar ? 'Sidebar is open' : 'Sidebar is closed'}\n *     </div>\n *   )\n * }\n * ```\n *\n * If the table has a default id, `useClientDocument` can be called without an `id` argument. Otherwise, the `id` argument is required.\n */\nexport const useClientDocument: {\n  // case: with default id\n  <\n    TTableDef extends State.SQLite.ClientDocumentTableDef.Trait<\n      any,\n      any,\n      any,\n      { partialSet: boolean; default: { id: string | SessionIdSymbol; value: any } }\n    >,\n  >(\n    table: TTableDef,\n    id?: State.SQLite.ClientDocumentTableDef.DefaultIdType<TTableDef> | SessionIdSymbol,\n    options?: Partial<RowQuery.GetOrCreateOptions<TTableDef>>,\n  ): UseRowResult<TTableDef>\n\n  // case: no default id â†’ id arg is required\n  <\n    TTableDef extends State.SQLite.ClientDocumentTableDef.Trait<\n      any,\n      any,\n      any,\n      { partialSet: boolean; default: { id: string | SessionIdSymbol | undefined; value: any } }\n    >,\n  >(\n    table: TTableDef,\n    // TODO adjust so it works with arbitrary primary keys or unique constraints\n    id: State.SQLite.ClientDocumentTableDef.DefaultIdType<TTableDef> | string | SessionIdSymbol,\n    options?: Partial<RowQuery.GetOrCreateOptions<TTableDef>>,\n  ): UseRowResult<TTableDef>\n} = <TTableDef extends State.SQLite.ClientDocumentTableDef.Any>(\n  table: TTableDef,\n  idOrOptions?: string | SessionIdSymbol,\n  options_?: Partial<RowQuery.GetOrCreateOptions<TTableDef>>,\n  storeArg?: { store?: Store },\n): UseRowResult<TTableDef> => {\n  const id =\n    typeof idOrOptions === 'string' || idOrOptions === SessionIdSymbol\n      ? idOrOptions\n      : table[State.SQLite.ClientDocumentTableDefSymbol].options.default.id\n\n  const options: Partial<RowQuery.GetOrCreateOptions<TTableDef>> | undefined =\n    typeof idOrOptions === 'string' || idOrOptions === SessionIdSymbol ? options_ : idOrOptions\n\n  const { default: defaultValues } = options ?? {}\n\n  React.useMemo(() => validateTableOptions(table), [table])\n\n  const tableName = table.sqliteDef.name\n\n  const store =\n    storeArg?.store ??\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useContext(LiveStoreContext)?.store ??\n    shouldNeverHappen(`No store provided to useClientDocument`)\n\n  // console.debug('useClientDocument', tableName, id)\n\n  const idStr: string = id === SessionIdSymbol ? store.clientSession.sessionId : id\n\n  type QueryDef = LiveQueryDef<TTableDef['Value']>\n  const queryDef: QueryDef = React.useMemo(\n    () =>\n      queryDb(table.get(id!, { default: defaultValues! }), {\n        deps: [idStr!, table.sqliteDef.name, JSON.stringify(defaultValues)],\n      }),\n    [table, id, defaultValues, idStr],\n  )\n\n  const queryRef = useQueryRef(queryDef, {\n    otelSpanName: `LiveStore:useClientDocument:${tableName}:${idStr}`,\n    store: storeArg?.store,\n  })\n\n  const setState = React.useMemo<StateSetters<TTableDef>>(\n    () => (newValueOrFn: TTableDef['Value']) => {\n      const newValue = typeof newValueOrFn === 'function' ? newValueOrFn(queryRef.valueRef.current) : newValueOrFn\n      if (queryRef.valueRef.current === newValue) return\n\n      store.commit(table.set(removeUndefinedValues(newValue), id as any))\n    },\n    [id, queryRef.valueRef, store, table],\n  )\n\n  return [queryRef.valueRef.current, setState, idStr, queryRef.queryRcRef.value]\n}\n\nexport type Dispatch<A> = (action: A) => void\nexport type SetStateAction<S> = Partial<S> | ((previousValue: S) => Partial<S>)\n\nexport type StateSetters<TTableDef extends State.SQLite.ClientDocumentTableDef.TraitAny> = Dispatch<\n  SetStateAction<TTableDef['Value']>\n>\n\nconst validateTableOptions = (table: State.SQLite.TableDef<any, any>) => {\n  if (State.SQLite.tableIsClientDocumentTable(table) === false) {\n    return shouldNeverHappen(\n      `useClientDocument called on table \"${table.sqliteDef.name}\" which is not a client document table`,\n    )\n  }\n}\n\nconst removeUndefinedValues = (value: any) => {\n  if (typeof value === 'object' && value !== null) {\n    return Object.fromEntries(Object.entries(value).filter(([_, v]) => v !== undefined))\n  }\n\n  return value\n}\n", "/* eslint-disable react-hooks/rules-of-hooks */\nimport type { LiveQuery, LiveQueryDef, Store } from '@livestore/livestore'\nimport { extractStackInfoFromStackTrace, stackInfoToString } from '@livestore/livestore'\nimport type { LiveQueries } from '@livestore/livestore/internal'\nimport { deepEqual, indent, shouldNeverHappen } from '@livestore/utils'\nimport * as otel from '@opentelemetry/api'\nimport React from 'react'\n\nimport { LiveStoreContext } from './LiveStoreContext.js'\nimport { useRcResource } from './useRcResource.js'\nimport { originalStackLimit } from './utils/stack-info.js'\nimport { useStateRefWithReactiveInput } from './utils/useStateRefWithReactiveInput.js'\n\n/**\n * Returns the result of a query and subscribes to future updates.\n *\n * Example:\n * ```tsx\n * const App = () => {\n *   const todos = useQuery(queryDb(tables.todos.query.where({ complete: true })))\n *   return <div>{todos.map((todo) => <div key={todo.id}>{todo.title}</div>)}</div>\n * }\n * ```\n */\nexport const useQuery = <TQuery extends LiveQueryDef.Any>(\n  queryDef: TQuery,\n  options?: { store?: Store },\n): LiveQueries.GetResult<TQuery> => useQueryRef(queryDef, options).valueRef.current\n\n/**\n */\nexport const useQueryRef = <TQuery extends LiveQueryDef.Any>(\n  queryDef: TQuery,\n  options?: {\n    store?: Store\n    /** Parent otel context for the query */\n    otelContext?: otel.Context\n    /** The name of the span to use for the query */\n    otelSpanName?: string\n  },\n): {\n  valueRef: React.RefObject<LiveQueries.GetResult<TQuery>>\n  queryRcRef: LiveQueries.RcRef<LiveQuery<LiveQueries.GetResult<TQuery>>>\n} => {\n  const store =\n    options?.store ?? React.useContext(LiveStoreContext)?.store ?? shouldNeverHappen(`No store provided to useQuery`)\n\n  // It's important to use all \"aspects\" of a store instance here, otherwise we get unexpected cache mappings\n  const rcRefKey = `${store.storeId}_${store.clientId}_${store.sessionId}_${queryDef.hash}`\n\n  const stackInfo = React.useMemo(() => {\n    Error.stackTraceLimit = 10\n    // eslint-disable-next-line unicorn/error-message\n    const stack = new Error().stack!\n    Error.stackTraceLimit = originalStackLimit\n    return extractStackInfoFromStackTrace(stack)\n  }, [])\n\n  const { queryRcRef, span, otelContext } = useRcResource(\n    rcRefKey,\n    () => {\n      const queryDefLabel = queryDef.label\n\n      const span = store.otel.tracer.startSpan(\n        options?.otelSpanName ?? `LiveStore:useQuery:${queryDefLabel}`,\n        { attributes: { label: queryDefLabel, firstStackInfo: JSON.stringify(stackInfo) } },\n        options?.otelContext ?? store.otel.queriesSpanContext,\n      )\n\n      const otelContext = otel.trace.setSpan(otel.context.active(), span)\n\n      const queryRcRef = queryDef.make(store.reactivityGraph.context!, otelContext)\n\n      return { queryRcRef, span, otelContext }\n    },\n    // We need to keep the queryRcRef alive a bit longer, so we have a second `useRcResource` below\n    // which takes care of disposing the queryRcRef\n    () => {},\n  )\n\n  // if (queryRcRef.value._tag === 'signal') {\n  //   const  queryRcRef.value.get()\n  // }\n\n  const query$ = queryRcRef.value as LiveQuery<LiveQueries.GetResult<TQuery>>\n\n  React.useDebugValue(`LiveStore:useQuery:${query$.id}:${query$.label}`)\n  // console.debug(`LiveStore:useQuery:${query$.id}:${query$.label}`)\n\n  const initialResult = React.useMemo(() => {\n    try {\n      return query$.run({\n        otelContext,\n        debugRefreshReason: {\n          _tag: 'react',\n          api: 'useQuery',\n          label: `useQuery:initial-run:${query$.label}`,\n          stackInfo,\n        },\n      })\n    } catch (cause: any) {\n      console.error('[@livestore/react:useQuery] Error running query', cause)\n      throw new Error(\n        `\\\n[@livestore/react:useQuery] Error running query: ${cause.name}\n\nQuery: ${query$.label}\n\nReact trace:\n\n${indent(stackInfoToString(stackInfo), 4)}\n\nStack trace:\n`,\n        { cause },\n      )\n    }\n  }, [otelContext, query$, stackInfo])\n\n  // We know the query has a result by the time we use it; so we can synchronously populate a default state\n  const [valueRef, setValue] = useStateRefWithReactiveInput<LiveQueries.GetResult<TQuery>>(initialResult)\n\n  // TODO we probably need to change the order of `useEffect` calls, so we destroy the query at the end\n  // before calling the LS `onEffect` on it\n\n  // Subscribe to future updates for this query\n  React.useEffect(() => {\n    // TODO double check whether we still need `activeSubscriptions`\n    query$.activeSubscriptions.add(stackInfo)\n\n    // Dynamic queries only set their actual label after they've been run the first time,\n    // so we're also updating the span name here.\n    span.updateName(options?.otelSpanName ?? `LiveStore:useQuery:${query$.label}`)\n\n    return store.subscribe(query$, {\n      onUpdate: (newValue) => {\n        // NOTE: we return a reference to the result object within LiveStore;\n        // this implies that app code must not mutate the results, or else\n        // there may be weird reactivity bugs.\n        if (deepEqual(newValue, valueRef.current) === false) {\n          setValue(newValue)\n        }\n      },\n      onUnsubsubscribe: () => {\n        query$.activeSubscriptions.delete(stackInfo)\n      },\n      label: query$.label,\n      otelContext,\n    })\n  }, [stackInfo, query$, setValue, store, valueRef, otelContext, span, options?.otelSpanName])\n\n  useRcResource(\n    rcRefKey,\n    () => ({ queryRcRef, span }),\n    ({ queryRcRef, span }) => {\n      // console.debug('deref', queryRcRef.value.id, queryRcRef.value.label)\n      queryRcRef.deref()\n      span.end()\n    },\n  )\n\n  return { valueRef, queryRcRef }\n}\n", "import * as React from 'react'\n\n/**\n * Creates a reference-counted resource object that is \"stable\" across React lifecycles.\n *\n * The hook is primarily intended for creating stateful objects or entities where:\n * 1) reference identity is crucial (e.g. stateful objects, references, ...)\n *    and needed to persist across multiple component instances\n * 2) the `create`/`dispose` functions might be effectful and can be called exactly once per key\n *\n * **Goals:**\n * - Guarantee stable reference identity for stateful entities that are created via the `create` function.\n * - Strong guarantees about the `create`/`dispose` calls (i.e. exactly one `create`/`dispose` call per key)\n * - Ensure that such state is retained across component re-mounts, even in development environments like\n *   React Strict Mode or during Fast Refresh.\n * - Automatically handle resource disposal by decrementing a reference count and disposing of the resource\n *   when no components are using it.\n *\n * **Behavior:**\n * - On the first render with a specific key, the `create` function is invoked to create the stateful entity,\n *   and the resource is stored in a cache with a reference count set to 1.\n * - If another component renders with the same key, the cached entity is reused and its reference count is incremented.\n * - When a component renders with a new key, the previous key's reference count is decremented and, if it reaches zero,\n *   the `dispose` function is called for that resource.\n * - Upon component unmount, the reference count is decremented, leading to disposal (via the `dispose` function)\n *   if the reference count drops to zero. An unmount is either detected via React's `useEffect` callback or\n *   in the useMemo hook when the key changes.\n * \n * Why this is needed in LiveStore:\n * Let's first take a look at the \"trivial implementation\":\n * \n * ```ts\n * const useSimpleResource = <T>(create: () => T, dispose: (resource: T) => void) => {\n *     const val = React.useMemo(() => create(), [create])\n *\n *     React.useEffect(() => {\n *       return () => {\n *         dispose(val)\n *       }\n *     }, [dispose, val])\n\n *     return val\n * }\n * ```\n * \n * LiveStore uses this hook to create LiveQuery instances which are stateful and must not be leaked.\n * The simple implementation above would leak the LiveQuery instance if the component is unmounted or props change.\n *\n * **Usage:**\n * ```tsx\n * // Create a stateful object instance for a unique key and share it between components.\n * const statefulObject = useRcResource(\n *   'stable-object-key',\n *   () => createObjectInstance(),\n *   (object) => object.dispose()\n * );\n * ```\n *\n * **Caveats:**\n * - The `create` function is intentionally omitted from the dependency array in `useMemo` to prevent\n *   unintended re-creations of the stateful entity. Avoid closing over changing values within `create`\n *   or include them in the `key`.\n * - Ensure that the `dispose` function is stable or properly memoized as its reference is used in a `useEffect`.\n * - Although the caching mechanism prevents duplicate instance creation for the same key, the strategy\n *   can interact in unexpected ways with Reactâ€™s development patterns. Please report any issues if encountered.\n *\n * @template T The type of the stateful entity managed by the hook.\n * @param key A unique identifier for the stateful entity. A change in this key triggers a disposal of the previous resource.\n * @param create Function to create the stateful entity when it does not exist in the cache.\n * @param dispose Function to dispose of the stateful entity when itâ€™s no longer needed. Needs to be stable.\n * @param _options Optional. Additional options such as a debug print callback for logging purposes.\n * @returns The stateful entity corresponding to the provided key.\n */\nexport const useRcResource = <T>(\n  key: string,\n  create: () => T,\n  dispose: (resource: NoInfer<T>) => void,\n  _options?: { debugPrint?: (resource: NoInfer<T>) => ReadonlyArray<any> },\n): T => {\n  const keyRef = React.useRef<string | undefined>(undefined)\n  const didDisposeInMemo = React.useRef(false)\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n  const resource = React.useMemo(() => {\n    // console.debug('useMemo', key)\n    if (didDisposeInMemo.current) {\n      // console.debug('useMemo', key, 'skip')\n      const cachedItem = cache.get(key)\n      if (cachedItem !== undefined && cachedItem._tag === 'active') {\n        return cachedItem.resource\n      }\n    }\n\n    // Check if the key has changed (or is undefined)\n    if (keyRef.current !== undefined && keyRef.current !== key) {\n      // If the key has changed, decrement the reference on the previous key\n      const previousKey = keyRef.current\n      const cachedItemForPreviousKey = cache.get(previousKey)\n      if (cachedItemForPreviousKey !== undefined && cachedItemForPreviousKey._tag === 'active') {\n        // previousKeyRef.current = previousKey\n        cachedItemForPreviousKey.rc--\n\n        // console.debug('useMemo', key, 'rc--', previousKey, cachedItemForPreviousKey.rc)\n\n        if (cachedItemForPreviousKey.rc === 0) {\n          // Clean up the stateful resource if no longer referenced\n          dispose(cachedItemForPreviousKey.resource)\n          cache.set(previousKey, { _tag: 'destroyed' })\n          didDisposeInMemo.current = true\n        }\n      }\n    }\n\n    const cachedItem = cache.get(key)\n    if (cachedItem !== undefined && cachedItem._tag === 'active') {\n      // In React Strict Mode, the `useMemo` hook is called multiple times,\n      // so we only increment the reference from the first call for this component.\n      cachedItem.rc++\n      // console.debug('rc++', cachedItem.rc, ...(_options?.debugPrint?.(cachedItem.resource) ?? []))\n\n      return cachedItem.resource\n    }\n\n    // Create a new stateful resource if not cached\n    const resource = create()\n    cache.set(key, { _tag: 'active', rc: 1, resource })\n    return resource\n    // Dependency is deliberately limited to `key` to avoid unintended re-creations.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [key])\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n  React.useEffect(() => {\n    return () => {\n      if (didDisposeInMemo.current) {\n        // console.debug('unmount', keyRef.current, 'skip')\n        didDisposeInMemo.current = false\n        return\n      }\n\n      // console.debug('unmount', keyRef.current)\n      const cachedItem = cache.get(key)\n      // If the stateful resource is already cleaned up, do nothing.\n      if (cachedItem === undefined || cachedItem._tag === 'destroyed') return\n\n      cachedItem.rc--\n\n      // console.debug('rc--', cachedItem.rc, ...(_options?.debugPrint?.(cachedItem.resource) ?? []))\n\n      if (cachedItem.rc === 0) {\n        dispose(cachedItem.resource)\n        cache.delete(key)\n      }\n    }\n    // We assume the `dispose` function is stable and won't change across renders\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [key])\n\n  keyRef.current = key\n\n  return resource\n}\n\n// NOTE Given `useMemo` will be called multiple times (e.g. when using React Strict mode or Fast Refresh),\n// we are using this cache to avoid starting multiple queries/spans for the same component.\n// This is somewhat against some recommended React best practices, but it should be fine in our case below.\n// Please definitely open an issue if you see or run into any problems with this approach!\nconst cache = new Map<\n  string,\n  | {\n      _tag: 'active'\n      rc: number\n      resource: any\n    }\n  | {\n      _tag: 'destroyed'\n    }\n>()\n\nexport const __resetUseRcResourceCache = () => {\n  cache.clear()\n}\n", "import { extractStackInfoFromStackTrace, type StackInfo } from '@livestore/livestore'\nimport React from 'react'\n\nexport const originalStackLimit = Error.stackTraceLimit\n\nexport const useStackInfo = (): StackInfo =>\n  React.useMemo(() => {\n    Error.stackTraceLimit = 10\n    // eslint-disable-next-line unicorn/error-message\n    const stack = new Error().stack!\n    Error.stackTraceLimit = originalStackLimit\n    return extractStackInfoFromStackTrace(stack)\n  }, [])\n", "import React from 'react'\n\n/**\n * A variant of `React.useState` which allows the `inputState` to change over time as well.\n * Important: This hook is synchronous / single-render-pass (i.e. doesn't use `useEffect` or `setState` directly).\n *\n * Notes:\n * - The output state is always reset to the input state in case the input state changes (i.e. the previous \"external\" `setStateAndRerender` call is forgotten)\n * - This hook might not work properly with React Suspense\n * - Also see this Tweet for more potential problems: https://twitter.com/schickling/status/1677317711104278528\n *\n */\nexport const useStateRefWithReactiveInput = <T>(\n  inputState: T,\n): [React.RefObject<T>, (newState: T | ((prev: T) => T)) => void] => {\n  const [_, rerender] = React.useState(0)\n\n  const lastKnownInputStateRef = React.useRef<T>(inputState)\n  const stateRef = React.useRef<T>(inputState)\n\n  if (lastKnownInputStateRef.current !== inputState) {\n    lastKnownInputStateRef.current = inputState\n\n    // NOTE we don't need to re-render here, because the component is already re-rendering due to the `inputState` change\n    stateRef.current = inputState\n  }\n\n  const setStateAndRerender = React.useCallback(\n    (newState: ((prev: T) => T) | T) => {\n      // @ts-expect-error https://github.com/microsoft/TypeScript/issues/37663\n      const val = typeof newState === 'function' ? newState(stateRef.current) : newState\n      stateRef.current = val\n      rerender((c) => c + 1)\n    },\n    [rerender],\n  )\n\n  return [stateRef, setStateAndRerender]\n}\n\n// Down-side of this implementation: Double render pass due to `setState` call (which forces a re-render)\n// Keeping around for now in case `useStateRefWithReactiveInput` doesn't work out\n// const _useStateWithReactiveInput = <T>(inputState: T): [T, (newState: T | ((prev: T) => T)) => void] => {\n//   const [externalState, setExternalState] = React.useState(inputState)\n\n//   if (externalState !== inputState) {\n//     setExternalState(inputState)\n//   }\n\n//   return [externalState, setExternalState]\n// }\n", "import type { Adapter, BootStatus, IntentionalShutdownCause, MigrationsReport } from '@livestore/common'\nimport { provideOtel, UnexpectedError } from '@livestore/common'\nimport type { LiveStoreSchema } from '@livestore/common/schema'\nimport type {\n  CreateStoreOptions,\n  LiveStoreContext as StoreContext_,\n  OtelOptions,\n  ShutdownDeferred,\n  Store,\n} from '@livestore/livestore'\nimport { createStore, makeShutdownDeferred, StoreInterrupted } from '@livestore/livestore'\nimport { errorToString, IS_REACT_NATIVE, LS_DEV } from '@livestore/utils'\nimport type { OtelTracer } from '@livestore/utils/effect'\nimport {\n  Cause,\n  Deferred,\n  Effect,\n  Exit,\n  identity,\n  Logger,\n  LogLevel,\n  Schema,\n  Scope,\n  TaskTracing,\n} from '@livestore/utils/effect'\nimport type * as otel from '@opentelemetry/api'\nimport type { ReactElement, ReactNode } from 'react'\nimport React from 'react'\n\nimport { LiveStoreContext } from './LiveStoreContext.js'\n\nexport interface LiveStoreProviderProps {\n  schema: LiveStoreSchema\n  /**\n   * The `storeId` can be used to isolate multiple stores from each other.\n   * So it can be useful for multi-tenancy scenarios.\n   *\n   * The `storeId` is also used for persistence.\n   *\n   * Make sure to also configure `storeId` in LiveStore Devtools (e.g. in Vite plugin).\n   *\n   * @default 'default'\n   */\n  storeId?: string\n  boot?: (\n    store: Store<LiveStoreSchema>,\n    ctx: { migrationsReport: MigrationsReport; parentSpan: otel.Span },\n  ) => void | Promise<void> | Effect.Effect<void, unknown, OtelTracer.OtelTracer>\n  otelOptions?: Partial<OtelOptions>\n  renderLoading?: (status: BootStatus) => ReactElement\n  renderError?: (error: UnexpectedError | unknown) => ReactElement\n  renderShutdown?: (cause: IntentionalShutdownCause | StoreInterrupted) => ReactElement\n  adapter: Adapter\n  /**\n   * In order for LiveStore to apply multiple events in a single render,\n   * you need to pass the `batchUpdates` function from either `react-dom` or `react-native`.\n   *\n   * ```ts\n   * // With React DOM\n   * import { unstable_batchedUpdates as batchUpdates } from 'react-dom'\n   *\n   * // With React Native\n   * import { unstable_batchedUpdates as batchUpdates } from 'react-native'\n   * ```\n   */\n  batchUpdates: (run: () => void) => void\n  disableDevtools?: boolean\n  signal?: AbortSignal\n  /**\n   * Currently only used in the web adapter:\n   * If true, registers a beforeunload event listener to confirm unsaved changes.\n   *\n   * @default true\n   */\n  confirmUnsavedChanges?: boolean\n  /**\n   * Payload that will be passed to the sync backend when connecting\n   *\n   * @default undefined\n   */\n  syncPayload?: Schema.JsonValue\n  debug?: {\n    instanceId?: string\n  }\n}\n\nconst defaultRenderError = (error: UnexpectedError | unknown) =>\n  IS_REACT_NATIVE ? <></> : <>{Schema.is(UnexpectedError)(error) ? error.toString() : errorToString(error)}</>\n\nconst defaultRenderShutdown = (cause: IntentionalShutdownCause | StoreInterrupted) => {\n  const reason =\n    cause._tag === 'LiveStore.StoreInterrupted'\n      ? `interrupted due to: ${cause.reason}`\n      : cause.reason === 'devtools-import'\n        ? 'devtools import'\n        : cause.reason === 'devtools-reset'\n          ? 'devtools reset'\n          : cause.reason === 'adapter-reset'\n            ? 'adapter reset'\n            : cause.reason === 'manual'\n              ? 'manual shutdown'\n              : 'unknown reason'\n\n  return IS_REACT_NATIVE ? <></> : <>LiveStore Shutdown due to {reason}</>\n}\n\nconst defaultRenderLoading = (status: BootStatus) =>\n  IS_REACT_NATIVE ? <></> : <>LiveStore is loading ({status.stage})...</>\n\nexport const LiveStoreProvider = ({\n  renderLoading = defaultRenderLoading,\n  renderError = defaultRenderError,\n  renderShutdown = defaultRenderShutdown,\n  otelOptions,\n  children,\n  schema,\n  storeId = 'default',\n  boot,\n  adapter,\n  batchUpdates,\n  disableDevtools,\n  signal,\n  confirmUnsavedChanges = true,\n  syncPayload,\n  debug,\n}: LiveStoreProviderProps & { children?: ReactNode }): React.ReactElement => {\n  const storeCtx = useCreateStore({\n    storeId,\n    schema,\n    otelOptions,\n    boot,\n    adapter,\n    batchUpdates,\n    disableDevtools,\n    signal,\n    confirmUnsavedChanges,\n    syncPayload,\n    debug,\n  })\n\n  if (storeCtx.stage === 'error') {\n    return renderError(storeCtx.error)\n  }\n\n  if (storeCtx.stage === 'shutdown') {\n    return renderShutdown(storeCtx.cause)\n  }\n\n  if (storeCtx.stage !== 'running') {\n    return renderLoading(storeCtx)\n  }\n\n  globalThis.__debugLiveStore ??= {}\n  if (Object.keys(globalThis.__debugLiveStore).length === 0) {\n    globalThis.__debugLiveStore['_'] = storeCtx.store\n  }\n  globalThis.__debugLiveStore[debug?.instanceId ?? storeId] = storeCtx.store\n\n  return <LiveStoreContext.Provider value={storeCtx as TODO}>{children}</LiveStoreContext.Provider>\n}\n\nconst useCreateStore = ({\n  schema,\n  storeId,\n  otelOptions,\n  boot,\n  adapter,\n  batchUpdates,\n  disableDevtools,\n  signal,\n  context,\n  params,\n  confirmUnsavedChanges,\n  syncPayload,\n  debug,\n}: CreateStoreOptions<LiveStoreSchema> & {\n  signal?: AbortSignal\n  otelOptions?: Partial<OtelOptions>\n}) => {\n  const [_, rerender] = React.useState(0)\n  const ctxValueRef = React.useRef<{\n    value: StoreContext_ | BootStatus\n    componentScope: Scope.CloseableScope | undefined\n    shutdownDeferred: ShutdownDeferred | undefined\n    /** Used to wait for the previous shutdown deferred to fully complete before creating a new one */\n    previousShutdownDeferred: ShutdownDeferred | undefined\n    counter: number\n  }>({\n    value: { stage: 'loading' },\n    componentScope: undefined,\n    shutdownDeferred: undefined,\n    previousShutdownDeferred: undefined,\n    counter: 0,\n  })\n  const debugInstanceId = debug?.instanceId\n\n  // console.debug(`useCreateStore (${ctxValueRef.current.counter})`, ctxValueRef.current.value.stage)\n\n  const inputPropsCacheRef = React.useRef({\n    schema,\n    otelOptions,\n    boot,\n    adapter,\n    batchUpdates,\n    disableDevtools,\n    signal,\n    context,\n    params,\n    confirmUnsavedChanges,\n    syncPayload,\n    debugInstanceId,\n  })\n\n  const interrupt = (\n    componentScope: Scope.CloseableScope,\n    shutdownDeferred: ShutdownDeferred,\n    error: StoreInterrupted,\n  ) =>\n    Effect.gen(function* () {\n      // console.log('[@livestore/livestore/react] interupting', error)\n      yield* Scope.close(componentScope, Exit.fail(error))\n      yield* Deferred.fail(shutdownDeferred, error)\n    }).pipe(\n      Effect.tapErrorCause((cause) => Effect.logDebug('[@livestore/livestore/react] interupting', cause)),\n      Effect.runFork,\n    )\n\n  const inputPropChanges = {\n    schema: inputPropsCacheRef.current.schema !== schema,\n    otelOptions: inputPropsCacheRef.current.otelOptions !== otelOptions,\n    boot: inputPropsCacheRef.current.boot !== boot,\n    adapter: inputPropsCacheRef.current.adapter !== adapter,\n    batchUpdates: inputPropsCacheRef.current.batchUpdates !== batchUpdates,\n    disableDevtools: inputPropsCacheRef.current.disableDevtools !== disableDevtools,\n    signal: inputPropsCacheRef.current.signal !== signal,\n    context: inputPropsCacheRef.current.context !== context,\n    params: inputPropsCacheRef.current.params !== params,\n    confirmUnsavedChanges: inputPropsCacheRef.current.confirmUnsavedChanges !== confirmUnsavedChanges,\n    syncPayload: inputPropsCacheRef.current.syncPayload !== syncPayload,\n    debugInstanceId: inputPropsCacheRef.current.debugInstanceId !== debugInstanceId,\n  }\n\n  if (\n    inputPropChanges.schema ||\n    inputPropChanges.otelOptions ||\n    inputPropChanges.boot ||\n    inputPropChanges.adapter ||\n    inputPropChanges.batchUpdates ||\n    inputPropChanges.disableDevtools ||\n    inputPropChanges.signal ||\n    inputPropChanges.context ||\n    inputPropChanges.params ||\n    inputPropChanges.confirmUnsavedChanges ||\n    inputPropChanges.syncPayload\n  ) {\n    inputPropsCacheRef.current = {\n      schema,\n      otelOptions,\n      boot,\n      adapter,\n      batchUpdates,\n      disableDevtools,\n      signal,\n      context,\n      params,\n      confirmUnsavedChanges,\n      syncPayload,\n      debugInstanceId,\n    }\n    if (ctxValueRef.current.componentScope !== undefined && ctxValueRef.current.shutdownDeferred !== undefined) {\n      const changedInputProps = Object.keys(inputPropChanges).filter(\n        (key) => inputPropChanges[key as keyof typeof inputPropChanges],\n      )\n\n      interrupt(\n        ctxValueRef.current.componentScope,\n        ctxValueRef.current.shutdownDeferred,\n        new StoreInterrupted({ reason: `re-rendering due to changed input props: ${changedInputProps.join(', ')}` }),\n      )\n      ctxValueRef.current.componentScope = undefined\n      ctxValueRef.current.shutdownDeferred = undefined\n    }\n    ctxValueRef.current = {\n      value: { stage: 'loading' },\n      componentScope: undefined,\n      shutdownDeferred: undefined,\n      previousShutdownDeferred: ctxValueRef.current.shutdownDeferred,\n      counter: ctxValueRef.current.counter + 1,\n    }\n  }\n\n  React.useEffect(() => {\n    const counter = ctxValueRef.current.counter\n\n    const setContextValue = (value: StoreContext_ | BootStatus) => {\n      if (ctxValueRef.current.counter !== counter) return\n      ctxValueRef.current.value = value\n      rerender((c) => c + 1)\n    }\n\n    signal?.addEventListener('abort', () => {\n      if (\n        ctxValueRef.current.componentScope !== undefined &&\n        ctxValueRef.current.shutdownDeferred !== undefined &&\n        ctxValueRef.current.counter === counter\n      ) {\n        interrupt(\n          ctxValueRef.current.componentScope,\n          ctxValueRef.current.shutdownDeferred,\n          new StoreInterrupted({ reason: 'Aborted via provided AbortController' }),\n        )\n        ctxValueRef.current.componentScope = undefined\n        ctxValueRef.current.shutdownDeferred = undefined\n      }\n    })\n\n    const cancel = Effect.gen(function* () {\n      // Wait for the previous store to fully shutdown before creating a new one\n      if (ctxValueRef.current.previousShutdownDeferred) {\n        yield* Deferred.await(ctxValueRef.current.previousShutdownDeferred)\n      }\n\n      const componentScope = yield* Scope.make().pipe(Effect.acquireRelease(Scope.close))\n      const shutdownDeferred = yield* makeShutdownDeferred\n\n      ctxValueRef.current.componentScope = componentScope\n      ctxValueRef.current.shutdownDeferred = shutdownDeferred\n\n      yield* Effect.gen(function* () {\n        const store = yield* createStore({\n          schema,\n          storeId,\n          boot,\n          adapter,\n          batchUpdates,\n          disableDevtools,\n          shutdownDeferred,\n          context,\n          params,\n          confirmUnsavedChanges,\n          syncPayload,\n          onBootStatus: (status) => {\n            if (ctxValueRef.current.value.stage === 'running' || ctxValueRef.current.value.stage === 'error') return\n            // NOTE sometimes when status come in in rapid succession, only the last value will be rendered by React\n            setContextValue(status)\n          },\n          debug: { instanceId: debugInstanceId },\n        }).pipe(Effect.tapErrorCause((cause) => Deferred.failCause(shutdownDeferred, cause)))\n\n        setContextValue({ stage: 'running', store })\n      }).pipe(Scope.extend(componentScope), Effect.forkIn(componentScope))\n\n      const shutdownContext = (cause: IntentionalShutdownCause | StoreInterrupted) =>\n        Effect.sync(() => setContextValue({ stage: 'shutdown', cause }))\n\n      yield* Deferred.await(shutdownDeferred).pipe(\n        Effect.tapErrorCause((cause) => Effect.logDebug('[@livestore/livestore/react] shutdown', Cause.pretty(cause))),\n        Effect.catchTag('LiveStore.IntentionalShutdownCause', (cause) => shutdownContext(cause)),\n        Effect.catchTag('LiveStore.StoreInterrupted', (cause) => shutdownContext(cause)),\n        Effect.tapError((error) => Effect.sync(() => setContextValue({ stage: 'error', error }))),\n        Effect.tapDefect((defect) => Effect.sync(() => setContextValue({ stage: 'error', error: defect }))),\n        Effect.exit,\n      )\n    }).pipe(\n      Effect.scoped,\n      Effect.withSpan('@livestore/react:useCreateStore'),\n      LS_DEV ? TaskTracing.withAsyncTaggingTracing((name: string) => (console as any).createTask(name)) : identity,\n      provideOtel({ parentSpanContext: otelOptions?.rootSpanContext, otelTracer: otelOptions?.tracer }),\n      Effect.tapCauseLogPretty,\n      Effect.annotateLogs({ thread: 'window' }),\n      Effect.provide(Logger.prettyWithThread('window')),\n      Logger.withMinimumLogLevel(LogLevel.Debug),\n      Effect.runCallback,\n    )\n\n    return () => {\n      cancel()\n\n      if (ctxValueRef.current.componentScope !== undefined && ctxValueRef.current.shutdownDeferred !== undefined) {\n        interrupt(\n          ctxValueRef.current.componentScope,\n          ctxValueRef.current.shutdownDeferred,\n          new StoreInterrupted({ reason: 'unmounting component' }),\n        )\n        ctxValueRef.current.componentScope = undefined\n        ctxValueRef.current.shutdownDeferred = undefined\n      }\n    }\n  }, [\n    schema,\n    otelOptions,\n    boot,\n    adapter,\n    batchUpdates,\n    disableDevtools,\n    signal,\n    storeId,\n    context,\n    params,\n    confirmUnsavedChanges,\n    syncPayload,\n    debugInstanceId,\n  ])\n\n  return ctxValueRef.current.value\n}\n"],
  "mappings": "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",
  "names": ["React", "import_react", "import_react", "import_react", "React", "cachedItem", "resource", "import_react", "React", "import_react", "React", "React", "span", "otelContext", "queryRcRef", "React", "React", "import_react", "_jsx", "_Fragment", "_jsxs", "context", "React"]
}

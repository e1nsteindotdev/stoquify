import {
  Deferred_exports,
  Effect_exports,
  EventSequenceNumber_exports,
  InvalidPullError,
  InvalidPushError,
  LS_DEV,
  LiveStoreEvent_exports,
  Option_exports,
  PubSub_exports,
  Queue_exports,
  Schedule_exports,
  Schema_exports,
  Stream_exports,
  SubscriptionRef_exports,
  UnexpectedError,
  UrlParams_exports,
  WebSocket_exports,
  nanoid,
  shouldNeverHappen
} from "./chunk-J7UPD3II.js";
import {
  __export
} from "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/@livestore+sync-cf@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/sync-cf/dist/common/ws-message-types.js
var ws_message_types_exports = {};
__export(ws_message_types_exports, {
  AdminInfoReq: () => AdminInfoReq,
  AdminInfoRes: () => AdminInfoRes,
  AdminResetRoomReq: () => AdminResetRoomReq,
  AdminResetRoomRes: () => AdminResetRoomRes,
  BackendToClientMessage: () => BackendToClientMessage,
  ClientToBackendMessage: () => ClientToBackendMessage,
  Error: () => Error,
  Message: () => Message,
  Ping: () => Ping,
  Pong: () => Pong,
  PullReq: () => PullReq,
  PullRes: () => PullRes,
  PushAck: () => PushAck,
  PushReq: () => PushReq,
  SyncMetadata: () => SyncMetadata
});
var PullReq = Schema_exports.TaggedStruct("WSMessage.PullReq", {
  requestId: Schema_exports.String,
  /** Omitting the cursor will start from the beginning */
  cursor: Schema_exports.optional(Schema_exports.Number)
}).annotations({ title: "@livestore/sync-cf:PullReq" });
var SyncMetadata = Schema_exports.Struct({
  /** ISO date format */
  createdAt: Schema_exports.String
}).annotations({ title: "@livestore/sync-cf:SyncMetadata" });
var PullRes = Schema_exports.TaggedStruct("WSMessage.PullRes", {
  batch: Schema_exports.Array(Schema_exports.Struct({
    eventEncoded: LiveStoreEvent_exports.AnyEncodedGlobal,
    metadata: Schema_exports.Option(SyncMetadata)
  })),
  requestId: Schema_exports.Struct({ context: Schema_exports.Literal("pull", "push"), requestId: Schema_exports.String }),
  remaining: Schema_exports.Number
}).annotations({ title: "@livestore/sync-cf:PullRes" });
var PushReq = Schema_exports.TaggedStruct("WSMessage.PushReq", {
  requestId: Schema_exports.String,
  batch: Schema_exports.Array(LiveStoreEvent_exports.AnyEncodedGlobal)
}).annotations({ title: "@livestore/sync-cf:PushReq" });
var PushAck = Schema_exports.TaggedStruct("WSMessage.PushAck", {
  requestId: Schema_exports.String
}).annotations({ title: "@livestore/sync-cf:PushAck" });
var Error = Schema_exports.TaggedStruct("WSMessage.Error", {
  requestId: Schema_exports.String,
  message: Schema_exports.String
}).annotations({ title: "@livestore/sync-cf:Error" });
var Ping = Schema_exports.TaggedStruct("WSMessage.Ping", {
  requestId: Schema_exports.Literal("ping")
}).annotations({ title: "@livestore/sync-cf:Ping" });
var Pong = Schema_exports.TaggedStruct("WSMessage.Pong", {
  requestId: Schema_exports.Literal("ping")
}).annotations({ title: "@livestore/sync-cf:Pong" });
var AdminResetRoomReq = Schema_exports.TaggedStruct("WSMessage.AdminResetRoomReq", {
  requestId: Schema_exports.String,
  adminSecret: Schema_exports.String
}).annotations({ title: "@livestore/sync-cf:AdminResetRoomReq" });
var AdminResetRoomRes = Schema_exports.TaggedStruct("WSMessage.AdminResetRoomRes", {
  requestId: Schema_exports.String
}).annotations({ title: "@livestore/sync-cf:AdminResetRoomRes" });
var AdminInfoReq = Schema_exports.TaggedStruct("WSMessage.AdminInfoReq", {
  requestId: Schema_exports.String,
  adminSecret: Schema_exports.String
}).annotations({ title: "@livestore/sync-cf:AdminInfoReq" });
var AdminInfoRes = Schema_exports.TaggedStruct("WSMessage.AdminInfoRes", {
  requestId: Schema_exports.String,
  info: Schema_exports.Struct({
    durableObjectId: Schema_exports.String
  })
}).annotations({ title: "@livestore/sync-cf:AdminInfoRes" });
var Message = Schema_exports.Union(PullReq, PullRes, PushReq, PushAck, Error, Ping, Pong, AdminResetRoomReq, AdminResetRoomRes, AdminInfoReq, AdminInfoRes).annotations({ title: "@livestore/sync-cf:Message" });
var BackendToClientMessage = Schema_exports.Union(PullRes, PushAck, AdminResetRoomRes, AdminInfoRes, Error, Pong);
var ClientToBackendMessage = Schema_exports.Union(PullReq, PushReq, AdminResetRoomReq, AdminInfoReq, Ping);

// node_modules/.pnpm/@livestore+sync-cf@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/sync-cf/dist/common/mod.js
var SearchParamsSchema = Schema_exports.Struct({
  storeId: Schema_exports.String,
  payload: Schema_exports.compose(Schema_exports.StringFromUriComponent, Schema_exports.parseJson(Schema_exports.JsonValue)).pipe(Schema_exports.UndefinedOr)
});

// node_modules/.pnpm/@livestore+sync-cf@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/sync-cf/dist/sync-impl/ws-impl.js
var makeCfSync = (options) => ({ storeId, payload }) => Effect_exports.gen(function* () {
  const urlParamsData = yield* Schema_exports.encode(SearchParamsSchema)({
    storeId,
    payload
  }).pipe(UnexpectedError.mapToUnexpectedError);
  const urlParams = UrlParams_exports.fromInput(urlParamsData);
  const wsUrl = `${options.url}/websocket?${UrlParams_exports.toString(urlParams)}`;
  const { isConnected, incomingMessages, send } = yield* connect(wsUrl);
  const stashedPullBatch = [];
  let pullStarted = false;
  const api = {
    isConnected,
    // Currently we're already eagerly connecting when the sync backend is created but we might want to refactor this later to clean this up
    connect: Effect_exports.void,
    pull: (args) => Effect_exports.gen(function* () {
      var _a;
      if (pullStarted) {
        return shouldNeverHappen(`Pull already started for this sync backend.`);
      }
      pullStarted = true;
      let pullResponseReceived = false;
      const requestId = nanoid();
      const cursor = (_a = Option_exports.getOrUndefined(args)) == null ? void 0 : _a.cursor.global;
      yield* send(ws_message_types_exports.PullReq.make({ cursor, requestId }));
      return Stream_exports.fromPubSub(incomingMessages).pipe(Stream_exports.tap((_) => _._tag === "WSMessage.Error" && _.requestId === requestId ? new InvalidPullError({ message: _.message }) : Effect_exports.void), Stream_exports.filterMap((msg) => {
        var _a2;
        if (msg._tag === "WSMessage.PullRes") {
          if (msg.requestId.context === "pull") {
            if (msg.requestId.requestId === requestId) {
              pullResponseReceived = true;
              if (stashedPullBatch.length > 0 && msg.remaining === 0) {
                const pullResHead = ((_a2 = msg.batch.at(-1)) == null ? void 0 : _a2.eventEncoded.seqNum) ?? EventSequenceNumber_exports.ROOT.global;
                const newPartialBatchIndex = stashedPullBatch.findIndex((batchItem) => batchItem.eventEncoded.seqNum > pullResHead);
                const batchWithNewStashedEvents = newPartialBatchIndex === -1 ? [] : stashedPullBatch.slice(newPartialBatchIndex);
                const combinedBatch = [...msg.batch, ...batchWithNewStashedEvents];
                return Option_exports.some({ ...msg, batch: combinedBatch, remaining: 0 });
              } else {
                return Option_exports.some(msg);
              }
            } else {
              return Option_exports.none();
            }
          } else {
            if (pullResponseReceived) {
              return Option_exports.some(msg);
            } else {
              stashedPullBatch.push(...msg.batch);
              return Option_exports.none();
            }
          }
        }
        return Option_exports.none();
      }));
    }).pipe(Stream_exports.unwrap),
    push: (batch) => Effect_exports.gen(function* () {
      const pushAck = yield* Deferred_exports.make();
      const requestId = nanoid();
      yield* Stream_exports.fromPubSub(incomingMessages).pipe(Stream_exports.tap((_) => _._tag === "WSMessage.Error" && _.requestId === requestId ? Deferred_exports.fail(pushAck, new InvalidPushError({ reason: { _tag: "Unexpected", message: _.message } })) : Effect_exports.void), Stream_exports.filter((_) => _._tag === "WSMessage.PushAck" && _.requestId === requestId), Stream_exports.take(1), Stream_exports.tap(() => Deferred_exports.succeed(pushAck, void 0)), Stream_exports.runDrain, Effect_exports.tapCauseLogPretty, Effect_exports.fork);
      yield* send(ws_message_types_exports.PushReq.make({ batch, requestId }));
      yield* pushAck;
    }),
    metadata: {
      name: "@livestore/cf-sync",
      description: "LiveStore sync backend implementation using Cloudflare Workers & Durable Objects",
      protocol: "ws",
      url: options.url
    }
  };
  return api;
});
var connect = (wsUrl) => Effect_exports.gen(function* () {
  const isConnected = yield* SubscriptionRef_exports.make(false);
  const socketRef = { current: void 0 };
  const incomingMessages = yield* PubSub_exports.unbounded().pipe(Effect_exports.acquireRelease(PubSub_exports.shutdown));
  const waitUntilOnline = isConnected.changes.pipe(Stream_exports.filter(Boolean), Stream_exports.take(1), Stream_exports.runDrain);
  const send = (message) => Effect_exports.gen(function* () {
    yield* waitUntilOnline;
    socketRef.current.send(Schema_exports.encodeSync(Schema_exports.parseJson(ws_message_types_exports.Message))(message));
    if (LS_DEV) {
      yield* Effect_exports.spanEvent(`Sent message: ${message._tag}`, message._tag === "WSMessage.PushReq" ? {
        seqNum: message.batch[0].seqNum,
        parentSeqNum: message.batch[0].parentSeqNum,
        batchLength: message.batch.length
      } : message._tag === "WSMessage.PullReq" ? { cursor: message.cursor ?? "-" } : {});
    }
  });
  const innerConnect = Effect_exports.gen(function* () {
    while (typeof navigator !== "undefined" && navigator.onLine === false) {
      yield* Effect_exports.sleep(1e3);
    }
    const socket = yield* WebSocket_exports.makeWebSocket({ url: wsUrl, reconnect: Schedule_exports.exponential(100) });
    yield* SubscriptionRef_exports.set(isConnected, true);
    socketRef.current = socket;
    const connectionClosed = yield* Deferred_exports.make();
    const pongMessages = yield* Queue_exports.unbounded().pipe(Effect_exports.acquireRelease(Queue_exports.shutdown));
    yield* Effect_exports.eventListener(socket, "message", (event) => Effect_exports.gen(function* () {
      const decodedEventRes = Schema_exports.decodeUnknownEither(Schema_exports.parseJson(ws_message_types_exports.BackendToClientMessage))(event.data);
      if (decodedEventRes._tag === "Left") {
        console.error("Sync: Invalid message received", decodedEventRes.left);
        return;
      } else {
        if (decodedEventRes.right._tag === "WSMessage.Pong") {
          yield* Queue_exports.offer(pongMessages, decodedEventRes.right);
        } else {
          yield* PubSub_exports.publish(incomingMessages, decodedEventRes.right);
        }
      }
    }));
    yield* Effect_exports.eventListener(socket, "close", () => Deferred_exports.succeed(connectionClosed, void 0));
    yield* Effect_exports.eventListener(socket, "error", () => Effect_exports.gen(function* () {
      socket.close(3e3, "Sync: WebSocket error");
      yield* Deferred_exports.succeed(connectionClosed, void 0);
    }));
    if (typeof self !== "undefined" && typeof self.addEventListener === "function") {
      yield* Effect_exports.eventListener(self, "offline", () => Deferred_exports.succeed(connectionClosed, void 0));
    }
    yield* Effect_exports.addFinalizer(() => Effect_exports.gen(function* () {
      socketRef.current = void 0;
      yield* SubscriptionRef_exports.set(isConnected, false);
    }));
    const checkPingPong = Effect_exports.gen(function* () {
      yield* send({ _tag: "WSMessage.Ping", requestId: "ping" });
      yield* Queue_exports.take(pongMessages).pipe(Effect_exports.timeout(5e3));
      yield* Effect_exports.sleep(25e3);
    }).pipe(Effect_exports.withSpan("@livestore/sync-cf:connect:checkPingPong"), Effect_exports.ignore);
    yield* waitUntilOnline.pipe(Effect_exports.andThen(checkPingPong.pipe(Effect_exports.forever)), Effect_exports.tapErrorCause(() => Deferred_exports.succeed(connectionClosed, void 0)), Effect_exports.forkScoped);
    yield* connectionClosed;
  }).pipe(Effect_exports.scoped, Effect_exports.withSpan("@livestore/sync-cf:connect"));
  yield* innerConnect.pipe(Effect_exports.forever, Effect_exports.interruptible, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  return { isConnected, incomingMessages, send };
});
export {
  makeCfSync
};
//# sourceMappingURL=@livestore_sync-cf.js.map

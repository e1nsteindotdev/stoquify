{
  "version": 3,
  "sources": ["../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/reactive.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/live-queries/base-class.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/live-queries/client-document-get-query.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/QueryCache.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/SqliteDbWrapper.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/utils/data-structures.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/utils/dev.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/store/store.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/store/devtools.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/store/create-store.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/store/store-types.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/utils/function-string.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/live-queries/computed.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/live-queries/db-query.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/live-queries/signal.ts", "../../.pnpm/@livestore+livestore@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/livestore/src/utils/stack-info.ts"],
  "sourcesContent": ["// This is a simple implementation of a reactive dependency graph.\n\n// Key Terminology:\n// Ref: a mutable cell where values can be set\n// Thunk: a pure computation that depends on other values\n// Effect: a side effect that runs when a value changes; return value is ignored\n// Atom: a node returning a value that can be depended on: Ref | Thunk\n\n// Super computation: Nodes that depend on a given node (\"downstream\")\n// Sub computation: Nodes that a given node depends on (\"upstream\")\n\n// This vocabulary comes from the MiniAdapton paper linked below, although\n// we don't actually implement the MiniAdapton algorithm because we don't need lazy recomputation.\n// https://arxiv.org/abs/1609.05337\n\n// Features:\n// - Dependencies are tracked automatically in thunk computations by using a getter function\n//   to reference other atoms.\n// - Whenever a ref is updated, the graph is eagerly refreshed to be consistent with the new values.\n// - We minimize recomputation by refreshing the graph in topological sort order. (The topological height\n//   is maintained eagerly as edges are added and removed.)\n// - At every thunk we check value equality with the previous value and cutoff propagation if possible.\n\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n\nimport { BoundArray } from '@livestore/common'\nimport { deepEqual, shouldNeverHappen } from '@livestore/utils'\nimport type { Types } from '@livestore/utils/effect'\nimport type * as otel from '@opentelemetry/api'\n// import { getDurationMsFromSpan } from './otel.js'\n\nexport const NOT_REFRESHED_YET = Symbol.for('NOT_REFRESHED_YET')\nexport type NOT_REFRESHED_YET = typeof NOT_REFRESHED_YET\n\nexport type GetAtom = <T>(\n  atom: Atom<T, any, any>,\n  otelContext?: otel.Context | undefined,\n  debugRefreshReason?: TODO | undefined,\n) => T\n\nexport type Ref<T, TContext, TDebugRefreshReason extends DebugRefreshReason> = {\n  _tag: 'ref'\n  id: string\n  isDirty: false\n  isDestroyed: boolean\n  previousResult: T\n  computeResult: () => T\n  sub: Set<Atom<any, TContext, TDebugRefreshReason>> // always empty\n  super: Set<Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>>\n  label?: string\n  /** Container for meta information (e.g. the LiveStore Store) */\n  meta?: any\n  equal: (a: T, b: T) => boolean\n  refreshes: number\n}\n\nexport type Thunk<TResult, TContext, TDebugRefreshReason extends DebugRefreshReason> = {\n  _tag: 'thunk'\n  id: string\n  isDirty: boolean\n  isDestroyed: boolean\n  computeResult: (otelContext?: otel.Context, debugRefreshReason?: TDebugRefreshReason) => TResult\n  previousResult: TResult | NOT_REFRESHED_YET\n  sub: Set<Atom<any, TContext, TDebugRefreshReason>>\n  super: Set<Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>>\n  label?: string\n  /** Container for meta information (e.g. the LiveStore Store) */\n  meta?: any\n  equal: (a: TResult, b: TResult) => boolean\n  recomputations: number\n\n  __getResult: any\n}\n\nexport type Atom<T, TContext, TDebugRefreshReason extends DebugRefreshReason> =\n  | Ref<T, TContext, TDebugRefreshReason>\n  | Thunk<T, TContext, TDebugRefreshReason>\n\nexport type Effect<TDebugRefreshReason extends DebugRefreshReason> = {\n  _tag: 'effect'\n  id: string\n  isDestroyed: boolean\n  doEffect: (otelContext?: otel.Context | undefined, debugRefreshReason?: TDebugRefreshReason | undefined) => void\n  sub: Set<Atom<any, TODO, TODO>>\n  label?: string\n  invocations: number\n}\n\nexport type Node<T, TContext, TDebugRefreshReason extends DebugRefreshReason> =\n  | Atom<T, TContext, TDebugRefreshReason>\n  | Effect<TDebugRefreshReason>\n\nexport const isThunk = <T, TContext, TDebugRefreshReason extends DebugRefreshReason>(\n  obj: unknown,\n): obj is Thunk<T, TContext, TDebugRefreshReason> => {\n  return typeof obj === 'object' && obj !== null && '_tag' in obj && (obj as any)._tag === 'thunk'\n}\n\nexport type DebugThunkInfo<T extends string = string> = {\n  _tag: T\n  durationMs: number\n}\n\nexport type DebugRefreshReasonBase =\n  /** Usually in response to some `commit` calls with `skipRefresh: true` */\n  | {\n      _tag: 'runDeferredEffects'\n      originalRefreshReasons?: ReadonlyArray<DebugRefreshReasonBase>\n      manualRefreshReason?: DebugRefreshReasonBase\n    }\n  | { _tag: 'makeThunk'; label?: string }\n  | { _tag: 'unknown' }\n\nexport type DebugRefreshReason<T extends string = string> = DebugRefreshReasonBase | { _tag: T }\n\nexport type AtomDebugInfo<TDebugThunkInfo extends DebugThunkInfo> = {\n  atom: SerializedAtom\n  resultChanged: boolean\n  debugInfo: TDebugThunkInfo\n}\n\n// TODO possibly find a better name for \"refresh\"\nexport type RefreshDebugInfo<TDebugRefreshReason extends DebugRefreshReason, TDebugThunkInfo extends DebugThunkInfo> = {\n  /** Currently only used for easier handling in React (e.g. as key) */\n  id: string\n  reason: TDebugRefreshReason\n  refreshedAtoms: AtomDebugInfo<TDebugThunkInfo>[]\n  skippedRefresh: boolean\n  durationMs: number\n  /** Note we're using a regular `Date.now()` timestamp here as it's faster to produce and we don't need the fine accuracy */\n  completedTimestamp: number\n  graphSnapshot: ReactiveGraphSnapshot\n}\n\nconst unknownRefreshReason = () => {\n  // debugger\n  return { _tag: 'unknown' as const }\n}\n\nexport type EncodedOption<A> = { _tag: 'Some'; value?: A } | { _tag: 'None' }\nconst encodedOptionSome = <A>(value: A): EncodedOption<A> => ({ _tag: 'Some', value })\nconst encodedOptionNone = <A>(): EncodedOption<A> => ({ _tag: 'None' })\n\nexport type SerializedAtom = SerializedRef | SerializedThunk\n\nexport type SerializedRef = Readonly<\n  Types.Simplify<\n    Pick<Ref<unknown, unknown, any>, '_tag' | 'id' | 'label' | 'meta' | 'isDirty' | 'isDestroyed' | 'refreshes'> & {\n      /** Is `None` if `getSnapshot` was called with `includeResults: false` which is the default */\n      previousResult: EncodedOption<string>\n      sub: ReadonlyArray<string>\n      super: ReadonlyArray<string>\n    }\n  >\n>\n\nexport type SerializedThunk = Readonly<\n  Types.Simplify<\n    Pick<\n      Thunk<unknown, unknown, any>,\n      '_tag' | 'id' | 'label' | 'meta' | 'isDirty' | 'isDestroyed' | 'recomputations'\n    > & {\n      /** Is `None` if `getSnapshot` was called with `includeResults: false` which is the default */\n      previousResult: EncodedOption<string>\n      sub: ReadonlyArray<string>\n      super: ReadonlyArray<string>\n    }\n  >\n>\n\nexport type SerializedEffect = Readonly<\n  Types.Simplify<\n    Pick<Effect<any>, '_tag' | 'id' | 'label' | 'invocations' | 'isDestroyed'> & {\n      sub: ReadonlyArray<string>\n    }\n  >\n>\n\nexport type ReactiveGraphSnapshot = {\n  readonly atoms: ReadonlyArray<SerializedAtom>\n  readonly effects: ReadonlyArray<SerializedEffect>\n  /** IDs of deferred effects */\n  readonly deferredEffects: ReadonlyArray<string>\n}\n\nlet globalGraphIdCounter = 0\nconst uniqueGraphId = () => `graph-${++globalGraphIdCounter}`\n\n/** Used for testing */\nexport const __resetIds = () => {\n  globalGraphIdCounter = 0\n}\n\nexport class ReactiveGraph<\n  TDebugRefreshReason extends DebugRefreshReason,\n  TDebugThunkInfo extends DebugThunkInfo,\n  TContext extends { effectsWrapper?: (runEffects: () => void) => void } = {},\n> {\n  id = uniqueGraphId()\n\n  readonly atoms: Set<Atom<any, TContext, TDebugRefreshReason>> = new Set()\n  readonly effects: Set<Effect<TDebugRefreshReason>> = new Set()\n\n  context: TContext | undefined\n\n  debugRefreshInfos: BoundArray<RefreshDebugInfo<TDebugRefreshReason, TDebugThunkInfo>> = new BoundArray(200)\n\n  private currentDebugRefresh:\n    | { refreshedAtoms: AtomDebugInfo<TDebugThunkInfo>[]; startMs: DOMHighResTimeStamp }\n    | undefined\n\n  private deferredEffects: Map<Effect<TDebugRefreshReason>, Set<TDebugRefreshReason>> = new Map()\n\n  private refreshCallbacks: Set<() => void> = new Set()\n\n  private nodeIdCounter = 0\n  private uniqueNodeId = () => `node-${++this.nodeIdCounter}`\n  private refreshInfoIdCounter = 0\n  private uniqueRefreshInfoId = () => `refresh-info-${++this.refreshInfoIdCounter}`\n\n  makeRef<T>(\n    val: T,\n    options?: { label?: string; meta?: unknown; equal?: (a: T, b: T) => boolean },\n  ): Ref<T, TContext, TDebugRefreshReason> {\n    const ref: Ref<T, TContext, TDebugRefreshReason> = {\n      _tag: 'ref',\n      id: this.uniqueNodeId(),\n      isDirty: false,\n      isDestroyed: false,\n      previousResult: val,\n      computeResult: () => ref.previousResult,\n      sub: new Set(),\n      super: new Set(),\n      label: options?.label,\n      meta: options?.meta,\n      equal: options?.equal ?? deepEqual,\n      refreshes: 0,\n    }\n\n    this.atoms.add(ref)\n\n    return ref\n  }\n\n  makeThunk<T>(\n    getResult: (\n      get: GetAtom,\n      setDebugInfo: (debugInfo: TDebugThunkInfo) => void,\n      ctx: TContext,\n      otelContext: otel.Context | undefined,\n      debugRefreshReason: TDebugRefreshReason | undefined,\n    ) => T,\n    options?:\n      | {\n          label?: string\n          meta?: any\n          equal?: (a: T, b: T) => boolean\n        }\n      | undefined,\n  ): Thunk<T, TContext, TDebugRefreshReason> {\n    const thunk: Thunk<T, TContext, TDebugRefreshReason> = {\n      _tag: 'thunk',\n      id: this.uniqueNodeId(),\n      previousResult: NOT_REFRESHED_YET,\n      isDirty: true,\n      isDestroyed: false,\n      computeResult: (otelContext, debugRefreshReason) => {\n        if (thunk.isDirty) {\n          const neededCurrentRefresh = this.currentDebugRefresh === undefined\n          if (neededCurrentRefresh) {\n            this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() }\n          }\n\n          // Reset previous subcomputations as we're about to re-add them as part of the `doEffect` call below\n          thunk.sub = new Set()\n\n          const getAtom = (atom: Atom<T, TContext, TDebugRefreshReason>, otelContext: otel.Context) => {\n            this.addEdge(thunk, atom)\n            return compute(atom, otelContext, debugRefreshReason)\n          }\n\n          let debugInfo: TDebugThunkInfo | undefined = undefined\n          const setDebugInfo = (debugInfo_: TDebugThunkInfo) => {\n            debugInfo = debugInfo_\n          }\n\n          const result = getResult(\n            getAtom as GetAtom,\n            setDebugInfo,\n            this.context ?? throwContextNotSetError(this),\n            otelContext,\n            debugRefreshReason,\n          )\n\n          const resultChanged = thunk.equal(thunk.previousResult as T, result) === false\n\n          const debugInfoForAtom = {\n            atom: serializeAtom(thunk, false),\n            resultChanged,\n            debugInfo: debugInfo ?? (unknownRefreshReason() as TDebugThunkInfo),\n          } satisfies AtomDebugInfo<TDebugThunkInfo>\n\n          this.currentDebugRefresh!.refreshedAtoms.push(debugInfoForAtom)\n\n          thunk.isDirty = false\n          thunk.previousResult = result\n          thunk.recomputations++\n\n          if (neededCurrentRefresh) {\n            const refreshedAtoms = this.currentDebugRefresh!.refreshedAtoms\n            const durationMs = performance.now() - this.currentDebugRefresh!.startMs\n            this.currentDebugRefresh = undefined\n\n            this.debugRefreshInfos.push({\n              id: this.uniqueRefreshInfoId(),\n              reason: debugRefreshReason ?? ({ _tag: 'makeThunk', label: options?.label } as TDebugRefreshReason),\n              skippedRefresh: false,\n              refreshedAtoms,\n              durationMs,\n              completedTimestamp: Date.now(),\n              graphSnapshot: this.getSnapshot({ includeResults: false }),\n            })\n          }\n\n          return result\n        } else {\n          return thunk.previousResult as T\n        }\n      },\n      sub: new Set(),\n      super: new Set(),\n      recomputations: 0,\n      label: options?.label,\n      meta: options?.meta,\n      equal: options?.equal ?? deepEqual,\n      __getResult: getResult,\n    }\n\n    this.atoms.add(thunk)\n\n    return thunk\n  }\n\n  destroyNode(node: Node<any, TContext, TDebugRefreshReason>) {\n    // console.debug(`destroying node (${node._tag})`, node.id, node.label)\n\n    // Recursively destroy any supercomputations\n    if (node._tag === 'ref' || node._tag === 'thunk') {\n      for (const superComp of node.super) {\n        this.destroyNode(superComp)\n      }\n    }\n\n    // Destroy this node\n    if (node._tag !== 'ref') {\n      for (const subComp of node.sub) {\n        this.removeEdge(node, subComp)\n      }\n    }\n\n    if (node._tag === 'effect') {\n      this.deferredEffects.delete(node)\n      this.effects.delete(node)\n    } else {\n      this.atoms.delete(node)\n    }\n\n    node.isDestroyed = true\n  }\n\n  destroy() {\n    // NOTE we don't need to sort the atoms first, as `destroyNode` will recursively destroy all supercomputations\n    for (const node of this.atoms) {\n      this.destroyNode(node)\n    }\n  }\n\n  makeEffect(\n    doEffect: (\n      get: GetAtom,\n      otelContext: otel.Context | undefined,\n      debugRefreshReason: DebugRefreshReason | undefined,\n    ) => void,\n    options?: { label?: string } | undefined,\n  ): Effect<TDebugRefreshReason> {\n    const effect: Effect<TDebugRefreshReason> = {\n      _tag: 'effect',\n      id: this.uniqueNodeId(),\n      isDestroyed: false,\n      doEffect: (otelContext, debugRefreshReason) => {\n        effect.invocations++\n\n        // NOTE we're not tracking any debug refresh info for effects as they're tracked by the thunks they depend on\n\n        // Reset previous subcomputations as we're about to re-add them as part of the `doEffect` call below\n        effect.sub = new Set()\n\n        const getAtom = (\n          atom: Atom<any, TContext, TDebugRefreshReason>,\n          otelContext: otel.Context,\n          debugRefreshReason: DebugRefreshReason | undefined,\n        ) => {\n          this.addEdge(effect, atom)\n          return compute(atom, otelContext, debugRefreshReason)\n        }\n\n        doEffect(getAtom as GetAtom, otelContext, debugRefreshReason)\n      },\n      sub: new Set(),\n      label: options?.label,\n      invocations: 0,\n    }\n\n    this.effects.add(effect)\n\n    return effect\n  }\n\n  setRef<T>(\n    ref: Ref<T, TContext, TDebugRefreshReason>,\n    val: T,\n    options?:\n      | {\n          skipRefresh?: boolean\n          debugRefreshReason?: TDebugRefreshReason\n          otelContext?: otel.Context\n        }\n      | undefined,\n  ) {\n    this.setRefs([[ref, val]], options)\n  }\n\n  setRefs<T>(\n    refs: [Ref<T, TContext, TDebugRefreshReason>, T][],\n    options?:\n      | {\n          skipRefresh?: boolean\n          debugRefreshReason?: TDebugRefreshReason\n          otelContext?: otel.Context\n        }\n      | undefined,\n  ) {\n    const effectsToRefresh = new Set<Effect<TDebugRefreshReason>>()\n    for (const [ref, val] of refs) {\n      ref.previousResult = val\n      ref.refreshes++\n\n      markSuperCompDirtyRec(ref, effectsToRefresh)\n    }\n\n    if (options?.skipRefresh) {\n      for (const effect of effectsToRefresh) {\n        if (this.deferredEffects.has(effect) === false) {\n          this.deferredEffects.set(effect, new Set())\n        }\n\n        if (options?.debugRefreshReason !== undefined) {\n          this.deferredEffects.get(effect)!.add(options.debugRefreshReason)\n        }\n      }\n    } else {\n      this.runEffects(effectsToRefresh, {\n        debugRefreshReason: options?.debugRefreshReason ?? (unknownRefreshReason() as TDebugRefreshReason),\n        otelContext: options?.otelContext,\n      })\n    }\n  }\n\n  private runEffects = (\n    effectsToRefresh: Set<Effect<TDebugRefreshReason>>,\n    options: {\n      debugRefreshReason: TDebugRefreshReason\n      otelContext?: otel.Context\n    },\n  ) => {\n    const effectsWrapper = this.context?.effectsWrapper ?? ((runEffects: () => void) => runEffects())\n    effectsWrapper(() => {\n      this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() }\n\n      for (const effect of effectsToRefresh) {\n        effect.doEffect(options?.otelContext, options.debugRefreshReason)\n      }\n\n      const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms\n      const durationMs = performance.now() - this.currentDebugRefresh.startMs\n      this.currentDebugRefresh = undefined\n\n      const refreshDebugInfo: RefreshDebugInfo<TDebugRefreshReason, TDebugThunkInfo> = {\n        id: this.uniqueRefreshInfoId(),\n        reason: options.debugRefreshReason,\n        skippedRefresh: false,\n        refreshedAtoms,\n        durationMs,\n        completedTimestamp: Date.now(),\n        graphSnapshot: this.getSnapshot({ includeResults: false }),\n      }\n      this.debugRefreshInfos.push(refreshDebugInfo)\n\n      this.runRefreshCallbacks()\n    })\n  }\n\n  runDeferredEffects = (options?: { debugRefreshReason?: TDebugRefreshReason; otelContext?: otel.Context }) => {\n    // TODO improve how refresh reasons are propagated for deferred effect execution\n    // TODO also improve \"batching\" of running deferred effects (i.e. in a single `this.runEffects` call)\n    // but need to be careful to not overwhelm the main thread\n    for (const [effect, debugRefreshReasons] of this.deferredEffects) {\n      this.runEffects(new Set([effect]), {\n        debugRefreshReason: {\n          _tag: 'runDeferredEffects',\n          originalRefreshReasons: Array.from(debugRefreshReasons) as ReadonlyArray<DebugRefreshReasonBase>,\n          manualRefreshReason: options?.debugRefreshReason,\n        } as TDebugRefreshReason,\n        otelContext: options?.otelContext,\n      })\n    }\n  }\n\n  runRefreshCallbacks = () => {\n    for (const cb of this.refreshCallbacks) {\n      cb()\n    }\n  }\n\n  addEdge(\n    superComp: Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>,\n    subComp: Atom<any, TContext, TDebugRefreshReason>,\n  ) {\n    superComp.sub.add(subComp)\n    subComp.super.add(superComp)\n\n    if (this.currentDebugRefresh === undefined) {\n      this.runRefreshCallbacks()\n    }\n  }\n\n  removeEdge(\n    superComp: Thunk<any, TContext, TDebugRefreshReason> | Effect<TDebugRefreshReason>,\n    subComp: Atom<any, TContext, TDebugRefreshReason>,\n  ) {\n    superComp.sub.delete(subComp)\n    const effectsToRefresh = new Set<Effect<TDebugRefreshReason>>()\n    markSuperCompDirtyRec(subComp, effectsToRefresh)\n\n    for (const effect of effectsToRefresh) {\n      this.deferredEffects.set(effect, new Set())\n    }\n\n    subComp.super.delete(superComp)\n\n    if (this.currentDebugRefresh === undefined) {\n      this.runRefreshCallbacks()\n    }\n  }\n\n  // NOTE This function is performance-optimized (i.e. not using `Array.from`)\n  getSnapshot = (opts?: { includeResults: boolean }): ReactiveGraphSnapshot => {\n    const { includeResults = false } = opts ?? {}\n    const atoms: SerializedAtom[] = []\n    for (const atom of this.atoms) {\n      atoms.push(serializeAtom(atom, includeResults))\n    }\n\n    const effects: SerializedEffect[] = []\n    for (const effect of this.effects) {\n      effects.push(serializeEffect(effect))\n    }\n\n    const deferredEffects: string[] = []\n    for (const [effect] of this.deferredEffects) {\n      deferredEffects.push(effect.id)\n    }\n\n    return { atoms, effects, deferredEffects }\n  }\n\n  subscribeToRefresh = (cb: () => void) => {\n    this.refreshCallbacks.add(cb)\n    return () => {\n      this.refreshCallbacks.delete(cb)\n    }\n  }\n}\n\nconst compute = <T>(\n  atom: Atom<T, unknown, any>,\n  otelContext: otel.Context,\n  debugRefreshReason: DebugRefreshReason | undefined,\n): T => {\n  // const __getResult = atom._tag === 'thunk' ? atom.__getResult.toString() : ''\n  if (atom.isDestroyed) {\n    shouldNeverHappen(`LiveStore Error: Attempted to compute destroyed ${atom._tag} (${atom.id}): ${atom.label ?? ''}`)\n  }\n\n  if (atom.isDirty) {\n    // console.log('atom is dirty', atom.id, atom.label ?? '', atom._tag, __getResult)\n    const result = atom.computeResult(otelContext, debugRefreshReason)\n    atom.isDirty = false\n    atom.previousResult = result\n    return result\n  } else {\n    // console.log('atom is clean', atom.id, atom.label ?? '', atom._tag, __getResult)\n    return atom.previousResult as T\n  }\n}\n\nconst markSuperCompDirtyRec = <T>(atom: Atom<T, unknown, any>, effectsToRefresh: Set<Effect<any>>) => {\n  for (const superComp of atom.super) {\n    if (superComp._tag === 'thunk') {\n      superComp.isDirty = true\n      markSuperCompDirtyRec(superComp, effectsToRefresh)\n    } else {\n      effectsToRefresh.add(superComp)\n    }\n  }\n}\n\nexport const throwContextNotSetError = (graph: ReactiveGraph<any, any, any>): never => {\n  throw new Error(`LiveStore Error: \\`context\\` not set on ReactiveGraph (${graph.id})`)\n}\n\n// NOTE This function is performance-optimized (i.e. not using `pick` and `Array.from`)\nconst serializeAtom = (atom: Atom<any, unknown, any>, includeResult: boolean): SerializedAtom => {\n  const sub: string[] = []\n  for (const a of atom.sub) {\n    sub.push(a.id)\n  }\n\n  const super_: string[] = []\n  for (const a of atom.super) {\n    super_.push(a.id)\n  }\n\n  const previousResult: EncodedOption<string> = includeResult\n    ? encodedOptionSome(\n        atom.previousResult === NOT_REFRESHED_YET ? '\"SYMBOL_NOT_REFRESHED_YET\"' : JSON.stringify(atom.previousResult),\n      )\n    : encodedOptionNone()\n\n  if (atom._tag === 'ref') {\n    return {\n      _tag: atom._tag,\n      id: atom.id,\n      label: atom.label,\n      meta: atom.meta,\n      isDirty: atom.isDirty,\n      sub,\n      super: super_,\n      isDestroyed: atom.isDestroyed,\n      refreshes: atom.refreshes,\n      previousResult,\n    }\n  }\n\n  return {\n    _tag: 'thunk',\n    id: atom.id,\n    label: atom.label,\n    meta: atom.meta,\n    isDirty: atom.isDirty,\n    sub,\n    super: super_,\n    isDestroyed: atom.isDestroyed,\n    recomputations: atom.recomputations,\n    previousResult,\n  }\n}\n\n// NOTE This function is performance-optimized (i.e. not using `pick` and `Array.from`)\nconst serializeEffect = (effect: Effect<any>): SerializedEffect => {\n  const sub: string[] = []\n  for (const a of effect.sub) {\n    sub.push(a.id)\n  }\n\n  return {\n    _tag: effect._tag,\n    id: effect.id,\n    label: effect.label,\n    sub,\n    invocations: effect.invocations,\n    isDestroyed: effect.isDestroyed,\n  }\n}\n", "import { isNotNil } from '@livestore/utils'\nimport { Predicate } from '@livestore/utils/effect'\nimport type * as otel from '@opentelemetry/api'\n\nimport * as RG from '../reactive.js'\nimport type { Store } from '../store/store.js'\nimport type { QueryDebugInfo, RefreshReason } from '../store/store-types.js'\nimport type { StackInfo } from '../utils/stack-info.js'\n\nexport type ReactivityGraph = RG.ReactiveGraph<RefreshReason, QueryDebugInfo, ReactivityGraphContext>\n\nexport const makeReactivityGraph = (): ReactivityGraph =>\n  new RG.ReactiveGraph<RefreshReason, QueryDebugInfo, ReactivityGraphContext>()\n\nexport type ReactivityGraphContext = {\n  store: Store\n  /** Maps from the hash of the query definition to the RcRef of the query */\n  defRcMap: Map<string, RcRef<LiveQuery.Any | ISignal<any>>>\n  /** Back-reference to the reactivity graph for convenience */\n  reactivityGraph: WeakRef<ReactivityGraph>\n  otelTracer: otel.Tracer\n  rootOtelContext: otel.Context\n  effectsWrapper: (run: () => void) => void\n}\n\nexport type GetResult<TQuery extends LiveQueryDef.Any | LiveQuery.Any | SignalDef<any>> =\n  TQuery extends LiveQuery<infer TResult>\n    ? TResult\n    : TQuery extends LiveQueryDef<infer TResult>\n      ? TResult\n      : TQuery extends SignalDef<infer TResult>\n        ? TResult\n        : unknown\n\nlet queryIdCounter = 0\n\nexport interface SignalDef<T> extends LiveQueryDef<T, 'signal-def'> {\n  _tag: 'signal-def'\n  defaultValue: T\n  hash: string\n  label: string\n  make: (ctx: ReactivityGraphContext) => RcRef<ISignal<T>>\n}\n\nexport interface ISignal<T> extends LiveQuery<T> {\n  _tag: 'signal'\n  reactivityGraph: ReactivityGraph\n  ref: RG.Ref<T, ReactivityGraphContext, RefreshReason>\n  set: (value: T) => void\n  get: () => T\n  destroy: () => void\n}\n\nexport const TypeId = Symbol.for('LiveQuery')\nexport type TypeId = typeof TypeId\n\nexport interface RcRef<T> {\n  rc: number\n  value: T\n  deref: () => void\n}\n\nexport type DepKey = string | number | ReadonlyArray<string | number | undefined | null>\n\nexport const depsToString = (deps: DepKey): string => {\n  if (typeof deps === 'string' || typeof deps === 'number') {\n    return deps.toString()\n  }\n  return deps.filter(isNotNil).join(',')\n}\n\n// TODO we should refactor/clean up how LiveQueryDef / SignalDef / LiveQuery / ISignal are defined (particularly on the type-level)\nexport interface LiveQueryDef<TResult, TTag extends string = 'def'> {\n  _tag: TTag\n  /** Creates a new LiveQuery instance bound to a specific store/reactivityGraph */\n  make: (ctx: ReactivityGraphContext, otelContext?: otel.Context) => RcRef<LiveQuery<TResult> | ISignal<TResult>>\n  label: string\n  hash: string\n}\n\nexport namespace LiveQueryDef {\n  export type Any = LiveQueryDef<any, 'def' | 'signal-def'>\n}\n\n/**\n * A LiveQuery is stateful\n */\nexport interface LiveQuery<TResult> {\n  id: number\n  _tag: 'computed' | 'db' | 'graphql' | 'signal'\n  [TypeId]: TypeId\n\n  // reactivityGraph: ReactivityGraph\n\n  /** This should only be used on a type-level and doesn't hold any value during runtime */\n  '__result!': TResult\n\n  /** A reactive thunk representing the query results */\n  results$: RG.Atom<TResult, ReactivityGraphContext, RefreshReason>\n\n  label: string\n\n  run: (args: { otelContext?: otel.Context; debugRefreshReason?: RefreshReason }) => TResult\n\n  destroy: () => void\n  isDestroyed: boolean\n\n  // subscribe(\n  //   onNewValue: (value: TResult) => void,\n  //   onUnsubsubscribe?: () => void,\n  //   options?: { label?: string; otelContext?: otel.Context },\n  // ): () => void\n\n  activeSubscriptions: Set<StackInfo>\n\n  runs: number\n\n  executionTimes: number[]\n  def: LiveQueryDef<TResult> | SignalDef<TResult>\n}\n\nexport namespace LiveQuery {\n  export type Any = LiveQuery<any>\n}\n\nexport abstract class LiveStoreQueryBase<TResult> implements LiveQuery<TResult> {\n  '__result!'!: TResult\n  id = queryIdCounter++;\n  [TypeId]: TypeId = TypeId\n  abstract _tag: 'computed' | 'db' | 'graphql' | 'signal'\n\n  /** Human-readable label for the query for debugging */\n  abstract label: string\n\n  abstract def: LiveQueryDef<TResult> | SignalDef<TResult>\n\n  abstract results$: RG.Atom<TResult, ReactivityGraphContext, RefreshReason>\n\n  activeSubscriptions: Set<StackInfo> = new Set()\n\n  abstract readonly reactivityGraph: ReactivityGraph\n\n  get runs() {\n    if (this.results$._tag === 'thunk') {\n      return this.results$.recomputations\n    }\n    return 0\n  }\n\n  executionTimes: number[] = []\n\n  // TODO double check if this is needed\n  isDestroyed = false\n  abstract destroy: () => void\n\n  run = (args: { otelContext?: otel.Context; debugRefreshReason?: RefreshReason }): TResult => {\n    return this.results$.computeResult(args.otelContext, args.debugRefreshReason)\n  }\n\n  protected dependencyQueriesRef: DependencyQueriesRef = new Set()\n\n  // subscribe = (\n  //   onNewValue: (value: TResult) => void,\n  //   onUnsubsubscribe?: () => void,\n  //   options?: { label?: string; otelContext?: otel.Context } | undefined,\n  // ): (() => void) =>\n  //   this.reactivityGraph.context?.store.subscribe(this, onNewValue, onUnsubsubscribe, options) ??\n  //   RG.throwContextNotSetError(this.reactivityGraph)\n}\n\nexport type GetAtomResult = <T>(\n  atom: RG.Atom<T, any, RefreshReason> | LiveQueryDef<T> | LiveQuery<T> | ISignal<T> | SignalDef<T>,\n  otelContext?: otel.Context | undefined,\n  debugRefreshReason?: RefreshReason | undefined,\n) => T\n\nexport type DependencyQueriesRef = Set<RcRef<LiveQuery.Any | ISignal<any>>>\n\nexport const makeGetAtomResult = (\n  get: RG.GetAtom,\n  ctx: ReactivityGraphContext,\n  otelContext: otel.Context,\n  dependencyQueriesRef: DependencyQueriesRef,\n) => {\n  // NOTE we're using the `otelContext` from `makeGetAtomResult` here, not the `otelContext` from `getAtom`\n  const getAtom: GetAtomResult = (atom, _otelContext, debugRefreshReason) => {\n    // ReactivityGraph atoms case\n    if (atom._tag === 'thunk' || atom._tag === 'ref') return get(atom, otelContext, debugRefreshReason)\n\n    // def case\n    if (atom._tag === 'def' || atom._tag === 'signal-def') {\n      const query = atom.make(ctx)\n      dependencyQueriesRef.add(query)\n      // TODO deref the query on destroy\n      return getAtom(query.value, _otelContext, debugRefreshReason)\n    }\n\n    // Signal case\n    if (atom._tag === 'signal' && Predicate.hasProperty(atom, 'ref')) {\n      return get(atom.ref, otelContext, debugRefreshReason)\n    }\n\n    // LiveQuery case\n    return get(atom.results$, otelContext, debugRefreshReason)\n  }\n\n  return getAtom\n}\n\nexport const withRCMap = <T extends LiveQuery.Any | ISignal<any>>(\n  id: string,\n  make: (ctx: ReactivityGraphContext, otelContext?: otel.Context) => T,\n): ((ctx: ReactivityGraphContext, otelContext?: otel.Context) => RcRef<T>) => {\n  return (ctx, otelContext) => {\n    let item = ctx.defRcMap.get(id)\n    if (item) {\n      item.rc++\n      return item as RcRef<T>\n    }\n\n    const query$ = make(ctx, otelContext)\n\n    item = {\n      rc: 1,\n      value: query$,\n      deref: () => {\n        item!.rc--\n        if (item!.rc === 0) {\n          item!.value.destroy()\n          ctx.defRcMap.delete(id)\n        }\n      },\n    }\n    ctx.defRcMap.set(id, item)\n\n    return item as RcRef<T>\n  }\n}\n", "import type { PreparedBindValues } from '@livestore/common'\nimport { SessionIdSymbol } from '@livestore/common'\nimport { State } from '@livestore/common/schema'\nimport { shouldNeverHappen } from '@livestore/utils'\nimport type * as otel from '@opentelemetry/api'\n\nimport type { ReactivityGraphContext } from './base-class.js'\n\nexport const rowQueryLabel = (\n  table: State.SQLite.ClientDocumentTableDef.Any,\n  id: string | SessionIdSymbol | undefined,\n) => `${table.sqliteDef.name}.get:${id === undefined ? table.default.id : id === SessionIdSymbol ? 'sessionId' : id}`\n\nexport const makeExecBeforeFirstRun =\n  ({\n    id,\n    explicitDefaultValues,\n    table,\n    otelContext: otelContext_,\n  }: {\n    id?: string | SessionIdSymbol\n    explicitDefaultValues?: any\n    table: State.SQLite.TableDefBase\n    otelContext: otel.Context | undefined\n  }) =>\n  ({ store }: ReactivityGraphContext) => {\n    if (State.SQLite.tableIsClientDocumentTable(table) === false) {\n      return shouldNeverHappen(\n        `Cannot insert row for table \"${table.sqliteDef.name}\" which does not have 'deriveEvents: true' set`,\n      )\n    }\n\n    const otelContext = otelContext_ ?? store.otel.queriesSpanContext\n\n    const idVal = id === SessionIdSymbol ? store.sessionId : id!\n    const rowExists =\n      store.sqliteDbWrapper.cachedSelect(\n        `SELECT 1 FROM '${table.sqliteDef.name}' WHERE id = ?`,\n        [idVal] as any as PreparedBindValues,\n        { otelContext },\n      ).length === 1\n\n    if (rowExists) return\n\n    // It's important that we only commit and don't refresh here, as this function might be called during a render\n    // and otherwise we might end up in a \"reactive loop\"\n\n    store.commit(\n      { otelContext, skipRefresh: true, label: `${table.sqliteDef.name}.set:${idVal}` },\n      table.set(explicitDefaultValues, idVal as TODO),\n    )\n  }\n", "import type { Bindable } from '@livestore/common'\nimport { BoundMap, BoundSet } from '@livestore/common'\n\ntype Opaque<BaseType, BrandType = unknown> = BaseType & {\n  readonly [Symbols.base]: BaseType\n  readonly [Symbols.brand]: BrandType\n}\n\nnamespace Symbols {\n  export declare const base: unique symbol\n  export declare const brand: unique symbol\n}\n\nexport type CacheKey = Opaque<string, string>\ntype TableName = string\n\nconst ignore = ['begin', 'rollback', 'commit', 'savepoint', 'release']\n\n// TODO: profile to see how big we need this cache to be.\nconst cacheSize = 200\nexport default class QueryCache {\n  #entries = new BoundMap<CacheKey, any>(cacheSize)\n  #dependencies = new Map<TableName, BoundSet<CacheKey>>()\n\n  getKey = (sql: string, bindValues?: Bindable): CacheKey => {\n    if (bindValues == null) {\n      return sql as CacheKey\n    }\n\n    if (Array.isArray(bindValues)) {\n      return (sql + '\\n' + bindValues.join('\\n')) as CacheKey\n    }\n\n    return (sql + '\\n' + Object.values(bindValues).join('\\n')) as CacheKey\n  }\n\n  get = (key: CacheKey) => {\n    return this.#entries.get(key)\n  }\n\n  set = (queriedTables: Iterable<string>, key: CacheKey, results: any) => {\n    this.#entries.set(key, results)\n    for (const table of queriedTables) {\n      let keys = this.#dependencies.get(table)\n      if (keys == null) {\n        keys = new BoundSet(cacheSize)\n        keys.onEvict = this.#dependencyTrackerEvicted\n        this.#dependencies.set(table, keys)\n      }\n      keys.add(key)\n    }\n  }\n\n  #dependencyTrackerEvicted = (key: CacheKey) => {\n    this.#entries.delete(key)\n  }\n\n  ignoreQuery = (query: string) => {\n    return ignore.some((prefix) => query.startsWith(prefix))\n  }\n\n  // The next simplest step is to create a specific implementation for invalidating\n  // the expensive track list queries only when constraints data in a write overlaps with read constraints.\n  //\n  // As well as either:\n  // a. removeing the big view (since we'll have our cache)\n  // b. incrementally updating the view on insert by the EventImporter\n  //\n  // We'll not try to tackle any generalized approach until we have a proof of concept working.\n  invalidate = (queriedTables: Iterable<string>) => {\n    for (const table of queriedTables) {\n      const keys = this.#dependencies.get(table)\n      if (keys == null) {\n        continue\n      }\n      for (const k of keys) {\n        this.#entries.delete(k)\n      }\n    }\n  }\n}\n", "/* eslint-disable prefer-arrow/prefer-arrow-functions */\n\nimport {\n  type DebugInfo,\n  type MutableDebugInfo,\n  type PreparedBindValues,\n  type PreparedStatement,\n  type SqliteDb,\n  type SqliteDbChangeset,\n  SqliteDbHelper,\n  type SqliteDbSession,\n} from '@livestore/common'\nimport {\n  BoundArray,\n  BoundMap,\n  getDurationMsFromSpan,\n  getStartTimeHighResFromSpan,\n  sql,\n  SqliteError,\n} from '@livestore/common'\nimport { isDevEnv, LS_DEV } from '@livestore/utils'\nimport type * as otel from '@opentelemetry/api'\n\nimport QueryCache from './QueryCache.js'\n\nexport const emptyDebugInfo = (): DebugInfo => ({\n  slowQueries: new BoundArray(200),\n  queryFrameDuration: 0,\n  queryFrameCount: 0,\n  events: new BoundArray(1000),\n})\n\n/**\n * This class is mostly adding result caching around a SqliteDb which is used to speed up\n * SQLite queries when used through the reactivity graph.\n */\nexport class SqliteDbWrapper implements SqliteDb {\n  _tag = 'SqliteDb' as const\n  // TODO: how many unique active statements are expected?\n  private cachedStmts = new BoundMap<string, PreparedStatement>(200)\n  private tablesUsedCache = new BoundMap<string, Set<string>>(200)\n  private resultCache = new QueryCache()\n  private db: SqliteDb\n  private otelTracer: otel.Tracer\n  private otelRootSpanContext: otel.Context\n  private tablesUsedStmt\n  public debugInfo: MutableDebugInfo = emptyDebugInfo()\n\n  constructor({\n    db,\n    otel,\n  }: {\n    db: SqliteDb\n    otel: {\n      tracer: otel.Tracer\n      rootSpanContext: otel.Context\n    }\n  }) {\n    this.db = db\n    this.otelTracer = otel.tracer\n    this.otelRootSpanContext = otel.rootSpanContext\n\n    this.tablesUsedStmt = db.prepare(\n      `SELECT tbl_name FROM tables_used(?) AS u JOIN sqlite_master ON sqlite_master.name = u.name WHERE u.schema = 'main';`,\n    )\n\n    this.cachedStmts.onEvict = (_queryStr, stmt) => stmt.finalize()\n\n    configureSQLite(this)\n  }\n  metadata: any\n  prepare(queryStr: string): PreparedStatement {\n    return this.db.prepare(queryStr)\n  }\n  import(data: Uint8Array<ArrayBufferLike> | SqliteDb<any, any>) {\n    return this.db.import(data)\n  }\n  close(): void {\n    this.db.close()\n  }\n  destroy(): void {\n    this.db.destroy()\n  }\n  session(): SqliteDbSession {\n    return this.db.session()\n  }\n  makeChangeset(data: Uint8Array): SqliteDbChangeset {\n    return this.db.makeChangeset(data)\n  }\n\n  txn<TRes>(callback: () => TRes): TRes {\n    this.execute(sql`begin transaction;`)\n\n    let errored = false\n    let result: TRes\n\n    try {\n      result = callback()\n    } catch (e) {\n      errored = true\n      this.execute(sql`rollback;`)\n      throw e\n    }\n\n    if (!errored) {\n      this.execute(sql`commit;`)\n    }\n\n    return result\n  }\n\n  withChangeset<TRes>(callback: () => TRes): {\n    result: TRes\n    changeset: { _tag: 'sessionChangeset'; data: Uint8Array; debug: any } | { _tag: 'no-op' }\n  } {\n    const session = this.db.session()\n    const result = callback()\n    const changeset = session.changeset()\n\n    session.finish()\n\n    return {\n      result,\n      changeset: changeset ? { _tag: 'sessionChangeset', data: changeset, debug: null } : { _tag: 'no-op' },\n    }\n  }\n\n  rollback(changeset: Uint8Array) {\n    const invertedChangeset = this.db.makeChangeset(changeset).invert()\n    invertedChangeset.apply()\n  }\n\n  getTablesUsed(query: string) {\n    // It seems that SQLite doesn't properly handle `DELETE FROM SOME_TABLE` queries without a WHERE clause\n    // So we need to handle these queries separately\n    const tableNameFromPlainDeleteQuery = tryGetTableNameFromPlainDeleteQuery(query)\n    if (tableNameFromPlainDeleteQuery !== undefined) {\n      return new Set<string>([tableNameFromPlainDeleteQuery])\n    }\n\n    const cached = this.tablesUsedCache.get(query)\n    if (cached) {\n      return cached\n    }\n    const stmt = this.tablesUsedStmt\n    const tablesUsed = new Set<string>()\n    try {\n      const results = stmt.select<{ tbl_name: string }>([query] as unknown as PreparedBindValues)\n\n      for (const row of results) {\n        tablesUsed.add(row.tbl_name)\n      }\n    } catch (e) {\n      console.error('Error getting tables used', e, 'for query', query)\n      return new Set<string>()\n    }\n    this.tablesUsedCache.set(query, tablesUsed)\n    return tablesUsed\n  }\n\n  cachedExecute(\n    queryStr: string,\n    bindValues?: PreparedBindValues | undefined,\n    options?: {\n      hasNoEffects?: boolean\n      otelContext?: otel.Context\n      writeTables?: ReadonlySet<string>\n      onRowsChanged?: (rowsChanged: number) => void\n    },\n  ): { durationMs: number } {\n    // console.debug('in-memory-db:execute', query, bindValues)\n\n    return this.otelTracer.startActiveSpan(\n      'livestore.in-memory-db:execute',\n      // TODO truncate query string\n      { attributes: { 'sql.query': queryStr } },\n      options?.otelContext ?? this.otelRootSpanContext,\n      (span) => {\n        try {\n          let stmt = this.cachedStmts.get(queryStr)\n          if (stmt === undefined) {\n            stmt = this.db.prepare(queryStr)\n            this.cachedStmts.set(queryStr, stmt)\n          }\n\n          stmt.execute(bindValues)\n\n          if (options?.hasNoEffects !== true && !this.resultCache.ignoreQuery(queryStr)) {\n            // TODO use write tables instead\n            // check what queries actually end up here.\n            this.resultCache.invalidate(options?.writeTables ?? this.getTablesUsed(queryStr))\n          }\n\n          span.end()\n\n          const durationMs = getDurationMsFromSpan(span)\n\n          this.debugInfo.queryFrameDuration += durationMs\n          this.debugInfo.queryFrameCount++\n\n          if (durationMs > 5 && isDevEnv()) {\n            this.debugInfo.slowQueries.push({\n              queryStr,\n              bindValues,\n              durationMs,\n              rowsCount: undefined,\n              queriedTables: new Set(),\n              startTimePerfNow: getStartTimeHighResFromSpan(span),\n            })\n          }\n\n          return { durationMs }\n        } catch (cause: any) {\n          span.recordException(cause)\n          span.end()\n          if (LS_DEV) {\n            // biome-ignore lint/suspicious/noDebugger: <explanation>\n            debugger\n          }\n          throw new SqliteError({ cause, query: { bindValues: bindValues ?? {}, sql: queryStr } })\n        }\n      },\n    )\n  }\n\n  execute = SqliteDbHelper.makeExecute((queryStr, bindValues) => this.cachedExecute(queryStr, bindValues))\n\n  select = SqliteDbHelper.makeSelect((queryStr, bindValues) => this.cachedSelect(queryStr, bindValues))\n\n  cachedSelect<T = any>(\n    queryStr: string,\n    bindValues?: PreparedBindValues | undefined,\n    options?: {\n      queriedTables?: ReadonlySet<string>\n      skipCache?: boolean\n      otelContext?: otel.Context\n    },\n  ): ReadonlyArray<T> {\n    const { queriedTables, skipCache = false, otelContext } = options ?? {}\n\n    // console.debug('in-memory-db:select', query, bindValues)\n\n    return this.otelTracer.startActiveSpan(\n      'sql-in-memory-select',\n      {},\n      otelContext ?? this.otelRootSpanContext,\n      (span) => {\n        try {\n          span.setAttribute('sql.query', queryStr)\n\n          const key = this.resultCache.getKey(queryStr, bindValues)\n          const cachedResult = this.resultCache.get(key)\n          if (skipCache === false && cachedResult !== undefined) {\n            span.setAttribute('sql.rowsCount', cachedResult.length)\n            span.setAttribute('sql.cached', true)\n            span.end()\n            return cachedResult\n          }\n\n          let stmt = this.cachedStmts.get(queryStr)\n          if (stmt === undefined) {\n            stmt = this.db.prepare(queryStr)\n            this.cachedStmts.set(queryStr, stmt)\n          }\n\n          const result = stmt.select<T>(bindValues)\n\n          span.setAttribute('sql.rowsCount', result.length)\n          span.setAttribute('sql.cached', false)\n\n          const queriedTables_ = queriedTables ?? this.getTablesUsed(queryStr)\n          this.resultCache.set(queriedTables_, key, result)\n\n          span.end()\n\n          const durationMs = getDurationMsFromSpan(span)\n\n          this.debugInfo.queryFrameDuration += durationMs\n          this.debugInfo.queryFrameCount++\n\n          // TODO also enable in non-dev mode\n          if (durationMs > 5 && isDevEnv()) {\n            this.debugInfo.slowQueries.push({\n              queryStr,\n              bindValues,\n              durationMs,\n              rowsCount: result.length,\n              queriedTables: queriedTables_,\n              startTimePerfNow: getStartTimeHighResFromSpan(span),\n            })\n          }\n\n          return result\n        } finally {\n          span.end()\n        }\n      },\n    )\n  }\n\n  export() {\n    // Clear statement cache because exporting frees statements\n    for (const key of this.cachedStmts.keys()) {\n      this.cachedStmts.delete(key)\n    }\n\n    return this.db.export()\n  }\n}\n\n/** Set up SQLite performance; hasn't been super carefully optimized yet. */\nconst configureSQLite = (db: SqliteDbWrapper) => {\n  db.execute(\n    // TODO: revisit these tuning parameters for max performance\n    sql`\n      PRAGMA page_size=32768;\n      PRAGMA cache_size=10000;\n      PRAGMA synchronous='OFF';\n      PRAGMA temp_store='MEMORY';\n      PRAGMA foreign_keys='ON'; -- we want foreign key constraints to be enforced\n    `,\n  )\n}\n\nconst tryGetTableNameFromPlainDeleteQuery = (query: string) => {\n  const [_, tableName] = query.trim().match(/^delete\\s+from\\s+(\\w+)$/i) ?? []\n  return tableName\n}\n", "// TODO consider replacing with Effect's RC data structures\nexport class ReferenceCountedSet<T> {\n  private map: Map<T, number>\n\n  constructor() {\n    this.map = new Map<T, number>()\n  }\n\n  add = (key: T) => {\n    const count = this.map.get(key) ?? 0\n    this.map.set(key, count + 1)\n  }\n\n  remove = (key: T) => {\n    const count = this.map.get(key) ?? 0\n    if (count === 1) {\n      this.map.delete(key)\n    } else {\n      this.map.set(key, count - 1)\n    }\n  }\n\n  has = (key: T) => {\n    return this.map.has(key)\n  }\n\n  get size() {\n    return this.map.size\n  }\n\n  *[Symbol.iterator]() {\n    for (const key of this.map.keys()) {\n      yield key\n    }\n  }\n}\n", "import { isDevEnv } from '@livestore/utils'\nimport { Effect } from '@livestore/utils/effect'\n\n/* eslint-disable unicorn/prefer-global-this */\nexport const downloadBlob = (\n  data: Uint8Array | Blob | string,\n  fileName: string,\n  mimeType = 'application/octet-stream',\n) => {\n  const blob = data instanceof Blob ? data : new Blob([data], { type: mimeType })\n\n  const url = window.URL.createObjectURL(blob)\n\n  downloadURL(url, fileName)\n\n  setTimeout(() => window.URL.revokeObjectURL(url), 1000)\n}\n\nexport const downloadURL = (data: string, fileName: string) => {\n  const a = document.createElement('a')\n  a.href = data\n  a.download = fileName\n  document.body.append(a)\n  a.style.display = 'none'\n  a.click()\n  a.remove()\n}\n\nexport const exposeDebugUtils = () => {\n  if (isDevEnv()) {\n    globalThis.__debugLiveStoreUtils = {\n      downloadBlob,\n      runSync: (effect: Effect.Effect<any, any, never>) => Effect.runSync(effect),\n      runFork: (effect: Effect.Effect<any, any, never>) => Effect.runFork(effect),\n    }\n  }\n}\n", "import {\n  type ClientSession,\n  type ClientSessionSyncProcessor,\n  type ParamsObject,\n  type PreparedBindValues,\n  type QueryBuilder,\n  UnexpectedError,\n} from '@livestore/common'\nimport {\n  Devtools,\n  getDurationMsFromSpan,\n  getExecStatementsFromMaterializer,\n  getResultSchema,\n  hashMaterializerResults,\n  IntentionalShutdownCause,\n  isQueryBuilder,\n  liveStoreVersion,\n  makeClientSessionSyncProcessor,\n  prepareBindValues,\n  QueryBuilderAstSymbol,\n  replaceSessionIdSymbol,\n} from '@livestore/common'\nimport type { LiveStoreSchema } from '@livestore/common/schema'\nimport { getEventDef, LiveStoreEvent, SystemTables } from '@livestore/common/schema'\nimport { assertNever, isDevEnv, notYetImplemented } from '@livestore/utils'\nimport type { Scope } from '@livestore/utils/effect'\nimport { Cause, Effect, Fiber, Inspectable, Option, OtelTracer, Runtime, Schema, Stream } from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\nimport * as otel from '@opentelemetry/api'\n\nimport type {\n  LiveQuery,\n  LiveQueryDef,\n  ReactivityGraph,\n  ReactivityGraphContext,\n  SignalDef,\n} from '../live-queries/base-class.js'\nimport { makeReactivityGraph } from '../live-queries/base-class.js'\nimport { makeExecBeforeFirstRun } from '../live-queries/client-document-get-query.js'\nimport type { Ref } from '../reactive.js'\nimport { SqliteDbWrapper } from '../SqliteDbWrapper.js'\nimport { ReferenceCountedSet } from '../utils/data-structures.js'\nimport { downloadBlob, exposeDebugUtils } from '../utils/dev.js'\nimport type { StackInfo } from '../utils/stack-info.js'\nimport type {\n  RefreshReason,\n  StoreCommitOptions,\n  StoreEventsOptions,\n  StoreOptions,\n  StoreOtel,\n  Unsubscribe,\n} from './store-types.js'\n\nif (isDevEnv()) {\n  exposeDebugUtils()\n}\n\nexport class Store<TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}> extends Inspectable.Class {\n  readonly storeId: string\n  reactivityGraph: ReactivityGraph\n  sqliteDbWrapper: SqliteDbWrapper\n  clientSession: ClientSession\n  schema: LiveStoreSchema\n  context: TContext\n  otel: StoreOtel\n  /**\n   * Note we're using `Ref<null>` here as we don't care about the value but only about *that* something has changed.\n   * This only works in combination with `equal: () => false` which will always trigger a refresh.\n   */\n  tableRefs: { [key: string]: Ref<null, ReactivityGraphContext, RefreshReason> }\n\n  private effectContext: {\n    runtime: Runtime.Runtime<Scope.Scope>\n    lifetimeScope: Scope.Scope\n  }\n\n  /** RC-based set to see which queries are currently subscribed to */\n  activeQueries: ReferenceCountedSet<LiveQuery<any>>\n\n  // NOTE this is currently exposed for the Devtools databrowser to commit events\n  readonly __eventSchema\n  readonly syncProcessor: ClientSessionSyncProcessor\n\n  readonly boot: Effect.Effect<void, UnexpectedError, Scope.Scope>\n\n  // #region constructor\n  constructor({\n    clientSession,\n    schema,\n    otelOptions,\n    context,\n    batchUpdates,\n    storeId,\n    effectContext,\n    params,\n    confirmUnsavedChanges,\n    __runningInDevtools,\n  }: StoreOptions<TSchema, TContext>) {\n    super()\n\n    this.storeId = storeId\n\n    this.sqliteDbWrapper = new SqliteDbWrapper({ otel: otelOptions, db: clientSession.sqliteDb })\n    this.clientSession = clientSession\n    this.schema = schema\n    this.context = context\n\n    this.effectContext = effectContext\n\n    const reactivityGraph = makeReactivityGraph()\n\n    const syncSpan = otelOptions.tracer.startSpan('LiveStore:sync', {}, otelOptions.rootSpanContext)\n\n    this.syncProcessor = makeClientSessionSyncProcessor({\n      schema,\n      clientSession,\n      runtime: effectContext.runtime,\n      materializeEvent: (eventDecoded, { otelContext, withChangeset, materializerHashLeader }) => {\n        const { eventDef, materializer } = getEventDef(schema, eventDecoded.name)\n\n        const execArgsArr = getExecStatementsFromMaterializer({\n          eventDef,\n          materializer,\n          dbState: this.sqliteDbWrapper,\n          event: { decoded: eventDecoded, encoded: undefined },\n        })\n\n        const materializerHash = isDevEnv() ? Option.some(hashMaterializerResults(execArgsArr)) : Option.none()\n\n        if (\n          materializerHashLeader._tag === 'Some' &&\n          materializerHash._tag === 'Some' &&\n          materializerHashLeader.value !== materializerHash.value\n        ) {\n          void this.shutdown(\n            Cause.fail(\n              UnexpectedError.make({\n                cause: `Materializer hash mismatch detected for event \"${eventDecoded.name}\".`,\n                note: `Please make sure your event materializer is a pure function without side effects.`,\n              }),\n            ),\n          )\n        }\n\n        const writeTablesForEvent = new Set<string>()\n\n        const exec = () => {\n          for (const {\n            statementSql,\n            bindValues,\n            writeTables = this.sqliteDbWrapper.getTablesUsed(statementSql),\n          } of execArgsArr) {\n            try {\n              this.sqliteDbWrapper.cachedExecute(statementSql, bindValues, { otelContext, writeTables })\n            } catch (cause) {\n              throw UnexpectedError.make({\n                cause,\n                note: `Error executing materializer for event \"${eventDecoded.name}\".\\nStatement: ${statementSql}\\nBind values: ${JSON.stringify(bindValues)}`,\n              })\n            }\n\n            // durationMsTotal += durationMs\n            for (const table of writeTables) {\n              writeTablesForEvent.add(table)\n            }\n          }\n        }\n\n        let sessionChangeset:\n          | { _tag: 'sessionChangeset'; data: Uint8Array; debug: any }\n          | { _tag: 'no-op' }\n          | { _tag: 'unset' } = { _tag: 'unset' }\n\n        if (withChangeset === true) {\n          sessionChangeset = this.sqliteDbWrapper.withChangeset(exec).changeset\n        } else {\n          exec()\n        }\n\n        return { writeTables: writeTablesForEvent, sessionChangeset, materializerHash }\n      },\n      rollback: (changeset) => {\n        this.sqliteDbWrapper.rollback(changeset)\n      },\n      refreshTables: (tables) => {\n        const tablesToUpdate = [] as [Ref<null, ReactivityGraphContext, RefreshReason>, null][]\n        for (const tableName of tables) {\n          const tableRef = this.tableRefs[tableName]\n          assertNever(tableRef !== undefined, `No table ref found for ${tableName}`)\n          tablesToUpdate.push([tableRef!, null])\n        }\n        reactivityGraph.setRefs(tablesToUpdate)\n      },\n      span: syncSpan,\n      params: {\n        leaderPushBatchSize: params.leaderPushBatchSize,\n      },\n      confirmUnsavedChanges,\n    })\n\n    this.__eventSchema = LiveStoreEvent.makeEventDefSchemaMemo(schema)\n\n    // TODO generalize the `tableRefs` concept to allow finer-grained refs\n    this.tableRefs = {}\n    this.activeQueries = new ReferenceCountedSet()\n\n    const commitsSpan = otelOptions.tracer.startSpan('LiveStore:commits', {}, otelOptions.rootSpanContext)\n    const otelMuationsSpanContext = otel.trace.setSpan(otel.context.active(), commitsSpan)\n\n    const queriesSpan = otelOptions.tracer.startSpan('LiveStore:queries', {}, otelOptions.rootSpanContext)\n    const otelQueriesSpanContext = otel.trace.setSpan(otel.context.active(), queriesSpan)\n\n    this.reactivityGraph = reactivityGraph\n    this.reactivityGraph.context = {\n      store: this as unknown as Store<LiveStoreSchema>,\n      defRcMap: new Map(),\n      reactivityGraph: new WeakRef(reactivityGraph),\n      otelTracer: otelOptions.tracer,\n      rootOtelContext: otelQueriesSpanContext,\n      effectsWrapper: batchUpdates,\n    }\n\n    this.otel = {\n      tracer: otelOptions.tracer,\n      rootSpanContext: otelOptions.rootSpanContext,\n      commitsSpanContext: otelMuationsSpanContext,\n      queriesSpanContext: otelQueriesSpanContext,\n    }\n\n    // Need a set here since `schema.tables` might contain duplicates and some componentStateTables\n    const allTableNames = new Set(\n      // NOTE we're excluding the LiveStore schema and events tables as they are not user-facing\n      // unless LiveStore is running in the devtools\n      __runningInDevtools\n        ? this.schema.state.sqlite.tables.keys()\n        : Array.from(this.schema.state.sqlite.tables.keys()).filter((_) => !SystemTables.isStateSystemTable(_)),\n    )\n    const existingTableRefs = new Map(\n      Array.from(this.reactivityGraph.atoms.values())\n        .filter((_): _ is Ref<any, any, any> => _._tag === 'ref' && _.label?.startsWith('tableRef:') === true)\n        .map((_) => [_.label!.slice('tableRef:'.length), _] as const),\n    )\n    for (const tableName of allTableNames) {\n      this.tableRefs[tableName] =\n        existingTableRefs.get(tableName) ??\n        this.reactivityGraph.makeRef(null, {\n          equal: () => false,\n          label: `tableRef:${tableName}`,\n          meta: { liveStoreRefType: 'table' },\n        })\n    }\n\n    this.boot = Effect.gen(this, function* () {\n      yield* Effect.addFinalizer(() =>\n        Effect.sync(() => {\n          // Remove all table refs from the reactivity graph\n          for (const tableRef of Object.values(this.tableRefs)) {\n            for (const superComp of tableRef.super) {\n              this.reactivityGraph.removeEdge(superComp, tableRef)\n            }\n          }\n\n          // End the otel spans\n          syncSpan.end()\n          commitsSpan.end()\n          queriesSpan.end()\n        }),\n      )\n\n      yield* this.syncProcessor.boot\n    })\n  }\n  // #endregion constructor\n\n  get sessionId(): string {\n    return this.clientSession.sessionId\n  }\n\n  get clientId(): string {\n    return this.clientSession.clientId\n  }\n\n  /**\n   * Subscribe to the results of a query\n   * Returns a function to cancel the subscription.\n   *\n   * @example\n   * ```ts\n   * const unsubscribe = store.subscribe(query$, { onUpdate: (result) => console.log(result) })\n   * ```\n   */\n  subscribe = <TResult>(\n    query: LiveQueryDef<TResult, 'def' | 'signal-def'> | LiveQuery<TResult>,\n    options: {\n      /** Called when the query result has changed */\n      onUpdate: (value: TResult) => void\n      onSubscribe?: (query$: LiveQuery<TResult>) => void\n      /** Gets called after the query subscription has been removed */\n      onUnsubsubscribe?: () => void\n      label?: string\n      /**\n       * Skips the initial `onUpdate` callback\n       * @default false\n       */\n      skipInitialRun?: boolean\n      otelContext?: otel.Context\n      /** If provided, the stack info will be added to the `activeSubscriptions` set of the query */\n      stackInfo?: StackInfo\n    },\n  ): Unsubscribe =>\n    this.otel.tracer.startActiveSpan(\n      `LiveStore.subscribe`,\n      { attributes: { label: options?.label, queryLabel: query.label } },\n      options?.otelContext ?? this.otel.queriesSpanContext,\n      (span) => {\n        // console.debug('store sub', query$.id, query$.label)\n        const otelContext = otel.trace.setSpan(otel.context.active(), span)\n\n        const queryRcRef =\n          query._tag === 'def' || query._tag === 'signal-def'\n            ? query.make(this.reactivityGraph.context!)\n            : {\n                value: query as LiveQuery<TResult>,\n                deref: () => {},\n              }\n        const query$ = queryRcRef.value\n\n        const label = `subscribe:${options?.label}`\n        const effect = this.reactivityGraph.makeEffect(\n          (get, _otelContext, debugRefreshReason) =>\n            options.onUpdate(get(query$.results$, otelContext, debugRefreshReason)),\n          { label },\n        )\n\n        if (options?.stackInfo) {\n          query$.activeSubscriptions.add(options.stackInfo)\n        }\n\n        options?.onSubscribe?.(query$)\n\n        this.activeQueries.add(query$ as LiveQuery<TResult>)\n\n        // Running effect right away to get initial value (unless `skipInitialRun` is set)\n        if (options?.skipInitialRun !== true && !query$.isDestroyed) {\n          effect.doEffect(otelContext, { _tag: 'subscribe.initial', label: `subscribe-initial-run:${options?.label}` })\n        }\n\n        const unsubscribe = () => {\n          // console.debug('store unsub', query$.id, query$.label)\n          try {\n            this.reactivityGraph.destroyNode(effect)\n            this.activeQueries.remove(query$ as LiveQuery<TResult>)\n\n            if (options?.stackInfo) {\n              query$.activeSubscriptions.delete(options.stackInfo)\n            }\n\n            queryRcRef.deref()\n\n            options?.onUnsubsubscribe?.()\n          } finally {\n            span.end()\n          }\n        }\n\n        return unsubscribe\n      },\n    )\n\n  subscribeStream = <TResult>(\n    query$: LiveQueryDef<TResult>,\n    options?: { label?: string; skipInitialRun?: boolean } | undefined,\n  ): Stream.Stream<TResult> =>\n    Stream.asyncPush<TResult>((emit) =>\n      Effect.gen(this, function* () {\n        const otelSpan = yield* OtelTracer.currentOtelSpan.pipe(\n          Effect.catchTag('NoSuchElementException', () => Effect.succeed(undefined)),\n        )\n        const otelContext = otelSpan ? otel.trace.setSpan(otel.context.active(), otelSpan) : otel.context.active()\n\n        yield* Effect.acquireRelease(\n          Effect.sync(() =>\n            this.subscribe(query$, {\n              onUpdate: (result) => emit.single(result),\n              otelContext,\n              label: options?.label,\n            }),\n          ),\n          (unsub) => Effect.sync(() => unsub()),\n        )\n      }),\n    )\n\n  /**\n   * Synchronously queries the database without creating a LiveQuery.\n   * This is useful for queries that don't need to be reactive.\n   *\n   * Example: Query builder\n   * ```ts\n   * const completedTodos = store.query(tables.todo.where({ complete: true }))\n   * ```\n   *\n   * Example: Raw SQL query\n   * ```ts\n   * const completedTodos = store.query({ query: 'SELECT * FROM todo WHERE complete = 1', bindValues: {} })\n   * ```\n   */\n  query = <TResult>(\n    query:\n      | QueryBuilder<TResult, any, any>\n      | LiveQuery<TResult>\n      | LiveQueryDef<TResult>\n      | SignalDef<TResult>\n      | { query: string; bindValues: ParamsObject },\n    options?: { otelContext?: otel.Context; debugRefreshReason?: RefreshReason },\n  ): TResult => {\n    if (typeof query === 'object' && 'query' in query && 'bindValues' in query) {\n      return this.sqliteDbWrapper.cachedSelect(query.query, prepareBindValues(query.bindValues, query.query), {\n        otelContext: options?.otelContext,\n      }) as any\n    } else if (isQueryBuilder(query)) {\n      const ast = query[QueryBuilderAstSymbol]\n      if (ast._tag === 'RowQuery') {\n        makeExecBeforeFirstRun({\n          table: ast.tableDef,\n          id: ast.id,\n          explicitDefaultValues: ast.explicitDefaultValues,\n          otelContext: options?.otelContext,\n        })(this.reactivityGraph.context!)\n      }\n\n      const sqlRes = query.asSql()\n      const schema = getResultSchema(query)\n      const rawRes = this.sqliteDbWrapper.cachedSelect(sqlRes.query, sqlRes.bindValues as any as PreparedBindValues, {\n        otelContext: options?.otelContext,\n        queriedTables: new Set([query[QueryBuilderAstSymbol].tableDef.sqliteDef.name]),\n      })\n\n      return Schema.decodeSync(schema)(rawRes)\n    } else if (query._tag === 'def') {\n      const query$ = query.make(this.reactivityGraph.context!)\n      const result = this.query(query$.value, options)\n      query$.deref()\n      return result\n    } else if (query._tag === 'signal-def') {\n      const signal$ = query.make(this.reactivityGraph.context!)\n      return signal$.value.get()\n    } else {\n      return query.run({ otelContext: options?.otelContext, debugRefreshReason: options?.debugRefreshReason })\n    }\n  }\n\n  /**\n   * Set the value of a signal\n   *\n   * @example\n   * ```ts\n   * const count$ = signal(0, { label: 'count$' })\n   * store.setSignal(count$, 2)\n   * ```\n   *\n   * @example\n   * ```ts\n   * const count$ = signal(0, { label: 'count$' })\n   * store.setSignal(count$, (prev) => prev + 1)\n   * ```\n   */\n  setSignal = <T>(signalDef: SignalDef<T>, value: T | ((prev: T) => T)): void => {\n    const signalRef = signalDef.make(this.reactivityGraph.context!)\n    const newValue: T = typeof value === 'function' ? (value as any)(signalRef.value.get()) : value\n    signalRef.value.set(newValue)\n\n    // The current implementation of signals i.e. the separation into `signal-def` and `signal`\n    // can lead to a situation where a reffed signal is immediately de-reffed when calling `store.setSignal`,\n    // in case there is nothing else holding a reference to the signal which leads to the set value being \"lost\".\n    // To avoid this, we don't deref the signal here if this set call is the only reference to the signal.\n    // Hopefully this won't lead to any issues in the future. 🤞\n    if (signalRef.rc > 1) {\n      signalRef.deref()\n    }\n  }\n\n  // #region commit\n  /**\n   * Commit a list of events to the store which will immediately update the local database\n   * and sync the events across other clients (similar to a `git commit`).\n   *\n   * @example\n   * ```ts\n   * store.commit(events.todoCreated({ id: nanoid(), text: 'Make coffee' }))\n   * ```\n   *\n   * You can call `commit` with multiple events to apply them in a single database transaction.\n   *\n   * @example\n   * ```ts\n   * const todoId = nanoid()\n   * store.commit(\n   *   events.todoCreated({ id: todoId, text: 'Make coffee' }),\n   *   events.todoCompleted({ id: todoId }))\n   * ```\n   *\n   * For more advanced transaction scenarios, you can pass a synchronous function to `commit` which will receive a callback\n   * to which you can pass multiple events to be committed in the same database transaction.\n   * Under the hood this will simply collect all events and apply them in a single database transaction.\n   *\n   * @example\n   * ```ts\n   * store.commit((commit) => {\n   *   const todoId = nanoid()\n   *   if (Math.random() > 0.5) {\n   *     commit(events.todoCreated({ id: todoId, text: 'Make coffee' }))\n   *   } else {\n   *     commit(events.todoCompleted({ id: todoId }))\n   *   }\n   * })\n   * ```\n   *\n   * When committing a large batch of events, you can also skip the database refresh to improve performance\n   * and call `store.manualRefresh()` after all events have been committed.\n   *\n   * @example\n   * ```ts\n   * const todos = [\n   *   { id: nanoid(), text: 'Make coffee' },\n   *   { id: nanoid(), text: 'Buy groceries' },\n   *   // ... 1000 more todos\n   * ]\n   * for (const todo of todos) {\n   *   store.commit({ skipRefresh: true }, events.todoCreated({ id: todo.id, text: todo.text }))\n   * }\n   * store.manualRefresh()\n   * ```\n   */\n  commit: {\n    <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(...list: TCommitArg): void\n    (\n      txn: <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(\n        ...list: TCommitArg\n      ) => void,\n    ): void\n    <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(\n      options: StoreCommitOptions,\n      ...list: TCommitArg\n    ): void\n    (\n      options: StoreCommitOptions,\n      txn: <const TCommitArg extends ReadonlyArray<LiveStoreEvent.PartialForSchema<TSchema>>>(\n        ...list: TCommitArg\n      ) => void,\n    ): void\n  } = (firstEventOrTxnFnOrOptions: any, ...restEvents: any[]) => {\n    const { events, options } = this.getCommitArgs(firstEventOrTxnFnOrOptions, restEvents)\n\n    for (const event of events) {\n      replaceSessionIdSymbol(event.args, this.clientSession.sessionId)\n    }\n\n    if (events.length === 0) return\n\n    const skipRefresh = options?.skipRefresh ?? false\n\n    const commitsSpan = otel.trace.getSpan(this.otel.commitsSpanContext)!\n    commitsSpan.addEvent('commit')\n\n    // console.group('LiveStore.commit', { skipRefresh })\n    // events.forEach((_) => console.debug(_.name, _.args))\n    // console.groupEnd()\n\n    let durationMs: number\n\n    return this.otel.tracer.startActiveSpan(\n      'LiveStore:commit',\n      {\n        attributes: {\n          'livestore.eventsCount': events.length,\n          'livestore.eventTags': events.map((_) => _.name),\n          'livestore.commitLabel': options?.label,\n        },\n        links: options?.spanLinks,\n      },\n      options?.otelContext ?? this.otel.commitsSpanContext,\n      (span) => {\n        const otelContext = otel.trace.setSpan(otel.context.active(), span)\n\n        try {\n          // Materialize events to state\n          const { writeTables } = (() => {\n            try {\n              const materializeEvents = () => this.syncProcessor.push(events, { otelContext })\n\n              if (events.length > 1) {\n                return this.sqliteDbWrapper.txn(materializeEvents)\n              } else {\n                return materializeEvents()\n              }\n            } catch (e: any) {\n              console.error(e)\n              span.setStatus({ code: otel.SpanStatusCode.ERROR, message: e.toString() })\n              throw e\n            } finally {\n              span.end()\n            }\n          })()\n\n          const tablesToUpdate = [] as [Ref<null, ReactivityGraphContext, RefreshReason>, null][]\n          for (const tableName of writeTables) {\n            const tableRef = this.tableRefs[tableName]\n            assertNever(tableRef !== undefined, `No table ref found for ${tableName}`)\n            tablesToUpdate.push([tableRef!, null])\n          }\n\n          const debugRefreshReason = {\n            _tag: 'commit' as const,\n            events,\n            writeTables: Array.from(writeTables),\n          }\n\n          // Update all table refs together in a batch, to only trigger one reactive update\n          this.reactivityGraph.setRefs(tablesToUpdate, { debugRefreshReason, otelContext, skipRefresh })\n        } catch (e: any) {\n          console.error(e)\n          span.setStatus({ code: otel.SpanStatusCode.ERROR, message: e.toString() })\n          throw e\n        } finally {\n          span.end()\n\n          durationMs = getDurationMsFromSpan(span)\n        }\n\n        return { durationMs }\n      },\n    )\n  }\n  // #endregion commit\n\n  /**\n   * Returns an async iterable of events.\n   *\n   * @example\n   * ```ts\n   * for await (const event of store.events()) {\n   *   console.log(event)\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Get all events from the beginning of time\n   * for await (const event of store.events({ cursor: EventSequenceNumber.ROOT })) {\n   *   console.log(event)\n   * }\n   * ```\n   */\n  events = (_options?: StoreEventsOptions<TSchema>): AsyncIterable<LiveStoreEvent.ForSchema<TSchema>> => {\n    return notYetImplemented(`store.events() is not yet implemented but planned soon`)\n  }\n\n  eventsStream = (_options?: StoreEventsOptions<TSchema>): Stream.Stream<LiveStoreEvent.ForSchema<TSchema>> => {\n    return notYetImplemented(`store.eventsStream() is not yet implemented but planned soon`)\n  }\n\n  /**\n   * This can be used in combination with `skipRefresh` when committing events.\n   * We might need a better solution for this. Let's see.\n   */\n  manualRefresh = (options?: { label?: string }) => {\n    const { label } = options ?? {}\n    this.otel.tracer.startActiveSpan(\n      'LiveStore:manualRefresh',\n      { attributes: { 'livestore.manualRefreshLabel': label } },\n      this.otel.commitsSpanContext,\n      (span) => {\n        const otelContext = otel.trace.setSpan(otel.context.active(), span)\n        this.reactivityGraph.runDeferredEffects({ otelContext })\n        span.end()\n      },\n    )\n  }\n\n  /**\n   * Shuts down the store and closes the client session.\n   *\n   * This is called automatically when the store was created using the React or Effect API.\n   */\n  shutdown = async (cause?: Cause.Cause<UnexpectedError>) => {\n    await this.clientSession\n      .shutdown(cause ?? Cause.fail(IntentionalShutdownCause.make({ reason: 'manual' })))\n      .pipe(this.runEffectFork, Fiber.join, Effect.runPromise)\n  }\n\n  /**\n   * Helper methods useful during development\n   *\n   * @internal\n   */\n  _dev = {\n    downloadDb: (source: 'local' | 'leader' = 'local') => {\n      Effect.gen(this, function* () {\n        const data = source === 'local' ? this.sqliteDbWrapper.export() : yield* this.clientSession.leaderThread.export\n        downloadBlob(data, `livestore-${Date.now()}.db`)\n      }).pipe(this.runEffectFork)\n    },\n\n    downloadEventlogDb: () => {\n      Effect.gen(this, function* () {\n        const data = yield* this.clientSession.leaderThread.getEventlogData\n        downloadBlob(data, `livestore-eventlog-${Date.now()}.db`)\n      }).pipe(this.runEffectFork)\n    },\n\n    hardReset: (mode: 'all-data' | 'only-app-db' = 'all-data') => {\n      Effect.gen(this, function* () {\n        const clientId = this.clientSession.clientId\n        yield* this.clientSession.leaderThread.sendDevtoolsMessage(\n          Devtools.Leader.ResetAllData.Request.make({ liveStoreVersion, mode, requestId: nanoid(), clientId }),\n        )\n      }).pipe(this.runEffectFork)\n    },\n\n    overrideNetworkStatus: (status: 'online' | 'offline') => {\n      const clientId = this.clientSession.clientId\n      this.clientSession.leaderThread\n        .sendDevtoolsMessage(\n          Devtools.Leader.SetSyncLatch.Request.make({\n            clientId,\n            closeLatch: status === 'offline',\n            liveStoreVersion,\n            requestId: nanoid(),\n          }),\n        )\n        .pipe(this.runEffectFork)\n    },\n\n    syncStates: () => {\n      Effect.gen(this, function* () {\n        const session = yield* this.syncProcessor.syncState\n        console.log('Session sync state:', session.toJSON())\n        const leader = yield* this.clientSession.leaderThread.getSyncState\n        console.log('Leader sync state:', leader.toJSON())\n      }).pipe(this.runEffectFork)\n    },\n\n    version: liveStoreVersion,\n\n    otel: {\n      rootSpanContext: () => otel.trace.getSpan(this.otel.rootSpanContext)?.spanContext(),\n    },\n  }\n\n  // NOTE This is needed because when booting a Store via Effect it seems to call `toJSON` in the error path\n  toJSON = () => ({\n    _tag: 'livestore.Store',\n    reactivityGraph: this.reactivityGraph.getSnapshot({ includeResults: true }),\n  })\n\n  private runEffectFork = <A, E>(effect: Effect.Effect<A, E, Scope.Scope>) =>\n    effect.pipe(\n      Effect.forkIn(this.effectContext.lifetimeScope),\n      Effect.tapCauseLogPretty,\n      Runtime.runFork(this.effectContext.runtime),\n    )\n\n  private getCommitArgs = (\n    firstEventOrTxnFnOrOptions: any,\n    restEvents: any[],\n  ): {\n    events: LiveStoreEvent.PartialForSchema<TSchema>[]\n    options: StoreCommitOptions | undefined\n  } => {\n    let events: LiveStoreEvent.PartialForSchema<TSchema>[]\n    let options: StoreCommitOptions | undefined\n\n    if (typeof firstEventOrTxnFnOrOptions === 'function') {\n      // TODO ensure that function is synchronous and isn't called in a async way (also write tests for this)\n      events = firstEventOrTxnFnOrOptions((arg: any) => events.push(arg))\n    } else if (\n      firstEventOrTxnFnOrOptions?.label !== undefined ||\n      firstEventOrTxnFnOrOptions?.skipRefresh !== undefined ||\n      firstEventOrTxnFnOrOptions?.otelContext !== undefined ||\n      firstEventOrTxnFnOrOptions?.spanLinks !== undefined\n    ) {\n      options = firstEventOrTxnFnOrOptions\n      events = restEvents\n    } else if (firstEventOrTxnFnOrOptions === undefined) {\n      // When `commit` is called with no arguments (which sometimes happens when dynamically filtering events)\n      events = []\n    } else {\n      events = [firstEventOrTxnFnOrOptions, ...restEvents]\n    }\n\n    // for (const event of events) {\n    //   if (event.args.id === SessionIdSymbol) {\n    //     event.args.id = this.clientSession.sessionId\n    //   }\n    // }\n\n    return { events, options }\n  }\n}\n", "import type { ClientSession, ClientSessionSyncProcessor, DebugInfo, SyncState } from '@livestore/common'\nimport { Devtools, liveStoreVersion, UnexpectedError } from '@livestore/common'\nimport { throttle } from '@livestore/utils'\nimport type { WebChannel } from '@livestore/utils/effect'\nimport { Effect, Stream } from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\n\nimport type { LiveQuery, ReactivityGraph } from '../live-queries/base-class.js'\nimport { NOT_REFRESHED_YET } from '../reactive.js'\nimport type { SqliteDbWrapper } from '../SqliteDbWrapper.js'\nimport { emptyDebugInfo as makeEmptyDebugInfo } from '../SqliteDbWrapper.js'\nimport type { ReferenceCountedSet } from '../utils/data-structures.js'\n\ntype IStore = {\n  clientSession: ClientSession\n  reactivityGraph: ReactivityGraph\n  sqliteDbWrapper: SqliteDbWrapper\n  activeQueries: ReferenceCountedSet<LiveQuery<any>>\n  syncProcessor: ClientSessionSyncProcessor\n}\n\ntype Unsub = () => void\ntype RequestId = string\ntype SubMap = Map<RequestId, Unsub>\n\n// When running this code in Node.js, we need to use `setTimeout` instead of `requestAnimationFrame`\nconst requestNextTick: (cb: () => void) => number =\n  globalThis.requestAnimationFrame === undefined\n    ? (cb: () => void) => setTimeout(cb, 1000) as unknown as number\n    : globalThis.requestAnimationFrame\n\nconst cancelTick: (id: number) => void =\n  globalThis.cancelAnimationFrame === undefined ? (id: number) => clearTimeout(id) : globalThis.cancelAnimationFrame\n\nexport const connectDevtoolsToStore = ({\n  storeDevtoolsChannel,\n  store,\n}: {\n  storeDevtoolsChannel: WebChannel.WebChannel<\n    Devtools.ClientSession.MessageToApp,\n    Devtools.ClientSession.MessageFromApp\n  >\n  store: IStore\n}) =>\n  Effect.gen(function* () {\n    const reactivityGraphSubcriptions: SubMap = new Map()\n    const liveQueriesSubscriptions: SubMap = new Map()\n    const debugInfoHistorySubscriptions: SubMap = new Map()\n    const syncHeadClientSessionSubscriptions: SubMap = new Map()\n\n    const { clientId, sessionId } = store.clientSession\n\n    yield* Effect.addFinalizer(() =>\n      Effect.sync(() => {\n        for (const unsub of reactivityGraphSubcriptions.values()) unsub()\n        for (const unsub of liveQueriesSubscriptions.values()) unsub()\n        for (const unsub of debugInfoHistorySubscriptions.values()) unsub()\n        for (const unsub of syncHeadClientSessionSubscriptions.values()) unsub()\n      }),\n    )\n\n    const handledRequestIds = new Set<RequestId>()\n\n    const sendToDevtools = (message: Devtools.ClientSession.MessageFromApp) =>\n      storeDevtoolsChannel.send(message).pipe(Effect.tapCauseLogPretty, Effect.runFork)\n\n    const onMessage = (decodedMessage: typeof Devtools.ClientSession.MessageToApp.Type) => {\n      // console.debug('@livestore/livestore:store:devtools:onMessage', decodedMessage)\n\n      if (decodedMessage.clientId !== clientId || decodedMessage.sessionId !== sessionId) {\n        // console.log(`Unknown message`, event)\n        return\n      }\n\n      if (decodedMessage._tag === 'LSD.ClientSession.Disconnect') {\n        // console.error('TODO handle disconnect properly in store')\n        return\n      }\n\n      const requestId = decodedMessage.requestId\n\n      // TODO we should try to move the duplicate message handling on the webmesh layer\n      // So far I could only observe this problem with webmesh proxy channels (e.g. for Expo)\n      // Proof: https://share.cleanshot.com/V9G87B0B\n      // Also see `leader-worker-devtools.ts` for same problem\n      if (handledRequestIds.has(requestId)) {\n        return\n      }\n\n      handledRequestIds.add(requestId)\n\n      const requestIdleCallback = globalThis.requestIdleCallback ?? ((cb: () => void) => cb())\n\n      switch (decodedMessage._tag) {\n        case 'LSD.ClientSession.ReactivityGraphSubscribe': {\n          const includeResults = decodedMessage.includeResults\n          const { subscriptionId } = decodedMessage\n\n          const send = () =>\n            // In order to not add more work to the current tick, we use requestIdleCallback\n            // to send the reactivity graph updates to the devtools\n            requestIdleCallback(\n              () =>\n                sendToDevtools(\n                  Devtools.ClientSession.ReactivityGraphRes.make({\n                    reactivityGraph: store.reactivityGraph.getSnapshot({ includeResults }),\n                    requestId: nanoid(10),\n                    clientId,\n                    sessionId,\n                    liveStoreVersion,\n                    subscriptionId,\n                  }),\n                ),\n              { timeout: 500 },\n            )\n\n          send()\n\n          // In some cases, there can be A LOT of reactivity graph updates in a short period of time\n          // so we throttle the updates to avoid sending too much data\n          // This might need to be tweaked further and possibly be exposed to the user in some way.\n          const throttledSend = throttle(send, 20)\n\n          reactivityGraphSubcriptions.set(subscriptionId, store.reactivityGraph.subscribeToRefresh(throttledSend))\n\n          break\n        }\n        case 'LSD.ClientSession.DebugInfoReq': {\n          sendToDevtools(\n            Devtools.ClientSession.DebugInfoRes.make({\n              debugInfo: store.sqliteDbWrapper.debugInfo,\n              requestId,\n              clientId,\n              sessionId,\n              liveStoreVersion,\n            }),\n          )\n          break\n        }\n        case 'LSD.ClientSession.DebugInfoHistorySubscribe': {\n          const { subscriptionId } = decodedMessage\n          const buffer: DebugInfo[] = []\n          let hasStopped = false\n          let tickHandle: number | undefined\n\n          const tick = () => {\n            buffer.push(store.sqliteDbWrapper.debugInfo)\n\n            // NOTE this resets the debug info, so all other \"readers\" e.g. in other `requestAnimationFrame` loops,\n            // will get the empty debug info\n            // TODO We need to come up with a more graceful way to do store. Probably via a single global\n            // `requestAnimationFrame` loop that is passed in somehow.\n            store.sqliteDbWrapper.debugInfo = makeEmptyDebugInfo()\n\n            if (buffer.length > 10) {\n              sendToDevtools(\n                Devtools.ClientSession.DebugInfoHistoryRes.make({\n                  debugInfoHistory: buffer,\n                  requestId: nanoid(10),\n                  clientId,\n                  sessionId,\n                  liveStoreVersion,\n                  subscriptionId,\n                }),\n              )\n              buffer.length = 0\n            }\n\n            if (hasStopped === false) {\n              tickHandle = requestNextTick(tick)\n            }\n          }\n\n          tickHandle = requestNextTick(tick)\n\n          const unsub = () => {\n            hasStopped = true\n            if (tickHandle !== undefined) {\n              cancelTick(tickHandle)\n              tickHandle = undefined\n            }\n          }\n\n          debugInfoHistorySubscriptions.set(subscriptionId, unsub)\n\n          break\n        }\n        case 'LSD.ClientSession.DebugInfoHistoryUnsubscribe': {\n          const { subscriptionId } = decodedMessage\n          // NOTE given Webmesh channels have persistent retry behaviour, it can happen that a previous\n          // Webmesh channel will send a unsubscribe message for an old requestId. Thus the `?.()` handling.\n          debugInfoHistorySubscriptions.get(subscriptionId)?.()\n          debugInfoHistorySubscriptions.delete(subscriptionId)\n          break\n        }\n        case 'LSD.ClientSession.DebugInfoResetReq': {\n          store.sqliteDbWrapper.debugInfo.slowQueries.clear()\n          sendToDevtools(\n            Devtools.ClientSession.DebugInfoResetRes.make({ requestId, clientId, sessionId, liveStoreVersion }),\n          )\n          break\n        }\n        case 'LSD.ClientSession.DebugInfoRerunQueryReq': {\n          const { queryStr, bindValues, queriedTables } = decodedMessage\n          store.sqliteDbWrapper.cachedSelect(queryStr, bindValues, { queriedTables, skipCache: true })\n          sendToDevtools(\n            Devtools.ClientSession.DebugInfoRerunQueryRes.make({ requestId, clientId, sessionId, liveStoreVersion }),\n          )\n          break\n        }\n        case 'LSD.ClientSession.ReactivityGraphUnsubscribe': {\n          const { subscriptionId } = decodedMessage\n          // NOTE given Webmesh channels have persistent retry behaviour, it can happen that a previous\n          // Webmesh channel will send a unsubscribe message for an old requestId. Thus the `?.()` handling.\n          reactivityGraphSubcriptions.get(subscriptionId)?.()\n          reactivityGraphSubcriptions.delete(subscriptionId)\n          break\n        }\n        case 'LSD.ClientSession.LiveQueriesSubscribe': {\n          const { subscriptionId } = decodedMessage\n          const send = () =>\n            requestIdleCallback(\n              () =>\n                sendToDevtools(\n                  Devtools.ClientSession.LiveQueriesRes.make({\n                    liveQueries: [...store.activeQueries].map((q) => ({\n                      _tag: q._tag,\n                      id: q.id,\n                      label: q.label,\n                      hash: q.def.hash,\n                      runs: q.runs,\n                      executionTimes: q.executionTimes.map((_) => Number(_.toString().slice(0, 5))),\n                      lastestResult:\n                        q.results$.previousResult === NOT_REFRESHED_YET\n                          ? 'SYMBOL_NOT_REFRESHED_YET'\n                          : q.results$.previousResult,\n                      activeSubscriptions: Array.from(q.activeSubscriptions),\n                    })),\n                    requestId: nanoid(10),\n                    liveStoreVersion,\n                    clientId,\n                    sessionId,\n                    subscriptionId,\n                  }),\n                ),\n              { timeout: 500 },\n            )\n\n          send()\n\n          // Same as in the reactivity graph subscription case above, we need to throttle the updates\n          const throttledSend = throttle(send, 20)\n\n          liveQueriesSubscriptions.set(subscriptionId, store.reactivityGraph.subscribeToRefresh(throttledSend))\n\n          break\n        }\n        case 'LSD.ClientSession.LiveQueriesUnsubscribe': {\n          const { subscriptionId } = decodedMessage\n          // NOTE given Webmesh channels have persistent retry behaviour, it can happen that a previous\n          // Webmesh channel will send a unsubscribe message for an old requestId. Thus the `?.()` handling.\n          liveQueriesSubscriptions.get(subscriptionId)?.()\n          liveQueriesSubscriptions.delete(subscriptionId)\n          break\n        }\n        case 'LSD.ClientSession.SyncHeadSubscribe': {\n          const { subscriptionId } = decodedMessage\n          const send = (syncState: SyncState.SyncState) =>\n            sendToDevtools(\n              Devtools.ClientSession.SyncHeadRes.make({\n                local: syncState.localHead,\n                upstream: syncState.upstreamHead,\n                requestId: nanoid(10),\n                clientId,\n                sessionId,\n                liveStoreVersion,\n                subscriptionId,\n              }),\n            )\n\n          send(store.syncProcessor.syncState.pipe(Effect.runSync))\n\n          syncHeadClientSessionSubscriptions.set(\n            subscriptionId,\n            store.syncProcessor.syncState.changes.pipe(\n              Stream.tap((syncState) => send(syncState)),\n              Stream.runDrain,\n              Effect.interruptible,\n              Effect.tapCauseLogPretty,\n              Effect.runCallback,\n            ),\n          )\n\n          break\n        }\n        case 'LSD.ClientSession.SyncHeadUnsubscribe': {\n          const { subscriptionId } = decodedMessage\n          // NOTE given Webmesh channels have persistent retry behaviour, it can happen that a previous\n          // Webmesh channel will send a unsubscribe message for an old requestId. Thus the `?.()` handling.\n          syncHeadClientSessionSubscriptions.get(subscriptionId)?.()\n          syncHeadClientSessionSubscriptions.delete(subscriptionId)\n          break\n        }\n        case 'LSD.ClientSession.Ping': {\n          sendToDevtools(Devtools.ClientSession.Pong.make({ requestId, clientId, sessionId, liveStoreVersion }))\n          break\n        }\n        default: {\n          console.warn(`[LSD.ClientSession] Unknown message`, decodedMessage)\n        }\n      }\n    }\n\n    yield* storeDevtoolsChannel.listen.pipe(\n      // Stream.tapLogWithLabel('@livestore/livestore:store:devtools:onMessage'),\n      Stream.flatten(),\n      Stream.tapSync((message) => onMessage(message)),\n      Stream.runDrain,\n      Effect.withSpan('LSD.devtools.onMessage'),\n    )\n  }).pipe(UnexpectedError.mapToUnexpectedError, Effect.withSpan('LSD.devtools.connectStoreToDevtools'))\n", "import type {\n  Adapter,\n  BootStatus,\n  ClientSession,\n  ClientSessionDevtoolsChannel,\n  IntentionalShutdownCause,\n  MigrationsReport,\n} from '@livestore/common'\nimport { provideOtel, UnexpectedError } from '@livestore/common'\nimport type { LiveStoreSchema } from '@livestore/common/schema'\nimport { isDevEnv, LS_DEV } from '@livestore/utils'\nimport type { Cause, Schema } from '@livestore/utils/effect'\nimport {\n  Context,\n  Deferred,\n  Effect,\n  Exit,\n  Fiber,\n  identity,\n  Layer,\n  Logger,\n  LogLevel,\n  OtelTracer,\n  Queue,\n  Runtime,\n  Scope,\n  TaskTracing,\n} from '@livestore/utils/effect'\nimport { nanoid } from '@livestore/utils/nanoid'\nimport * as otel from '@opentelemetry/api'\n\nimport { connectDevtoolsToStore } from './devtools.js'\nimport { Store } from './store.js'\nimport type {\n  LiveStoreContextRunning as LiveStoreContextRunning_,\n  OtelOptions,\n  ShutdownDeferred,\n} from './store-types.js'\n\nexport const DEFAULT_PARAMS = {\n  leaderPushBatchSize: 100,\n}\n\nexport class LiveStoreContextRunning extends Context.Tag('@livestore/livestore/effect/LiveStoreContextRunning')<\n  LiveStoreContextRunning,\n  LiveStoreContextRunning_\n>() {\n  static fromDeferred = Effect.gen(function* () {\n    const deferred = yield* DeferredStoreContext\n    const ctx = yield* deferred\n    return Layer.succeed(LiveStoreContextRunning, ctx)\n  }).pipe(Layer.unwrapScoped)\n}\n\nexport class DeferredStoreContext extends Context.Tag('@livestore/livestore/effect/DeferredStoreContext')<\n  DeferredStoreContext,\n  Deferred.Deferred<LiveStoreContextRunning['Type'], UnexpectedError>\n>() {}\n\nexport type LiveStoreContextProps<TSchema extends LiveStoreSchema, TContext = {}> = {\n  schema: TSchema\n  /**\n   * The `storeId` can be used to isolate multiple stores from each other.\n   * So it can be useful for multi-tenancy scenarios.\n   *\n   * The `storeId` is also used for persistence.\n   *\n   * @default 'default'\n   */\n  storeId?: string\n  /** Can be useful for custom live query implementations (e.g. see `@livestore/graphql`) */\n  context?: TContext\n  boot?: (\n    store: Store<TSchema, TContext>,\n  ) => Effect.Effect<void, unknown, OtelTracer.OtelTracer | LiveStoreContextRunning>\n  adapter: Adapter\n  /**\n   * Whether to disable devtools.\n   *\n   * @default 'auto'\n   */\n  disableDevtools?: boolean | 'auto'\n  onBootStatus?: (status: BootStatus) => void\n  batchUpdates: (run: () => void) => void\n}\n\nexport interface CreateStoreOptions<TSchema extends LiveStoreSchema, TContext = {}> {\n  schema: TSchema\n  adapter: Adapter\n  storeId: string\n  context?: TContext\n  boot?: (\n    store: Store<TSchema, TContext>,\n    ctx: {\n      migrationsReport: MigrationsReport\n      parentSpan: otel.Span\n    },\n  ) => void | Promise<void> | Effect.Effect<void, unknown, OtelTracer.OtelTracer | LiveStoreContextRunning>\n  batchUpdates?: (run: () => void) => void\n  /**\n   * Whether to disable devtools.\n   *\n   * @default 'auto'\n   */\n  disableDevtools?: boolean | 'auto'\n  onBootStatus?: (status: BootStatus) => void\n  shutdownDeferred?: ShutdownDeferred\n  /**\n   * Currently only used in the web adapter:\n   * If true, registers a beforeunload event listener to confirm unsaved changes.\n   *\n   * @default true\n   */\n  confirmUnsavedChanges?: boolean\n  /**\n   * Payload that will be passed to the sync backend when connecting\n   *\n   * @default undefined\n   */\n  syncPayload?: Schema.JsonValue\n  params?: {\n    leaderPushBatchSize?: number\n  }\n  debug?: {\n    instanceId?: string\n  }\n}\n\n/** Create a new LiveStore Store */\nexport const createStorePromise = async <TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}>({\n  signal,\n  otelOptions,\n  ...options\n}: CreateStoreOptions<TSchema, TContext> & {\n  signal?: AbortSignal\n  otelOptions?: Partial<OtelOptions>\n}): Promise<Store<TSchema, TContext>> =>\n  Effect.gen(function* () {\n    const scope = yield* Scope.make()\n    const runtime = yield* Effect.runtime()\n\n    if (signal !== undefined) {\n      signal.addEventListener('abort', () => {\n        Scope.close(scope, Exit.void).pipe(Effect.tapCauseLogPretty, Runtime.runFork(runtime))\n      })\n    }\n\n    return yield* createStore({ ...options }).pipe(Scope.extend(scope))\n  }).pipe(\n    Effect.withSpan('createStore', {\n      attributes: { storeId: options.storeId, disableDevtools: options.disableDevtools },\n    }),\n    provideOtel({ parentSpanContext: otelOptions?.rootSpanContext, otelTracer: otelOptions?.tracer }),\n    Effect.tapCauseLogPretty,\n    Effect.annotateLogs({ thread: 'window' }),\n    Effect.provide(Logger.prettyWithThread('window')),\n    Logger.withMinimumLogLevel(LogLevel.Debug),\n    Effect.runPromise,\n  )\n\nexport const createStore = <TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}>({\n  schema,\n  adapter,\n  storeId,\n  context = {} as TContext,\n  boot,\n  batchUpdates,\n  disableDevtools,\n  onBootStatus,\n  shutdownDeferred,\n  params,\n  debug,\n  confirmUnsavedChanges = true,\n  syncPayload,\n}: CreateStoreOptions<TSchema, TContext>): Effect.Effect<\n  Store<TSchema, TContext>,\n  UnexpectedError,\n  Scope.Scope | OtelTracer.OtelTracer\n> =>\n  Effect.gen(function* () {\n    const lifetimeScope = yield* Scope.make()\n\n    yield* validateStoreId(storeId)\n\n    yield* Effect.addFinalizer((_) => Scope.close(lifetimeScope, _))\n\n    const debugInstanceId = debug?.instanceId ?? nanoid(10)\n\n    return yield* Effect.gen(function* () {\n      const span = yield* OtelTracer.currentOtelSpan.pipe(Effect.orDie)\n      const otelRootSpanContext = otel.trace.setSpan(otel.context.active(), span)\n      const otelTracer = yield* OtelTracer.OtelTracer\n\n      const bootStatusQueue = yield* Queue.unbounded<BootStatus>().pipe(Effect.acquireRelease(Queue.shutdown))\n\n      yield* Queue.take(bootStatusQueue).pipe(\n        Effect.tapSync((status) => onBootStatus?.(status)),\n        Effect.tap((status) => (status.stage === 'done' ? Queue.shutdown(bootStatusQueue) : Effect.void)),\n        Effect.forever,\n        Effect.tapCauseLogPretty,\n        Effect.forkScoped,\n      )\n\n      const storeDeferred = yield* Deferred.make<Store>()\n\n      const connectDevtoolsToStore_ = (storeDevtoolsChannel: ClientSessionDevtoolsChannel) =>\n        Effect.gen(function* () {\n          const store = yield* storeDeferred\n          yield* connectDevtoolsToStore({ storeDevtoolsChannel, store })\n        })\n\n      const runtime = yield* Effect.runtime<Scope.Scope>()\n\n      const shutdown = (cause: Cause.Cause<UnexpectedError | IntentionalShutdownCause>) =>\n        Effect.gen(function* () {\n          yield* Scope.close(lifetimeScope, Exit.failCause(cause)).pipe(\n            Effect.logWarnIfTakesLongerThan({ label: '@livestore/livestore:shutdown', duration: 500 }),\n            Effect.timeout(1000),\n            Effect.catchTag('TimeoutException', () =>\n              Effect.logError('@livestore/livestore:shutdown: Timed out after 1 second'),\n            ),\n          )\n\n          if (shutdownDeferred) {\n            yield* Deferred.failCause(shutdownDeferred, cause)\n          }\n\n          yield* Effect.logDebug('LiveStore shutdown complete')\n        }).pipe(\n          Effect.withSpan('@livestore/livestore:shutdown'),\n          Effect.provide(runtime),\n          Effect.tapCauseLogPretty,\n          // Given that the shutdown flow might also interrupt the effect that is calling the shutdown,\n          // we want to detach the shutdown effect so it's not interrupted by itself\n          Effect.runFork,\n          Fiber.join,\n        )\n\n      const clientSession: ClientSession = yield* adapter({\n        schema,\n        storeId,\n        devtoolsEnabled: getDevtoolsEnabled(disableDevtools),\n        bootStatusQueue,\n        shutdown,\n        connectDevtoolsToStore: connectDevtoolsToStore_,\n        debugInstanceId,\n        syncPayload,\n      }).pipe(Effect.withPerformanceMeasure('livestore:makeAdapter'), Effect.withSpan('createStore:makeAdapter'))\n\n      if (LS_DEV && clientSession.leaderThread.initialState.migrationsReport.migrations.length > 0) {\n        yield* Effect.logDebug(\n          '[@livestore/livestore:createStore] migrationsReport',\n          ...clientSession.leaderThread.initialState.migrationsReport.migrations.map((m) =>\n            m.hashes.actual === undefined\n              ? `Table '${m.tableName}' doesn't exist yet. Creating table...`\n              : `Schema hash mismatch for table '${m.tableName}' (DB: ${m.hashes.actual}, expected: ${m.hashes.expected}), migrating table...`,\n          ),\n        )\n      }\n\n      const store = new Store<TSchema, TContext>({\n        clientSession,\n        schema,\n        context,\n        otelOptions: { tracer: otelTracer, rootSpanContext: otelRootSpanContext },\n        effectContext: { lifetimeScope, runtime },\n        // TODO find a better way to detect if we're running LiveStore in the LiveStore devtools\n        // But for now this is a good enough approximation with little downsides\n        __runningInDevtools: getDevtoolsEnabled(disableDevtools) === false,\n        confirmUnsavedChanges,\n        // NOTE during boot we're not yet executing events in a batched context\n        // but only set the provided `batchUpdates` function after boot\n        batchUpdates: (run) => run(),\n        storeId,\n        params: {\n          leaderPushBatchSize: params?.leaderPushBatchSize ?? DEFAULT_PARAMS.leaderPushBatchSize,\n        },\n      })\n\n      // Starts background fibers (syncing, event processing, etc) for store\n      yield* store.boot\n\n      if (boot !== undefined) {\n        // TODO also incorporate `boot` function progress into `bootStatusQueue`\n        yield* Effect.tryAll(() =>\n          boot(store, { migrationsReport: clientSession.leaderThread.initialState.migrationsReport, parentSpan: span }),\n        ).pipe(\n          UnexpectedError.mapToUnexpectedError,\n          Effect.provide(Layer.succeed(LiveStoreContextRunning, { stage: 'running', store: store as any as Store })),\n          Effect.withSpan('createStore:boot'),\n        )\n      }\n\n      // NOTE it's important to yield here to allow the forked Effect in the store constructor to run\n      yield* Effect.yieldNow()\n\n      if (batchUpdates !== undefined) {\n        // Replacing the default batchUpdates function with the provided one after boot\n        store.reactivityGraph.context!.effectsWrapper = batchUpdates\n      }\n\n      yield* Deferred.succeed(storeDeferred, store as any as Store)\n\n      return store\n    }).pipe(\n      Effect.withSpan('createStore', { attributes: { debugInstanceId, storeId } }),\n      Effect.annotateLogs({ debugInstanceId, storeId }),\n      LS_DEV ? TaskTracing.withAsyncTaggingTracing((name) => (console as any).createTask(name)) : identity,\n      Scope.extend(lifetimeScope),\n    )\n  })\n\nconst validateStoreId = (storeId: string) =>\n  Effect.gen(function* () {\n    const validChars = /^[a-zA-Z0-9_-]+$/\n\n    if (!validChars.test(storeId)) {\n      return yield* UnexpectedError.make({\n        cause: `Invalid storeId: ${storeId}. Only alphanumeric characters, underscores, and hyphens are allowed.`,\n        payload: { storeId },\n      })\n    }\n  })\n\nconst getDevtoolsEnabled = (disableDevtools: boolean | 'auto' | undefined) => {\n  // If an explicit value is provided, use that\n  if (disableDevtools === true || disableDevtools === false) {\n    return !disableDevtools\n  }\n\n  if (isDevEnv() === true) {\n    return true\n  }\n\n  return false\n}\n", "import type { ClientSession, IntentionalShutdownCause, StoreInterrupted, UnexpectedError } from '@livestore/common'\nimport type { EventSequenceNumber, LiveStoreEvent, LiveStoreSchema } from '@livestore/common/schema'\nimport type { Effect, Runtime, Scope } from '@livestore/utils/effect'\nimport { Deferred } from '@livestore/utils/effect'\nimport type * as otel from '@opentelemetry/api'\n\nimport type { DebugRefreshReasonBase } from '../reactive.js'\nimport type { StackInfo } from '../utils/stack-info.js'\nimport type { Store } from './store.js'\n\nexport type LiveStoreContext =\n  | LiveStoreContextRunning\n  | {\n      stage: 'error'\n      error: UnexpectedError | unknown\n    }\n  | {\n      stage: 'shutdown'\n      cause: IntentionalShutdownCause | StoreInterrupted\n    }\n\nexport type ShutdownDeferred = Deferred.Deferred<void, UnexpectedError | IntentionalShutdownCause | StoreInterrupted>\nexport const makeShutdownDeferred: Effect.Effect<ShutdownDeferred> = Deferred.make<\n  void,\n  UnexpectedError | IntentionalShutdownCause | StoreInterrupted\n>()\n\nexport type LiveStoreContextRunning = {\n  stage: 'running'\n  store: Store\n}\n\nexport type OtelOptions = {\n  tracer: otel.Tracer\n  rootSpanContext: otel.Context\n}\n\nexport type StoreOptions<TSchema extends LiveStoreSchema = LiveStoreSchema, TContext = {}> = {\n  clientSession: ClientSession\n  schema: TSchema\n  storeId: string\n  context: TContext\n  otelOptions: OtelOptions\n  effectContext: {\n    runtime: Runtime.Runtime<Scope.Scope>\n    lifetimeScope: Scope.Scope\n  }\n  confirmUnsavedChanges: boolean\n  batchUpdates: (runUpdates: () => void) => void\n  params: {\n    leaderPushBatchSize: number\n  }\n  __runningInDevtools: boolean\n}\n\nexport type RefreshReason =\n  | DebugRefreshReasonBase\n  | {\n      _tag: 'commit'\n      /** The events that were applied */\n      events: ReadonlyArray<LiveStoreEvent.AnyDecoded | LiveStoreEvent.PartialAnyDecoded>\n\n      /** The tables that were written to by the event */\n      writeTables: ReadonlyArray<string>\n    }\n  | {\n      // TODO rename to a more appropriate name which is framework-agnostic\n      _tag: 'react'\n      api: string\n      label?: string\n      stackInfo?: StackInfo\n    }\n  | { _tag: 'subscribe.initial'; label?: string }\n  | { _tag: 'subscribe.update'; label?: string }\n  | { _tag: 'manual'; label?: string }\n\nexport type QueryDebugInfo = {\n  _tag: string\n  label: string\n  query: string\n  durationMs: number\n}\n\nexport type StoreOtel = {\n  tracer: otel.Tracer\n  rootSpanContext: otel.Context\n  commitsSpanContext: otel.Context\n  queriesSpanContext: otel.Context\n}\n\nexport type StoreCommitOptions = {\n  label?: string\n  skipRefresh?: boolean\n  spanLinks?: otel.Link[]\n  otelContext?: otel.Context\n}\n\nexport type StoreEventsOptions<TSchema extends LiveStoreSchema> = {\n  /**\n   * By default only new events are returned.\n   * Use this to get all events from a specific point in time.\n   */\n  cursor?: EventSequenceNumber.EventSequenceNumber\n  /**\n   * Only include events of the given names\n   * @default undefined (include all)\n   */\n  filter?: ReadonlyArray<keyof TSchema['_EventDefMapType']>\n  /**\n   * Whether to include client-only events or only return synced events\n   * @default true\n   */\n  includeClientOnly?: boolean\n  /**\n   * Exclude own events that have not been pushed to the sync backend yet\n   * @default false\n   */\n  excludeUnpushed?: boolean\n}\n\nexport type Unsubscribe = () => void\n", "// Related https://github.com/facebook/hermes/issues/612#issuecomment-2549404649\nconst REACT_NATIVE_BAD_FUNCTION_STRING = 'function() { [bytecode] }'\n\nexport const isValidFunctionString = (\n  fnStr: string,\n): { _tag: 'valid' } | { _tag: 'invalid'; reason: 'react-native' } => {\n  if (fnStr === REACT_NATIVE_BAD_FUNCTION_STRING) {\n    return { _tag: 'invalid', reason: 'react-native' }\n  }\n\n  return { _tag: 'valid' }\n}\n", "import { getDurationMsFromSpan } from '@livestore/common'\nimport * as otel from '@opentelemetry/api'\n\nimport type { Thunk } from '../reactive.js'\nimport type { RefreshReason } from '../store/store-types.js'\nimport { isValidFunctionString } from '../utils/function-string.js'\nimport type { DepKey, GetAtomResult, LiveQueryDef, ReactivityGraph, ReactivityGraphContext } from './base-class.js'\nimport { depsToString, LiveStoreQueryBase, makeGetAtomResult, withRCMap } from './base-class.js'\n\nexport const computed = <TResult>(\n  fn: (get: GetAtomResult) => TResult,\n  options?: {\n    label?: string\n    deps?: DepKey\n  },\n): LiveQueryDef<TResult> => {\n  const hash = options?.deps ? depsToString(options.deps) : fn.toString()\n  if (isValidFunctionString(hash)._tag === 'invalid') {\n    throw new Error(`On Expo/React Native, computed queries must provide a \\`deps\\` option`)\n  }\n\n  const def: LiveQueryDef<any> = {\n    _tag: 'def',\n    make: withRCMap(hash, (ctx, _otelContext) => {\n      // TODO onDestroy\n      return new LiveStoreComputedQuery<TResult>({\n        fn,\n        label: options?.label ?? fn.toString(),\n        reactivityGraph: ctx.reactivityGraph.deref()!,\n        def,\n      })\n    }),\n    label: options?.label ?? fn.toString(),\n    // NOTE We're using the `makeQuery` function body string to make sure the key is unique across the app\n    // TODO we should figure out whether this could cause some problems and/or if there's a better way to do this\n    // NOTE `fn.toString()` doesn't work in Expo as it always produces `[native code]`\n    hash,\n  }\n\n  return def\n}\n\nexport class LiveStoreComputedQuery<TResult> extends LiveStoreQueryBase<TResult> {\n  _tag = 'computed' as const\n\n  /** A reactive thunk representing the query results */\n  results$: Thunk<TResult, ReactivityGraphContext, RefreshReason>\n\n  label: string\n\n  reactivityGraph: ReactivityGraph\n  def: LiveQueryDef<TResult>\n\n  constructor({\n    fn,\n    label,\n    reactivityGraph,\n    def,\n  }: {\n    label: string\n    fn: (get: GetAtomResult) => TResult\n    reactivityGraph: ReactivityGraph\n    def: LiveQueryDef<TResult>\n  }) {\n    super()\n\n    this.label = label\n    this.reactivityGraph = reactivityGraph\n    this.def = def\n\n    const queryLabel = `${label}:results`\n\n    this.results$ = this.reactivityGraph.makeThunk(\n      (get, setDebugInfo, ctx, otelContext) =>\n        ctx.otelTracer.startActiveSpan(`js:${label}`, {}, otelContext ?? ctx.rootOtelContext, (span) => {\n          const otelContext = otel.trace.setSpan(otel.context.active(), span)\n          const res = fn(makeGetAtomResult(get, ctx, otelContext, this.dependencyQueriesRef))\n\n          span.end()\n\n          const durationMs = getDurationMsFromSpan(span)\n\n          this.executionTimes.push(durationMs)\n\n          setDebugInfo({ _tag: 'computed', label, query: fn.toString(), durationMs })\n\n          return res\n        }),\n      { label: queryLabel, meta: { liveStoreThunkType: 'computed' } },\n    )\n  }\n\n  destroy = () => {\n    this.isDestroyed = true\n\n    this.reactivityGraph.destroyNode(this.results$)\n\n    for (const query of this.dependencyQueriesRef) {\n      query.deref()\n    }\n  }\n}\n", "import type { Bindable, QueryBuilder } from '@livestore/common'\nimport {\n  getDurationMsFromSpan,\n  getResultSchema,\n  isQueryBuilder,\n  prepareBindValues,\n  QueryBuilderAstSymbol,\n  replaceSessionIdSymbol,\n  SessionIdSymbol,\n  UnexpectedError,\n} from '@livestore/common'\nimport { deepEqual, shouldNeverHappen } from '@livestore/utils'\nimport { Predicate, Schema, TreeFormatter } from '@livestore/utils/effect'\nimport * as otel from '@opentelemetry/api'\n\nimport type { Thunk } from '../reactive.js'\nimport { isThunk, NOT_REFRESHED_YET } from '../reactive.js'\nimport type { RefreshReason } from '../store/store-types.js'\nimport { isValidFunctionString } from '../utils/function-string.js'\nimport type { DepKey, GetAtomResult, LiveQueryDef, ReactivityGraph, ReactivityGraphContext } from './base-class.js'\nimport { depsToString, LiveStoreQueryBase, makeGetAtomResult, withRCMap } from './base-class.js'\nimport { makeExecBeforeFirstRun, rowQueryLabel } from './client-document-get-query.js'\n\nexport type QueryInputRaw<TDecoded, TEncoded> = {\n  query: string\n  schema: Schema.Schema<TDecoded, TEncoded>\n  bindValues?: Bindable\n  /**\n   * Can be provided explicitly to slightly speed up initial query performance\n   *\n   * NOTE In the future we want to do this automatically at build time\n   */\n  queriedTables?: Set<string>\n  execBeforeFirstRun?: (ctx: ReactivityGraphContext) => void\n}\n\nexport const isQueryInputRaw = (value: unknown): value is QueryInputRaw<any, any> =>\n  Predicate.hasProperty(value, 'query') && Predicate.hasProperty(value, 'schema')\n\nexport type QueryInput<TDecoded, TEncoded> = QueryInputRaw<TDecoded, TEncoded> | QueryBuilder<TDecoded, any, any>\n\n/**\n * NOTE `queryDb` is only supposed to read data. Don't use it to insert/update/delete data but use events instead.\n *\n * When using contextual data when constructing the query, please make sure to include it in the `deps` option.\n *\n * @example\n * ```ts\n * const todos$ = queryDb(tables.todos.where({ complete: true }))\n * ```\n *\n * @example\n * ```ts\n * // Group-by raw SQL query\n * const colorCounts$ = queryDb({\n *   query: sql`SELECT color, COUNT(*) as count FROM todos WHERE complete = ? GROUP BY color`,\n *   schema: Schema.Array(Schema.Struct({\n *     color: Schema.String,\n *     count: Schema.Number,\n *   })),\n *   bindValues: [1],\n * })\n * ```\n *\n * @example\n * ```ts\n * // Using contextual data when constructing the query\n * const makeFilteredQuery = (filter: string) =>\n *   queryDb(tables.todos.where({ title: { op: 'like', value: filter } }), { deps: [filter] })\n *\n * const filteredTodos$ = makeFilteredQuery('buy coffee')\n * ```\n */\nexport const queryDb: {\n  <TResultSchema, TResult = TResultSchema>(\n    queryInput: QueryInputRaw<TResultSchema, ReadonlyArray<any>> | QueryBuilder<TResultSchema, any, any>,\n    options?: {\n      map?: (rows: TResultSchema) => TResult\n      /**\n       * Used for debugging / devtools\n       */\n      label?: string\n      deps?: DepKey\n    },\n  ): LiveQueryDef<TResult>\n  // NOTE in this \"thunk case\", we can't directly derive label/queryInfo from the queryInput,\n  // so the caller needs to provide them explicitly otherwise queryInfo will be set to `None`,\n  // and label will be set during the query execution\n  <TResultSchema, TResult = TResultSchema>(\n    queryInput:\n      | ((get: GetAtomResult) => QueryInputRaw<TResultSchema, ReadonlyArray<any>>)\n      | ((get: GetAtomResult) => QueryBuilder<TResultSchema, any, any>),\n    options?: {\n      map?: (rows: TResultSchema) => TResult\n      /**\n       * Used for debugging / devtools\n       */\n      label?: string\n      deps?: DepKey\n    },\n  ): LiveQueryDef<TResult>\n} = (queryInput, options) => {\n  const { queryString, extraDeps } = getQueryStringAndExtraDeps(queryInput)\n\n  const hash = [queryString, options?.deps ? depsToString(options.deps) : undefined, depsToString(extraDeps)]\n    .filter(Boolean)\n    .join('-')\n\n  if (isValidFunctionString(hash)._tag === 'invalid') {\n    throw new Error(`On Expo/React Native, db queries must provide a \\`deps\\` option`)\n  }\n\n  if (hash.trim() === '') {\n    return shouldNeverHappen(`Invalid query hash for query: ${queryInput}`)\n  }\n\n  const label = options?.label ?? queryString\n\n  const def: LiveQueryDef<any> = {\n    _tag: 'def',\n    make: withRCMap(hash, (ctx, otelContext) => {\n      // TODO onDestroy\n      return new LiveStoreDbQuery({\n        reactivityGraph: ctx.reactivityGraph.deref()!,\n        queryInput,\n        label,\n        map: options?.map,\n        otelContext,\n        def,\n      })\n    }),\n    label,\n    hash,\n  }\n\n  return def\n}\n\nconst bindValuesToDepKey = (bindValues: Bindable | undefined): DepKey => {\n  if (bindValues === undefined) {\n    return []\n  }\n\n  return Object.entries(bindValues)\n    .map(([key, value]: [string, any]) => `${key}:${value === SessionIdSymbol ? 'SessionIdSymbol' : value}`)\n    .join(',')\n}\n\nconst getQueryStringAndExtraDeps = (\n  queryInput: QueryInput<any, any> | ((get: GetAtomResult) => QueryInput<any, any>),\n): { queryString: string; extraDeps: DepKey } => {\n  if (isQueryBuilder(queryInput)) {\n    const { query, bindValues } = queryInput.asSql()\n    return { queryString: query, extraDeps: bindValuesToDepKey(bindValues) }\n  }\n\n  if (isQueryInputRaw(queryInput)) {\n    return { queryString: queryInput.query, extraDeps: bindValuesToDepKey(queryInput.bindValues) }\n  }\n\n  if (typeof queryInput === 'function') {\n    return { queryString: queryInput.toString(), extraDeps: [] }\n  }\n\n  return shouldNeverHappen(`Invalid query input: ${queryInput}`)\n}\n\n/* An object encapsulating a reactive SQL query */\nexport class LiveStoreDbQuery<TResultSchema, TResult = TResultSchema> extends LiveStoreQueryBase<TResult> {\n  _tag = 'db' as const\n\n  /** A reactive thunk representing the query text */\n  queryInput$: Thunk<QueryInputRaw<any, any>, ReactivityGraphContext, RefreshReason> | undefined\n\n  /** A reactive thunk representing the query results */\n  results$: Thunk<TResult, ReactivityGraphContext, RefreshReason>\n\n  label: string\n\n  readonly reactivityGraph\n\n  private mapResult: (rows: TResultSchema) => TResult\n  def: LiveQueryDef<TResult>\n\n  constructor({\n    queryInput,\n    label: inputLabel,\n    reactivityGraph,\n    map,\n    otelContext,\n    def,\n  }: {\n    label?: string\n    queryInput:\n      | QueryInput<TResultSchema, ReadonlyArray<any>>\n      | ((get: GetAtomResult, ctx: ReactivityGraphContext) => QueryInput<TResultSchema, ReadonlyArray<any>>)\n    reactivityGraph: ReactivityGraph\n    map?: (rows: TResultSchema) => TResult\n    /** Only used for the initial query execution */\n    otelContext?: otel.Context\n    def: LiveQueryDef<TResult>\n  }) {\n    super()\n\n    let label = inputLabel ?? 'db(unknown)'\n    this.reactivityGraph = reactivityGraph\n    this.def = def\n\n    this.mapResult = map === undefined ? (rows: any) => rows as TResult : map\n\n    const schemaRef: { current: Schema.Schema<any, any> | undefined } = {\n      current:\n        typeof queryInput === 'function' ? undefined : isQueryBuilder(queryInput) ? undefined : queryInput.schema,\n    }\n\n    const execBeforeFirstRunRef: {\n      current: ((ctx: ReactivityGraphContext, otelContext: otel.Context) => void) | undefined\n    } = {\n      current: undefined,\n    }\n\n    type TQueryInputRaw = QueryInputRaw<any, any>\n\n    let queryInputRaw$OrQueryInputRaw: TQueryInputRaw | Thunk<TQueryInputRaw, ReactivityGraphContext, RefreshReason>\n\n    const fromQueryBuilder = (qb: QueryBuilder.Any, otelContext: otel.Context | undefined) => {\n      try {\n        const qbRes = qb.asSql()\n        const schema = getResultSchema(qb) as Schema.Schema<TResultSchema, ReadonlyArray<any>>\n        const ast = qb[QueryBuilderAstSymbol]\n\n        return {\n          queryInputRaw: {\n            query: qbRes.query,\n            schema,\n            bindValues: qbRes.bindValues,\n            queriedTables: new Set([ast.tableDef.sqliteDef.name]),\n          } satisfies TQueryInputRaw,\n          label: ast._tag === 'RowQuery' ? rowQueryLabel(ast.tableDef, ast.id) : qb.toString(),\n          execBeforeFirstRun:\n            ast._tag === 'RowQuery'\n              ? makeExecBeforeFirstRun({\n                  table: ast.tableDef,\n                  explicitDefaultValues: ast.explicitDefaultValues,\n                  id: ast.id,\n                  otelContext,\n                })\n              : undefined,\n        }\n      } catch (cause) {\n        throw new UnexpectedError({ cause, note: `Error building query for ${qb.toString()}`, payload: { qb } })\n      }\n    }\n\n    if (typeof queryInput === 'function') {\n      queryInputRaw$OrQueryInputRaw = this.reactivityGraph.makeThunk(\n        (get, setDebugInfo, ctx, otelContext) => {\n          const startMs = performance.now()\n          const queryInputResult = queryInput(\n            makeGetAtomResult(get, ctx, otelContext ?? ctx.rootOtelContext, this.dependencyQueriesRef),\n            ctx,\n          )\n          const durationMs = performance.now() - startMs\n\n          let queryInputRaw: TQueryInputRaw\n\n          if (isQueryBuilder(queryInputResult)) {\n            const res = fromQueryBuilder(queryInputResult, otelContext)\n            queryInputRaw = res.queryInputRaw\n            // setting label dynamically here\n            this.label = res.label\n            execBeforeFirstRunRef.current = res.execBeforeFirstRun\n          } else {\n            queryInputRaw = queryInputResult\n          }\n\n          setDebugInfo({ _tag: 'computed', label: `${this.label}:queryInput`, query: queryInputRaw.query, durationMs })\n\n          schemaRef.current = queryInputRaw.schema\n\n          return queryInputRaw\n        },\n        {\n          label: `${label}:query`,\n          meta: { liveStoreThunkType: 'db.query' },\n          // NOTE we're not checking the schema here as we assume the query string to always change when the schema might change\n          equal: (a, b) => a.query === b.query && deepEqual(a.bindValues, b.bindValues),\n        },\n      )\n\n      this.queryInput$ = queryInputRaw$OrQueryInputRaw\n    } else {\n      let queryInputRaw: TQueryInputRaw\n      if (isQueryBuilder(queryInput)) {\n        const res = fromQueryBuilder(queryInput, otelContext)\n        queryInputRaw = res.queryInputRaw\n        label = res.label\n        execBeforeFirstRunRef.current = res.execBeforeFirstRun\n      } else {\n        queryInputRaw = queryInput\n      }\n\n      schemaRef.current = queryInputRaw.schema\n      queryInputRaw$OrQueryInputRaw = queryInputRaw\n\n      // this.label = inputLabel ? this.label : `db(${})`\n      if (inputLabel === undefined && isQueryBuilder(queryInput)) {\n        const ast = queryInput[QueryBuilderAstSymbol]\n        if (ast._tag === 'RowQuery') {\n          label = `db(${rowQueryLabel(ast.tableDef, ast.id)})`\n        }\n      }\n    }\n\n    const queriedTablesRef: { current: Set<string> | undefined } = { current: undefined }\n\n    const makeResultsEqual = (resultSchema: Schema.Schema<any, any>) => (a: TResult, b: TResult) =>\n      a === NOT_REFRESHED_YET || b === NOT_REFRESHED_YET ? false : Schema.equivalence(resultSchema)(a, b)\n\n    // NOTE we try to create the equality function eagerly as it might be expensive\n    // TODO also support derived equality for `map` (probably will depend on having an easy way to transform a schema without an `encode` step)\n    // This would mean dropping the `map` option\n    const resultsEqual =\n      map === undefined\n        ? schemaRef.current === undefined\n          ? (a: TResult, b: TResult) => makeResultsEqual(schemaRef.current!)(a, b)\n          : makeResultsEqual(schemaRef.current)\n        : undefined\n\n    const results$ = this.reactivityGraph.makeThunk<TResult>(\n      (get, setDebugInfo, queryContext, otelContext, debugRefreshReason) =>\n        queryContext.otelTracer.startActiveSpan(\n          'db:...', // NOTE span name will be overridden further down\n          {\n            attributes: {\n              'livestore.debugRefreshReason': Predicate.hasProperty(debugRefreshReason, 'label')\n                ? (debugRefreshReason.label as string)\n                : debugRefreshReason?._tag,\n            },\n          },\n          otelContext ?? queryContext.rootOtelContext,\n          (span) => {\n            const otelContext = otel.trace.setSpan(otel.context.active(), span)\n            const { store } = queryContext\n\n            if (execBeforeFirstRunRef.current !== undefined) {\n              execBeforeFirstRunRef.current(queryContext, otelContext)\n              execBeforeFirstRunRef.current = undefined\n            }\n\n            const queryInputResult = isThunk(queryInputRaw$OrQueryInputRaw)\n              ? (get(queryInputRaw$OrQueryInputRaw, otelContext, debugRefreshReason) as TQueryInputRaw)\n              : (queryInputRaw$OrQueryInputRaw as TQueryInputRaw)\n\n            const sqlString = queryInputResult.query\n            const bindValues = queryInputResult.bindValues\n\n            if (queriedTablesRef.current === undefined) {\n              queriedTablesRef.current = store.sqliteDbWrapper.getTablesUsed(sqlString)\n            }\n\n            if (bindValues !== undefined) {\n              replaceSessionIdSymbol(bindValues, store.clientSession.sessionId)\n            }\n\n            // Establish a reactive dependency on the tables used in the query\n            for (const tableName of queriedTablesRef.current) {\n              const tableRef = store.tableRefs[tableName] ?? shouldNeverHappen(`No table ref found for ${tableName}`)\n              get(tableRef, otelContext, debugRefreshReason)\n            }\n\n            span.setAttribute('sql.query', sqlString)\n            span.updateName(`db:${sqlString.slice(0, 50)}`)\n\n            const rawDbResults = store.sqliteDbWrapper.cachedSelect<any>(\n              sqlString,\n              bindValues ? prepareBindValues(bindValues, sqlString) : undefined,\n              {\n                queriedTables: queriedTablesRef.current,\n                otelContext,\n              },\n            )\n\n            span.setAttribute('sql.rowsCount', rawDbResults.length)\n\n            const parsedResult = Schema.decodeEither(schemaRef.current!)(rawDbResults)\n\n            if (parsedResult._tag === 'Left') {\n              const parseErrorStr = TreeFormatter.formatErrorSync(parsedResult.left)\n              const expectedSchemaStr = String(schemaRef.current!.ast)\n              const bindValuesStr = bindValues === undefined ? '' : `\\nBind values: ${JSON.stringify(bindValues)}`\n\n              return shouldNeverHappen(\n                `\\\nError parsing SQL query result (${label}).\n\nQuery: ${sqlString}\\\n${bindValuesStr}\n\nExpected schema: ${expectedSchemaStr}\n\nError: ${parseErrorStr}\n\nResult:`,\n                rawDbResults,\n                '\\n',\n              )\n            }\n\n            const result = this.mapResult(parsedResult.right)\n\n            span.end()\n\n            const durationMs = getDurationMsFromSpan(span)\n\n            this.executionTimes.push(durationMs)\n\n            setDebugInfo({ _tag: 'db', label: `${label}:results`, query: sqlString, durationMs })\n\n            return result\n          },\n        ),\n      { label: `${label}:results`, meta: { liveStoreThunkType: 'db.result' }, equal: resultsEqual },\n    )\n\n    this.results$ = results$\n\n    this.label = label\n  }\n\n  destroy = () => {\n    this.isDestroyed = true\n\n    if (this.queryInput$ !== undefined) {\n      this.reactivityGraph.destroyNode(this.queryInput$)\n    }\n\n    this.reactivityGraph.destroyNode(this.results$)\n\n    for (const query of this.dependencyQueriesRef) {\n      query.deref()\n    }\n  }\n}\n", "import { nanoid } from '@livestore/utils/nanoid'\n\nimport type * as RG from '../reactive.js'\nimport type { RefreshReason } from '../store/store-types.js'\nimport type { ISignal, ReactivityGraph, ReactivityGraphContext, SignalDef } from './base-class.js'\nimport { LiveStoreQueryBase, withRCMap } from './base-class.js'\n\nexport const signal = <T>(\n  defaultValue: T,\n  options?: {\n    label?: string\n  },\n): SignalDef<T> => {\n  const id = nanoid()\n  const def: SignalDef<T> = {\n    _tag: 'signal-def',\n    defaultValue,\n    hash: id,\n    label: options?.label ?? 'Signal',\n    make: withRCMap(\n      id,\n      (ctx) =>\n        new Signal({\n          defaultValue,\n          reactivityGraph: ctx.reactivityGraph.deref()!,\n          label: options?.label ?? 'Signal',\n          def,\n        }),\n    ),\n  }\n\n  return def\n}\n\nexport class Signal<T> extends LiveStoreQueryBase<T> implements ISignal<T> {\n  _tag = 'signal' as const\n  readonly ref: RG.Ref<T, ReactivityGraphContext, RefreshReason>\n  label: string\n  reactivityGraph: ReactivityGraph\n  results$: RG.Ref<T, ReactivityGraphContext, RefreshReason>\n  def: SignalDef<T>\n  constructor(\n    // private defaultValue: T,\n    // readonly reactivityGraph: ReactivityGraph,\n    // private options?: {\n    //   label?: string\n    // },\n    {\n      defaultValue,\n      reactivityGraph,\n      label,\n      def,\n    }: {\n      defaultValue: T\n      reactivityGraph: ReactivityGraph\n      label: string\n      def: SignalDef<T>\n    },\n  ) {\n    super()\n\n    this.ref = reactivityGraph.makeRef(defaultValue, { label })\n    this.label = label\n    this.reactivityGraph = reactivityGraph\n    this.def = def\n\n    this.results$ = this.ref\n  }\n\n  set = (value: T) => {\n    this.reactivityGraph.setRef(this.ref, value)\n  }\n\n  get = () => {\n    return this.ref.computeResult()\n  }\n\n  destroy = () => {\n    this.reactivityGraph.destroyNode(this.ref)\n  }\n}\n", "export type StackInfo = {\n  frames: StackFrame[]\n}\n\nexport type StackFrame = {\n  name: string\n  filePath: string\n}\n\n/*\nExample stack trace:\n\nError\n    at https://localhost:8081/@fs/Users/schickling/Code/overtone/submodules/livestore/packages/@livestore/livestore/dist/react/useQuery.js?t=1699550216884:18:23\n    at mountMemo (https://localhost:8081/node_modules/.vite-web/deps/chunk-M23HUTQV.js?v=3eb66ed6:12817:27)\n    at Object.useMemo (https://localhost:8081/node_modules/.vite-web/deps/chunk-M23HUTQV.js?v=3eb66ed6:13141:24)\n    at Object.useMemo (https://localhost:8081/node_modules/.vite-web/deps/chunk-4WADDZ2G.js?v=3eb66ed6:1094:29)\n    at useQuery (https://localhost:8081/@fs/Users/schickling/Code/overtone/submodules/livestore/packages/@livestore/livestore/dist/react/useQuery.js?t=1699550216884:13:33)\n    at useAppState (https://localhost:8081/src/db/AppState.ts?t=1699550216884:17:34)\n    at useRoute (https://localhost:8081/src/db/AppState.ts?t=1699550216884:74:22)\n    at RouteLink (https://localhost:8081/src/components/Link.tsx?t=1699550216884:36:7)\n    at renderWithHooks (https://localhost:8081/node_modules/.vite-web/deps/chunk-M23HUTQV.js?v=3eb66ed6:12171:26)\n    at mountIndeterminateComponent (https://localhost:8081/node_modules/.vite-web/deps/chunk-M23HUTQV.js?v=3eb66ed6:14921:21)\n  \nApproach:\n  - Start filtering at `at useQuery` (including)\n  - Stop filtering at `at renderWithHooks` (excluding)\n */\nexport const extractStackInfoFromStackTrace = (stackTrace: string): StackInfo => {\n  const namePattern = /at (\\S+) \\((.+)\\)/g\n  let match: RegExpExecArray | null\n  const frames: StackFrame[] = []\n  let hasReachedStart = false\n\n  while ((match = namePattern.exec(stackTrace)) !== null) {\n    const [, name, filePath] = match as any as [string, string, string]\n    // console.debug(name, filePath)\n\n    // NOTE No idea where this `Module.` comes from - possibly a Vite thing?\n    if ((name.startsWith('use') || name.startsWith('Module.use')) && name.endsWith('QueryRef') === false) {\n      hasReachedStart = true\n      // console.debug('hasReachedStart. adding one more frame.')\n\n      frames.unshift({ name: name.replace(/^Module\\./, ''), filePath })\n    } else if (hasReachedStart) {\n      // We've reached the end of the `use*` functions, so we're adding the component name and stop\n      // Unless it's `react-stack-bottom-frame`, which we skip\n      if (name !== 'Object.react-stack-bottom-frame') {\n        frames.unshift({ name, filePath })\n      }\n      break\n    }\n  }\n\n  return { frames }\n}\n\nexport const stackInfoToString = (stackInfo: StackInfo): string =>\n  stackInfo.frames.map((f) => `${f.name} (${f.filePath})`).join('\\n')\n"],
  "mappings": "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",
  "names": ["_a", "otelContext", "debugRefreshReason", "Symbols", "sql", "context", "_a", "mod_exports", "_a", "mod_exports", "signal", "context", "store", "otelContext", "otelContext"]
}

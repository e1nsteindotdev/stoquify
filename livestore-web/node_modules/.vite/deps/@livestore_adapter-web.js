import {
  CreateConnection,
  LeaderThreadCtx,
  LeaderWorkerInner,
  LeaderWorkerOuter,
  SharedWorker,
  StorageType,
  configureConnection,
  eventlog_exports,
  loadSqlite3Wasm,
  makeLeaderThreadLayer,
  makeShutdownChannel,
  opfs_utils_exports,
  readPersistedAppDbFromClientSession,
  resetPersistedDataFromClientSession,
  schema_exports,
  sqliteDbFactory,
  worker_schema_exports
} from "./chunk-OFAEZEPS.js";
import {
  BrowserWorker_exports,
  Cause_exports,
  Deferred_exports,
  Effect_exports,
  EventSequenceNumber_exports,
  Exit_exports,
  FetchHttpClient_exports,
  Fiber_exports,
  IntentionalShutdownCause,
  LS_DEV,
  Layer_exports,
  LiveStoreEvent_exports,
  ParseResult_exports,
  Queue_exports,
  Schema_exports,
  StoreInterrupted,
  Stream_exports,
  SubscriptionRef_exports,
  UnexpectedError,
  WebLock_exports,
  WorkerError_exports,
  Worker_exports,
  isDevEnv,
  liveStoreVersion,
  makeClientSession,
  makeMeshNode,
  mesh_schema_exports,
  mod_exports,
  mod_exports4 as mod_exports2,
  nanoid,
  shouldNeverHappen,
  system_tables_exports,
  tryAsFunctionAndNew
} from "./chunk-J7UPD3II.js";
import "./chunk-DWA4UIM3.js";

// node_modules/.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/dist/web-worker/common/worker-disconnect-channel.js
var DedicatedWorkerDisconnectBroadcast = class extends Schema_exports.TaggedStruct("DedicatedWorkerDisconnectBroadcast", {}) {
};
var makeWorkerDisconnectChannel = (storeId) => mod_exports.broadcastChannel({
  channelName: `livestore.worker-disconnect.${storeId}`,
  schema: DedicatedWorkerDisconnectBroadcast
});

// node_modules/.pnpm/@livestore+devtools-web-common@0.3.1_a2602a20d83ff4e94e4a35c6aa299805/node_modules/@livestore/devtools-web-common/dist/web-channel/index.js
var makeSessionInfoBroadcastChannel = mod_exports.broadcastChannel({
  channelName: "session-info",
  schema: mod_exports2.SessionInfo.Message
});
var makeNodeName = {
  sharedWorker: ({ storeId }) => `shared-worker-${storeId}`,
  // TODO refactor shared-worker setup so there's only a single shared-worker per origin
  // sharedWorker: () => `shared-worker`,
  browserExtension: {
    contentscriptMain: (tabId) => `contentscript-main-${tabId}`,
    contentscriptIframe: (tabId) => `contentscript-iframe-${tabId}`
  }
};
var ClientSessionContentscriptMainReq = Schema_exports.TaggedStruct("ClientSessionContentscriptMainReq", {
  storeId: Schema_exports.String,
  clientId: Schema_exports.String,
  sessionId: Schema_exports.String
});
var ClientSessionContentscriptMainRes = Schema_exports.TaggedStruct("ClientSessionContentscriptMainRes", {
  tabId: Schema_exports.Number
});
var makeStaticClientSessionChannel = {
  contentscriptMain: Effect_exports.suspend(() => mod_exports.windowChannel({
    // eslint-disable-next-line unicorn/prefer-global-this
    listenWindow: window,
    // eslint-disable-next-line unicorn/prefer-global-this
    sendWindow: window,
    schema: { listen: ClientSessionContentscriptMainReq, send: ClientSessionContentscriptMainRes },
    ids: { own: "contentscript-main-static", other: "client-session-static" }
  })),
  clientSession: Effect_exports.suspend(() => mod_exports.windowChannel({
    // eslint-disable-next-line unicorn/prefer-global-this
    listenWindow: window,
    // eslint-disable-next-line unicorn/prefer-global-this
    sendWindow: window,
    schema: { listen: ClientSessionContentscriptMainRes, send: ClientSessionContentscriptMainReq },
    ids: { own: "client-session-static", other: "contentscript-main-static" }
  }))
};
var connectViaWorker = ({ node, target, worker }) => Effect_exports.gen(function* () {
  const mc = new MessageChannel();
  const isConnected = yield* Deferred_exports.make();
  if (LS_DEV) {
    yield* Effect_exports.addFinalizerLog(`@livestore/devtools-web-common: closing message channel ${node.nodeName} → ${target}`);
  }
  yield* worker.execute(CreateConnection.make({ from: node.nodeName, port: mc.port1 })).pipe(Stream_exports.tap(() => Deferred_exports.succeed(isConnected, true)), Stream_exports.runDrain, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  yield* isConnected;
  const sharedWorkerConnection = yield* mod_exports.messagePortChannel({
    port: mc.port2,
    schema: mesh_schema_exports.Packet
  });
  yield* node.addEdge({ target, edgeChannel: sharedWorkerConnection, replaceIfExists: true });
  if (LS_DEV) {
    yield* Effect_exports.logDebug(`@livestore/devtools-web-common: initiated connection: ${node.nodeName} → ${target}`);
  }
}).pipe(UnexpectedError.mapToUnexpectedError);

// node_modules/.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/dist/web-worker/client-session/client-session-devtools.js
var logDevtoolsUrl = ({ schema, storeId, clientId, sessionId }) => Effect_exports.gen(function* () {
  if (isDevEnv()) {
    const devtoolsPath = globalThis.LIVESTORE_DEVTOOLS_PATH ?? `/_livestore`;
    const devtoolsBaseUrl = `${location.origin}${devtoolsPath}`;
    const response = yield* Effect_exports.promise(() => fetch(devtoolsBaseUrl));
    if (response.ok) {
      const text = yield* Effect_exports.promise(() => response.text());
      if (text.includes('<meta name="livestore-devtools" content="true" />')) {
        const url = `${devtoolsBaseUrl}/web/${storeId}/${clientId}/${sessionId}/${schema.devtools.alias}`;
        yield* Effect_exports.log(`[@livestore/adapter-web] Devtools ready on ${url}`);
      }
    }
  }
}).pipe(Effect_exports.withSpan("@livestore/adapter-web:client-session:devtools:logDevtoolsUrl"));
var connectWebmeshNodeClientSession = Effect_exports.fn(function* ({ webmeshNode, sessionInfo, sharedWorker, devtoolsEnabled, schema }) {
  if (devtoolsEnabled) {
    const { clientId, sessionId, storeId } = sessionInfo;
    yield* logDevtoolsUrl({ clientId, sessionId, schema, storeId });
    yield* mod_exports2.SessionInfo.provideSessionInfo({
      webChannel: yield* makeSessionInfoBroadcastChannel,
      sessionInfo
    }).pipe(Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
    yield* Effect_exports.gen(function* () {
      const clientSessionStaticChannel = yield* makeStaticClientSessionChannel.clientSession;
      yield* clientSessionStaticChannel.send(ClientSessionContentscriptMainReq.make({ clientId, sessionId, storeId }));
      const { tabId } = yield* clientSessionStaticChannel.listen.pipe(Stream_exports.flatten(), Stream_exports.runHead, Effect_exports.flatten);
      const contentscriptMainNodeName = makeNodeName.browserExtension.contentscriptMain(tabId);
      const contentscriptMainChannel = yield* mod_exports.windowChannel({
        listenWindow: window,
        sendWindow: window,
        schema: mesh_schema_exports.Packet,
        ids: { own: webmeshNode.nodeName, other: contentscriptMainNodeName }
      });
      yield* webmeshNode.addEdge({ target: contentscriptMainNodeName, edgeChannel: contentscriptMainChannel });
    }).pipe(Effect_exports.withSpan("@livestore/adapter-web:client-session:devtools:browser-extension"), Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
    yield* connectViaWorker({
      node: webmeshNode,
      target: makeNodeName.sharedWorker({ storeId }),
      worker: sharedWorker
    });
  }
});

// node_modules/.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/dist/web-worker/client-session/persisted-adapter.js
var sqlite3Promise = loadSqlite3Wasm();
if (isDevEnv()) {
  globalThis.__debugLiveStoreUtils = {
    opfs: opfs_utils_exports,
    runSync: (effect) => Effect_exports.runSync(effect),
    runFork: (effect) => Effect_exports.runFork(effect)
  };
}
var makePersistedAdapter = (options) => (adapterArgs) => Effect_exports.gen(function* () {
  var _a, _b;
  const { schema, storeId, devtoolsEnabled, debugInstanceId, bootStatusQueue, shutdown, syncPayload } = adapterArgs;
  yield* ensureBrowserRequirements;
  yield* Queue_exports.offer(bootStatusQueue, { stage: "loading" });
  const sqlite3 = yield* Effect_exports.promise(() => sqlite3Promise);
  const LIVESTORE_TAB_LOCK = `livestore-tab-lock-${storeId}`;
  const storageOptions = yield* Schema_exports.decode(StorageType)(options.storage);
  const shutdownChannel = yield* makeShutdownChannel(storeId);
  if (options.resetPersistence === true) {
    yield* shutdownChannel.send(IntentionalShutdownCause.make({ reason: "adapter-reset" }));
    yield* resetPersistedDataFromClientSession({ storageOptions, storeId });
  }
  const dataFromFile = ((_a = options.experimental) == null ? void 0 : _a.disableFastPath) === true ? void 0 : yield* readPersistedAppDbFromClientSession({ storageOptions, storeId, schema });
  const clientId = options.clientId ?? getPersistedId(`clientId:${storeId}`, "local");
  const sessionId = options.sessionId ?? getPersistedId(`sessionId:${storeId}`, "session");
  const workerDisconnectChannel = yield* makeWorkerDisconnectChannel(storeId);
  yield* shutdownChannel.listen.pipe(Stream_exports.flatten(), Stream_exports.tap((error) => shutdown(Cause_exports.fail(error))), Stream_exports.runDrain, Effect_exports.interruptible, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  const sharedWebWorker = tryAsFunctionAndNew(options.sharedWorker, { name: `livestore-shared-worker-${storeId}` });
  const sharedWorkerFiber = yield* Worker_exports.makePoolSerialized({
    size: 1,
    concurrency: 100,
    initialMessage: () => new SharedWorker.InitialMessage({
      liveStoreVersion,
      payload: {
        _tag: "FromClientSession",
        initialMessage: new LeaderWorkerInner.InitialMessage({
          storageOptions,
          storeId,
          clientId,
          devtoolsEnabled,
          debugInstanceId,
          syncPayload
        })
      }
    })
  }).pipe(Effect_exports.provide(BrowserWorker_exports.layer(() => sharedWebWorker)), Effect_exports.tapCauseLogPretty, UnexpectedError.mapToUnexpectedError, Effect_exports.tapErrorCause(shutdown), Effect_exports.withSpan("@livestore/adapter-web:client-session:setupSharedWorker"), Effect_exports.forkScoped);
  const lockDeferred = yield* Deferred_exports.make();
  let gotLocky = yield* WebLock_exports.tryGetDeferredLock(lockDeferred, LIVESTORE_TAB_LOCK);
  const lockStatus = yield* SubscriptionRef_exports.make(gotLocky ? "has-lock" : "no-lock");
  const waitForSharedWorkerInitialized = yield* Deferred_exports.make();
  if (gotLocky === false) {
    yield* Deferred_exports.succeed(waitForSharedWorkerInitialized, void 0);
  }
  const runLocked = Effect_exports.gen(function* () {
    yield* Effect_exports.logDebug(`[@livestore/adapter-web:client-session] ✅ Got lock '${LIVESTORE_TAB_LOCK}' (clientId: ${clientId}, sessionId: ${sessionId}).`);
    yield* Effect_exports.addFinalizer(() => Effect_exports.logDebug(`[@livestore/adapter-web:client-session] Releasing lock for '${LIVESTORE_TAB_LOCK}'`));
    yield* SubscriptionRef_exports.set(lockStatus, "has-lock");
    const mc = new MessageChannel();
    const worker = tryAsFunctionAndNew(options.worker, { name: `livestore-worker-${storeId}-${sessionId}` });
    yield* Worker_exports.makeSerialized({
      initialMessage: () => new LeaderWorkerOuter.InitialMessage({ port: mc.port1, storeId, clientId })
    }).pipe(Effect_exports.provide(BrowserWorker_exports.layer(() => worker)), UnexpectedError.mapToUnexpectedError, Effect_exports.tapErrorCause(shutdown), Effect_exports.withSpan("@livestore/adapter-web:client-session:setupDedicatedWorker"), Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
    yield* workerDisconnectChannel.send(DedicatedWorkerDisconnectBroadcast.make({}));
    const sharedWorker2 = yield* Fiber_exports.join(sharedWorkerFiber);
    yield* sharedWorker2.executeEffect(new SharedWorker.UpdateMessagePort({ port: mc.port2 })).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.tapErrorCause(shutdown));
    yield* Deferred_exports.succeed(waitForSharedWorkerInitialized, void 0);
    yield* Effect_exports.never;
  }).pipe(Effect_exports.withSpan("@livestore/adapter-web:client-session:lock"));
  if (gotLocky === false) {
    yield* Effect_exports.logDebug(`[@livestore/adapter-web:client-session] ⏳ Waiting for lock '${LIVESTORE_TAB_LOCK}' (sessionId: ${sessionId})`);
    yield* WebLock_exports.waitForDeferredLock(lockDeferred, LIVESTORE_TAB_LOCK).pipe(Effect_exports.andThen(() => {
      gotLocky = true;
      return runLocked;
    }), Effect_exports.interruptible, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  } else {
    yield* runLocked.pipe(Effect_exports.interruptible, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  }
  const runInWorker = (req) => Fiber_exports.join(sharedWorkerFiber).pipe(
    // NOTE we need to wait for the shared worker to be initialized before we can send requests to it
    Effect_exports.tap(() => waitForSharedWorkerInitialized),
    Effect_exports.flatMap((worker) => worker.executeEffect(req)),
    // NOTE we want to treat worker requests as atomic and therefore not allow them to be interrupted
    // Interruption usually only happens during leader re-election or store shutdown
    // Effect.uninterruptible,
    Effect_exports.logWarnIfTakesLongerThan({
      label: `@livestore/adapter-web:client-session:runInWorker:${req._tag}`,
      duration: 2e3
    }),
    Effect_exports.withSpan(`@livestore/adapter-web:client-session:runInWorker:${req._tag}`),
    Effect_exports.mapError((cause) => Schema_exports.is(UnexpectedError)(cause) ? cause : ParseResult_exports.isParseError(cause) || Schema_exports.is(WorkerError_exports.WorkerError)(cause) ? new UnexpectedError({ cause }) : cause),
    Effect_exports.catchAllDefect((cause) => new UnexpectedError({ cause }))
  );
  const runInWorkerStream = (req) => Effect_exports.gen(function* () {
    const sharedWorker2 = yield* Fiber_exports.join(sharedWorkerFiber);
    return sharedWorker2.execute(req).pipe(Stream_exports.mapError((cause) => Schema_exports.is(UnexpectedError)(cause) ? cause : ParseResult_exports.isParseError(cause) || Schema_exports.is(WorkerError_exports.WorkerError)(cause) ? new UnexpectedError({ cause }) : cause), Stream_exports.withSpan(`@livestore/adapter-web:client-session:runInWorkerStream:${req._tag}`));
  }).pipe(Stream_exports.unwrap);
  const bootStatusFiber = yield* runInWorkerStream(new LeaderWorkerInner.BootStatusStream()).pipe(Stream_exports.tap((_) => Queue_exports.offer(bootStatusQueue, _)), Stream_exports.runDrain, Effect_exports.tapErrorCause((cause) => Cause_exports.isInterruptedOnly(cause) ? Effect_exports.void : shutdown(cause)), Effect_exports.interruptible, Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  yield* Queue_exports.awaitShutdown(bootStatusQueue).pipe(Effect_exports.andThen(Fiber_exports.interrupt(bootStatusFiber)), Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
  const initialResult = dataFromFile === void 0 ? yield* runInWorker(new LeaderWorkerInner.GetRecreateSnapshot()).pipe(Effect_exports.map(({ snapshot, migrationsReport: migrationsReport2 }) => ({
    _tag: "from-leader-worker",
    snapshot,
    migrationsReport: migrationsReport2
  }))) : { _tag: "fast-path", snapshot: dataFromFile };
  const migrationsReport = initialResult._tag === "from-leader-worker" ? initialResult.migrationsReport : { migrations: [] };
  const makeSqliteDb = sqliteDbFactory({ sqlite3 });
  const sqliteDb = yield* makeSqliteDb({ _tag: "in-memory" });
  sqliteDb.import(initialResult.snapshot);
  const numberOfTables = ((_b = sqliteDb.select(`select count(*) as count from sqlite_master`)[0]) == null ? void 0 : _b.count) ?? 0;
  if (numberOfTables === 0) {
    yield* UnexpectedError.make({
      cause: `Encountered empty or corrupted database`,
      payload: { snapshotByteLength: initialResult.snapshot.byteLength, storageOptions: options.storage }
    });
  }
  const initialLeaderHeadRes = sqliteDb.select(`select seqNumGlobal, seqNumClient from ${system_tables_exports.SESSION_CHANGESET_META_TABLE} order by seqNumGlobal desc, seqNumClient desc limit 1`)[0];
  const initialLeaderHead = initialLeaderHeadRes ? EventSequenceNumber_exports.make({
    global: initialLeaderHeadRes.seqNumGlobal,
    client: initialLeaderHeadRes.seqNumClient
  }) : EventSequenceNumber_exports.ROOT;
  yield* Effect_exports.addFinalizer((ex) => Effect_exports.gen(function* () {
    if (Exit_exports.isFailure(ex) && Exit_exports.isInterrupted(ex) === false && Schema_exports.is(IntentionalShutdownCause)(Cause_exports.squash(ex.cause)) === false && Schema_exports.is(StoreInterrupted)(Cause_exports.squash(ex.cause)) === false) {
      yield* Effect_exports.logError("[@livestore/adapter-web:client-session] client-session shutdown", ex.cause);
    } else {
      yield* Effect_exports.logDebug("[@livestore/adapter-web:client-session] client-session shutdown", gotLocky, ex);
    }
    if (gotLocky) {
      yield* Deferred_exports.succeed(lockDeferred, void 0);
    }
  }).pipe(Effect_exports.tapCauseLogPretty, Effect_exports.orDie));
  const leaderThread = {
    export: runInWorker(new LeaderWorkerInner.Export()).pipe(Effect_exports.timeout(1e4), UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:client-session:export")),
    events: {
      pull: ({ cursor }) => runInWorkerStream(new LeaderWorkerInner.PullStream({ cursor })).pipe(Stream_exports.orDie),
      push: (batch) => runInWorker(new LeaderWorkerInner.PushToLeader({ batch })).pipe(Effect_exports.withSpan("@livestore/adapter-web:client-session:pushToLeader", {
        attributes: { batchSize: batch.length }
      }))
    },
    initialState: { leaderHead: initialLeaderHead, migrationsReport },
    getEventlogData: runInWorker(new LeaderWorkerInner.ExportEventlog()).pipe(Effect_exports.timeout(1e4), UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:client-session:getEventlogData")),
    getSyncState: runInWorker(new LeaderWorkerInner.GetLeaderSyncState()).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:client-session:getLeaderSyncState")),
    sendDevtoolsMessage: (message) => runInWorker(new LeaderWorkerInner.ExtraDevtoolsMessage({ message })).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.withSpan("@livestore/adapter-web:client-session:devtoolsMessageForLeader"))
  };
  const sharedWorker = yield* Fiber_exports.join(sharedWorkerFiber);
  const clientSession = yield* makeClientSession({
    ...adapterArgs,
    sqliteDb,
    lockStatus,
    clientId,
    sessionId,
    // isLeader: gotLocky, // TODO update when leader is changing
    isLeader: true,
    leaderThread,
    webmeshMode: "direct",
    connectWebmeshNode: ({ sessionInfo, webmeshNode }) => connectWebmeshNodeClientSession({ webmeshNode, sessionInfo, sharedWorker, devtoolsEnabled, schema }),
    registerBeforeUnload: (onBeforeUnload) => {
      if (typeof window !== "undefined" && typeof window.addEventListener === "function") {
        window.addEventListener("beforeunload", onBeforeUnload);
        return () => window.removeEventListener("beforeunload", onBeforeUnload);
      }
      return () => {
      };
    }
  });
  return clientSession;
}).pipe(UnexpectedError.mapToUnexpectedError);
var getPersistedId = (key, storageType) => {
  const makeId = () => nanoid(5);
  const storage = typeof window === "undefined" ? void 0 : storageType === "session" ? sessionStorage : storageType === "local" ? localStorage : shouldNeverHappen(`[@livestore/adapter-web] Invalid storage type: ${storageType}`);
  if (storage === void 0) {
    return makeId();
  }
  const fullKey = `livestore:${key}`;
  const storedKey = storage.getItem(fullKey);
  if (storedKey)
    return storedKey;
  const newKey = makeId();
  storage.setItem(fullKey, newKey);
  return newKey;
};
var ensureBrowserRequirements = Effect_exports.gen(function* () {
  const validate = (condition, label) => Effect_exports.gen(function* () {
    if (condition) {
      yield* UnexpectedError.make({
        cause: `[@livestore/adapter-web] Browser not supported. The LiveStore web adapter needs '${label}' to work properly`
      });
    }
  });
  yield* Effect_exports.all([
    validate(typeof navigator === "undefined", "navigator"),
    validate(navigator.locks === void 0, "navigator.locks"),
    validate(navigator.storage === void 0, "navigator.storage"),
    validate(crypto.randomUUID === void 0, "crypto.randomUUID"),
    validate(typeof window === "undefined", "window"),
    validate(typeof sessionStorage === "undefined", "sessionStorage")
  ]);
});

// node_modules/.pnpm/@livestore+adapter-web@0.3.1_505c75a1204e4cf21acbbd6b3e225a6b/node_modules/@livestore/adapter-web/dist/in-memory/in-memory-adapter.js
var sqlite3Promise2 = loadSqlite3Wasm();
var makeInMemoryAdapter = (options = {}) => (adapterArgs) => Effect_exports.gen(function* () {
  var _a;
  const { schema, shutdown, syncPayload, storeId, devtoolsEnabled } = adapterArgs;
  const sqlite3 = yield* Effect_exports.promise(() => sqlite3Promise2);
  const sqliteDb = yield* sqliteDbFactory({ sqlite3 })({ _tag: "in-memory" });
  const clientId = options.clientId ?? nanoid(6);
  const sessionId = options.sessionId ?? nanoid(6);
  const sharedWebWorker = ((_a = options.devtools) == null ? void 0 : _a.sharedWorker) ? tryAsFunctionAndNew(options.devtools.sharedWorker, {
    name: `livestore-shared-worker-${storeId}`
  }) : void 0;
  const sharedWorkerFiber = sharedWebWorker ? yield* Worker_exports.makePoolSerialized({
    size: 1,
    concurrency: 100
  }).pipe(Effect_exports.provide(BrowserWorker_exports.layer(() => sharedWebWorker)), Effect_exports.tapCauseLogPretty, UnexpectedError.mapToUnexpectedError, Effect_exports.forkScoped) : void 0;
  const { leaderThread, initialSnapshot } = yield* makeLeaderThread({
    schema,
    storeId,
    clientId,
    makeSqliteDb: sqliteDbFactory({ sqlite3 }),
    syncOptions: options.sync,
    syncPayload,
    importSnapshot: options.importSnapshot,
    devtoolsEnabled,
    sharedWorkerFiber
  });
  sqliteDb.import(initialSnapshot);
  const lockStatus = yield* SubscriptionRef_exports.make("has-lock");
  const clientSession = yield* makeClientSession({
    ...adapterArgs,
    sqliteDb,
    clientId,
    sessionId,
    isLeader: true,
    leaderThread,
    lockStatus,
    shutdown,
    webmeshMode: "direct",
    connectWebmeshNode: ({ sessionInfo, webmeshNode }) => Effect_exports.gen(function* () {
      if (sharedWorkerFiber === void 0 || devtoolsEnabled === false) {
        return;
      }
      const sharedWorker = yield* sharedWorkerFiber.pipe(Fiber_exports.join);
      yield* connectWebmeshNodeClientSession({ webmeshNode, sessionInfo, sharedWorker, devtoolsEnabled, schema });
    }),
    registerBeforeUnload: (onBeforeUnload) => {
      if (typeof window !== "undefined" && typeof window.addEventListener === "function") {
        window.addEventListener("beforeunload", onBeforeUnload);
        return () => window.removeEventListener("beforeunload", onBeforeUnload);
      }
      return () => {
      };
    }
  });
  return clientSession;
}).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports.provide(FetchHttpClient_exports.layer));
var makeLeaderThread = ({ schema, storeId, clientId, makeSqliteDb, syncOptions, syncPayload, importSnapshot, devtoolsEnabled, sharedWorkerFiber }) => Effect_exports.gen(function* () {
  const runtime = yield* Effect_exports.runtime();
  const makeDb = (_kind) => {
    return makeSqliteDb({
      _tag: "in-memory",
      configureDb: (db) => configureConnection(db, { foreignKeys: true }).pipe(Effect_exports.provide(runtime), Effect_exports.runSync)
    });
  };
  const shutdownChannel = yield* makeShutdownChannel(storeId);
  const [dbState, dbEventlog] = yield* Effect_exports.all([makeDb("state"), makeDb("eventlog")], { concurrency: 2 });
  if (importSnapshot) {
    dbState.import(importSnapshot);
  }
  const devtoolsOptions = yield* makeDevtoolsOptions({
    devtoolsEnabled,
    sharedWorkerFiber,
    dbState,
    dbEventlog,
    storeId,
    clientId
  });
  const layer = yield* Layer_exports.build(makeLeaderThreadLayer({
    schema,
    storeId,
    clientId,
    makeSqliteDb,
    syncOptions,
    dbState,
    dbEventlog,
    devtoolsOptions,
    shutdownChannel,
    syncPayload
  }));
  return yield* Effect_exports.gen(function* () {
    const { dbState: dbState2, dbEventlog: dbEventlog2, syncProcessor, extraIncomingMessagesQueue, initialState } = yield* LeaderThreadCtx;
    const initialLeaderHead = eventlog_exports.getClientHeadFromDb(dbEventlog2);
    const leaderThread = {
      events: {
        pull: ({ cursor }) => syncProcessor.pull({ cursor }),
        push: (batch) => syncProcessor.push(batch.map((item) => new LiveStoreEvent_exports.EncodedWithMeta(item)), { waitForProcessing: true })
      },
      initialState: { leaderHead: initialLeaderHead, migrationsReport: initialState.migrationsReport },
      export: Effect_exports.sync(() => dbState2.export()),
      getEventlogData: Effect_exports.sync(() => dbEventlog2.export()),
      getSyncState: syncProcessor.syncState,
      sendDevtoolsMessage: (message) => extraIncomingMessagesQueue.offer(message)
    };
    const initialSnapshot = dbState2.export();
    return { leaderThread, initialSnapshot };
  }).pipe(Effect_exports.provide(layer));
});
var makeDevtoolsOptions = ({ devtoolsEnabled, sharedWorkerFiber, dbState, dbEventlog, storeId, clientId }) => Effect_exports.gen(function* () {
  if (devtoolsEnabled === false || sharedWorkerFiber === void 0) {
    return { enabled: false };
  }
  return {
    enabled: true,
    boot: Effect_exports.gen(function* () {
      const persistenceInfo = {
        state: dbState.metadata.persistenceInfo,
        eventlog: dbEventlog.metadata.persistenceInfo
      };
      const node = yield* makeMeshNode(mod_exports2.makeNodeName.client.leader({ storeId, clientId }));
      globalThis.__debugWebmeshNodeLeader = node;
      const sharedWorker = yield* sharedWorkerFiber.pipe(Fiber_exports.join);
      yield* connectViaWorker({
        node,
        worker: sharedWorker,
        target: makeNodeName.sharedWorker({ storeId })
      }).pipe(Effect_exports.tapCauseLogPretty, Effect_exports.forkScoped);
      return { node, persistenceInfo, mode: "direct" };
    })
  };
});
export {
  worker_schema_exports as WorkerSchema,
  makeInMemoryAdapter,
  makePersistedAdapter
};
//# sourceMappingURL=@livestore_adapter-web.js.map
